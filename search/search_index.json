{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Danger</p> <p>This is the prototype documentation and need a rework!</p> <p>Info</p> <p>If you find some bugs don't hesitate to mail at Hochschule Nordhausen</p> <p></p>"},{"location":"#developed-and-maintained-by","title":"Developed and maintained by","text":""},{"location":"#contact","title":"Contact","text":"<p>Tip</p> <p>Using mail is the best way to get in contact.</p> <p>Thank you!</p> <p>Hochschule Nordhausen Institut f\u00fcr regenerative Energietechnik Weinberghof 4 99734 Nordhausen ensys@hs-nordhausen.de ensys.hs-nordhausen.de</p>"},{"location":"about/","title":"About inretensys-backend","text":""},{"location":"about/#software","title":"Software","text":"<p>to be done.</p>"},{"location":"about/#team","title":"Team","text":"<p>See Institut f\u00fcr Regnerative Energietechnik</p>"},{"location":"about/#oemofsolph","title":"oemof.solph","text":"<p>See oemof-Website.</p>"},{"location":"possibilities/","title":"Developer Doc Help","text":"<p>Note</p> <p>Dient der Veranschaulichung ausgew\u00e4hlter M\u00f6glichkeiten</p> <p>Tip</p> <p>Weitere Informationen in folgenden Dokumenationen</p> <ul> <li>mkDocs</li> <li>mkDocs-Material</li> </ul>"},{"location":"possibilities/#heading","title":"Heading","text":"<p>Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. </p>"},{"location":"possibilities/#subsubheading","title":"Subsubheading","text":"<p>Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat. Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi.   </p>"},{"location":"possibilities/#subsubheading_1","title":"Subsubheading","text":"<p>Nam liber tempor cum soluta nobis eleifend option congue nihil imperdiet doming id quod mazim placerat facer possim assum. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. </p>"},{"location":"possibilities/#subheading","title":"Subheading","text":"<p>Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis.   </p>"},{"location":"possibilities/#code-and-latex","title":"Code and LaTeX","text":"<pre><code>print(\"hallo welt\")\n\nx: str = \"dingsda\"\n\nif x == \"dingsda\":\n    print(\"Motor aus\")\nelif x == \"ninja\":\n    print(\"Motor an\")\nelse:\n    print(\"Motor m\u00fcde, Motor schlafen\")\n\nreturn xyz\n</code></pre> <p>Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.   </p> \\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\] <p>Nam liber tempor cum soluta nobis eleifend option congue nihil imperdiet doming id quod mazim placerat facer possim assum. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.   </p> <pre><code>$$\n\\sum^5_{i=1} x \\cdot y_i = e^x\n$$\n</code></pre> \\[ \\sum^5_{i=1} x \\cdot y_i = e^x \\] <p>Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.   </p>"},{"location":"possibilities/#mermaid","title":"Mermaid","text":""},{"location":"possibilities/#pap","title":"PAP","text":"<pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre>"},{"location":"possibilities/#sqeuence-diagram","title":"Sqeuence Diagram","text":"<pre><code>sequenceDiagram\n  autonumber\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n      John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!</code></pre>"},{"location":"possibilities/#tabs","title":"Tabs","text":"CC++ <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n  printf(\"Hello world!\\n\");\n  return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nint main(void) {\n  std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>"},{"location":"possibilities/#lists-and-task-lists","title":"Lists and Task Lists","text":""},{"location":"possibilities/#lists","title":"Lists","text":"<ol> <li> <p>Vivamus id mi enim. Integer id turpis sapien. Ut condimentum lobortis     sagittis. Aliquam purus tellus, faucibus eget urna at, iaculis venenatis     nulla. Vivamus a pharetra leo.</p> <ol> <li> <p>Vivamus venenatis porttitor tortor sit amet rutrum. Pellentesque aliquet     quam enim, eu volutpat urna rutrum a. Nam vehicula nunc mauris, a     ultricies libero efficitur sed.</p> </li> <li> <p>Morbi eget dapibus felis. Vivamus venenatis porttitor tortor sit amet     rutrum. Pellentesque aliquet quam enim, eu volutpat urna rutrum a.</p> <ol> <li>Mauris dictum mi lacus</li> <li>Ut sit amet placerat ante</li> <li>Suspendisse ac eros arcu</li> </ol> </li> </ol> </li> </ol>"},{"location":"possibilities/#task-lists","title":"Task lists","text":"<ul> <li> Lorem ipsum dolor sit amet, consectetur adipiscing elit</li> <li> Vestibulum convallis sit amet nisi a tincidunt<ul> <li> In hac habitasse platea dictumst</li> <li> In scelerisque nibh non dolor mollis congue sed et metus</li> <li> Praesent sed risus massa</li> </ul> </li> <li> Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque</li> </ul>"},{"location":"backend/","title":"Backend","text":"<p>All information for the backend documentation can be found in the FastAPI web interface.</p> <p>Info</p> <p>Links are given for local deployment</p> <p>Therefore you should go to:</p> <ul> <li>Swagger UI (/docs)</li> <li>Redoc Documentation /redoc</li> </ul>"},{"location":"backend/api/celery/","title":"celery","text":""},{"location":"backend/api/celery/#app.celery.simulation_task","title":"<code>simulation_task(scenario_id, simulation_id)</code>","text":"<p>Perform simulation task including data preparation, energy system creation, optimization, and result processing.</p> <p>This function is a Celery task that interacts with a database to fetch simulation and scenario data. It creates an energy system model, optimizes using the oemof library, processes the results, and updates the database with the results of the simulation.</p> <p>Detailed actions performed by the function include: - Fetching scenario and simulation details from the database. - Preparing necessary directory structures and dumping input data. - Configuring and initializing the oemof energy system. - Solving an optimization model using specified solver parameters. - Writing optimization results to files for further analysis. - Updating the status of the simulation task in the database.</p> <p>Parameters:</p> Name Type Description Default <code>scenario_id</code> <code>int</code> <p>Identifier of the scenario to be simulated.</p> required <code>simulation_id</code> <code>int</code> <p>Identifier of the simulation instance.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>backend/app/celery.py</code> <pre><code>@celery_app.task(name=\"ensys.optimization\")\ndef simulation_task(scenario_id: int, simulation_id: int):\n    \"\"\"\n    Perform simulation task including data preparation, energy system creation, optimization,\n    and result processing.\n\n    This function is a Celery task that interacts with a database to fetch simulation and\n    scenario data. It creates an energy system model, optimizes using the oemof library,\n    processes the results, and updates the database with the results of the simulation.\n\n    Detailed actions performed by the function include:\n    - Fetching scenario and simulation details from the database.\n    - Preparing necessary directory structures and dumping input data.\n    - Configuring and initializing the oemof energy system.\n    - Solving an optimization model using specified solver parameters.\n    - Writing optimization results to files for further analysis.\n    - Updating the status of the simulation task in the database.\n\n    :param scenario_id: Identifier of the scenario to be simulated.\n    :type scenario_id: int\n    :param simulation_id: Identifier of the simulation instance.\n    :type simulation_id: int\n    :return: None\n    \"\"\"\n    task_counter.inc()\n    task_in_progress.inc()\n\n    db = Session(create_engine(os.getenv(\"DATABASE_URL\")))\n    scenario = db.get(EnScenarioDB, scenario_id)\n    simulation = db.get(EnSimulationDB, simulation_id)\n    simulation_token = simulation.sim_token\n\n    dump_path = os.path.join(os.getenv(\"LOCAL_DATADIR\"), simulation_token, \"dump\")\n    log_path = os.path.join(os.getenv(\"LOCAL_DATADIR\"), simulation_token, \"log\")\n    os.makedirs(dump_path, exist_ok=True)\n    os.makedirs(log_path, exist_ok=True)\n\n    logger = get_task_logger(__name__)\n\n    # Create Energysystem to be stored\n    energysystem_api = scenario.energysystem_model\n    simulation_model = EnModel(\n        energysystem=energysystem_api\n    )\n\n    simulation_folder = os.path.abspath(os.path.join(os.getenv(\"LOCAL_DATADIR\"), simulation_token))\n    os.makedirs(\n        name=simulation_folder,\n        exist_ok=True\n    )\n\n    with open(os.path.join(simulation_folder, \"es_\" + simulation_token + \".json\"), \"wt\") as f:\n        f.write(simulation_model.model_dump_json())\n\n    logger.info(\"read scenario data from database\")\n    scenario = db.exec(select(EnScenarioDB).where(EnScenarioDB.id == scenario_id)).first()\n\n    print(f\"Scenario Interval:{scenario.interval}\")\n    print(f\"Scenario Timesteps:{scenario.time_steps}\")\n    print(f\"Scenario Startdate:{scenario.start_date}\")\n    print(f\"Scenario Startdate:{type(scenario.start_date)}\")\n    print(f\"Scenario Startdate:{scenario.start_date.year}\")\n\n    logger.info(\"create oemof energy system\")\n    timeindex = solph.create_time_index(\n        start=scenario.start_date,\n        number=scenario.time_steps,\n        interval=scenario.interval,\n    )\n\n    print(f\"timeindex:{timeindex}\")\n    oemof_es: solph.EnergySystem = solph.EnergySystem(\n        timeindex=timeindex,\n        infer_last_interval=False\n    )\n\n    oemof_es = simulation_model.energysystem.to_oemof_energysystem(oemof_es)\n\n    # create the model for optimization\n    logger.info(\"create simulation model\")\n    oemof_model = solph.Model(oemof_es)\n\n    # solve the optimization model\n    logger.info(\"solve optimization model\")\n    oemof_model.solve(\n        solver=str(simulation_model.solver.value),\n        solve_kwargs=simulation_model.solver_kwargs if hasattr(simulation_model, \"solver_kwargs\") else {\"tee\": True},\n        cmdline_opts={\"logfile\": os.path.join(log_path, \"solver.log\")}\n    )\n\n    logger.info(\"simulation finished\")\n    # write the lp file for specific analysis\n    logger.info(\"write lp file\")\n    oemof_model.write(\n        filename=os.path.join(dump_path, \"oemof_model.lp\"),\n        io_options={\"symbolic_solver_labels\": True}\n    )\n\n    logger.info(\"collect results\")\n    oemof_es.results[\"main\"] = solph.processing.results(oemof_model)\n    oemof_es.results[\"meta\"] = solph.processing.meta_results(oemof_model)\n\n    logger.info(\"dump results\")\n    oemof_es.dump(\n        dpath=dump_path,\n        filename=\"oemof_es.dump\"\n    )\n\n    logger.info(\"update database\")\n    simulation.status = Status.FINISHED.value\n    simulation.end_date = datetime.now()\n    db.commit()\n    db.refresh(simulation)\n    logger.info(\"backgroundtask finished\")\n\n    task_in_progress.dec()\n</code></pre>"},{"location":"backend/api/db/","title":"db","text":""},{"location":"backend/api/db/#app.db.get_db_session","title":"<code>get_db_session()</code>","text":"<p>Creates and provides a database session.</p> <p>This function is designed to yield a database session for interacting with the database. The session is created using the given database engine and is managed within a context to ensure proper cleanup after usage.</p> <p>Yields:     session: A database session object for database operations.</p> <p>Returns:</p> Type Description <p>Yields database session objects.</p> Source code in <code>backend/app/db.py</code> <pre><code>def get_db_session():\n    \"\"\"\n    Creates and provides a database session.\n\n    This function is designed to yield a database session for interacting with the\n    database. The session is created using the given database engine and is\n    managed within a context to ensure proper cleanup after usage.\n\n    Yields:\n        session: A database session object for database operations.\n\n    :return: Yields database session objects.\n    \"\"\"\n    with Session(db_engine) as session:\n        yield session\n</code></pre>"},{"location":"backend/api/main/","title":"main","text":""},{"location":"backend/api/main/#app.main.lifespan","title":"<code>lifespan(fastapi_app)</code>  <code>async</code>","text":"<p>Manages the lifespan of a FastAPI application, handling setup during startup and cleanup during shutdown.</p> <p>This function is meant to be used as an async context manager for setting up and tearing down application-wide resources or configurations in a uniform way.</p> <p>Parameters:</p> Name Type Description Default <code>fastapi_app</code> <code>FastAPI</code> <p>Instance of the FastAPI application</p> required <p>Returns:</p> Type Description <code>AsyncIterator[None]</code> <p>Async context for managing the lifespan of the FastAPI application</p> Source code in <code>backend/app/main.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(fastapi_app: FastAPI):\n    \"\"\"\n    Manages the lifespan of a FastAPI application, handling setup during startup and cleanup\n    during shutdown.\n\n    This function is meant to be used as an async context manager for setting up and tearing\n    down application-wide resources or configurations in a uniform way.\n\n    :param fastapi_app: Instance of the FastAPI application\n    :type fastapi_app: FastAPI\n    :return: Async context for managing the lifespan of the FastAPI application\n    :rtype: AsyncIterator[None]\n    \"\"\"\n    # startup event\n    yield\n</code></pre>"},{"location":"backend/api/responses/","title":"responses","text":""},{"location":"backend/api/responses/#app.responses.DataResponse","title":"<code>DataResponse</code>","text":"<p>               Bases: <code>GeneralResponse</code></p> <p>Represents a response containing general data, inheriting from the GeneralResponse.</p> <p>This class is used for defining a response structure that includes the general data model. It enforces the inclusion of the general data field, ensuring proper structure and expected data handling as part of the response. It can be extended or utilized wherever a general data response entity is required.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>GeneralDataModel</code> <p>The general data model that represents the main content of the response.</p> Source code in <code>backend/app/responses.py</code> <pre><code>class DataResponse(GeneralResponse):\n    \"\"\"\n    Represents a response containing general data, inheriting from the\n    GeneralResponse.\n\n    This class is used for defining a response structure that includes the\n    general data model. It enforces the inclusion of the general data field,\n    ensuring proper structure and expected data handling as part of the response.\n    It can be extended or utilized wherever a general data response entity\n    is required.\n\n    :ivar data: The general data model that represents the main content of\n                the response.\n    :type data: GeneralDataModel\n    \"\"\"\n    data: GeneralDataModel = Field(...)\n</code></pre>"},{"location":"backend/api/responses/#app.responses.ErrorResponse","title":"<code>ErrorResponse</code>","text":"<p>               Bases: <code>GeneralResponse</code></p> <p>Represents an error response detailing the result of a failed operation.</p> <p>This class extends the GeneralResponse and is intended to provide a standard structure for reporting errors or unsuccessful operations in the application. It includes attributes that indicate the success status and any data related to the error response.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>None</code> <p>Data returned by the request. Default is None.</p> <code>success</code> <code>bool</code> <p>Indicates whether the request was successful or not. Default is False.</p> Source code in <code>backend/app/responses.py</code> <pre><code>class ErrorResponse(GeneralResponse):\n    \"\"\"\n    Represents an error response detailing the result of a failed operation.\n\n    This class extends the GeneralResponse and is intended to provide a standard\n    structure for reporting errors or unsuccessful operations in the application.\n    It includes attributes that indicate the success status and any data related\n    to the error response.\n\n    :ivar data: Data returned by the request. Default is None.\n    :type data: None\n    :ivar success: Indicates whether the request was successful or not. Default is False.\n    :type success: bool\n    \"\"\"\n    data: None = Field(\n        default=None,\n        description=\"Data returned by the request.\"\n    )\n    success: bool = Field(\n        default=False,\n        description=\"Indicates whether the request was successful or not.\"\n    )\n</code></pre>"},{"location":"backend/api/responses/#app.responses.GeneralResponse","title":"<code>GeneralResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the general response structure for API requests.</p> <p>This class encapsulates the standard response format, including the data returned, success status, and any errors that occurred during the request. It is utilized as the base model for structuring API responses.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>None</code> <p>Data returned by the request.</p> <code>success</code> <code>bool</code> <p>Indicates whether the request was successful or not.</p> <code>errors</code> <code>list[ErrorModel] | None</code> <p>List of errors encountered during the request.</p> Source code in <code>backend/app/responses.py</code> <pre><code>class GeneralResponse(BaseModel):\n    \"\"\"\n    Represents the general response structure for API requests.\n\n    This class encapsulates the standard response format, including the data\n    returned, success status, and any errors that occurred during the request.\n    It is utilized as the base model for structuring API responses.\n\n    :ivar data: Data returned by the request.\n    :type data: None\n    :ivar success: Indicates whether the request was successful or not.\n    :type success: bool\n    :ivar errors: List of errors encountered during the request.\n    :type errors: list[ErrorModel] | None\n    \"\"\"\n    data: None = Field(\n        default=None,\n        description=\"Data returned by the request.\"\n    )\n    success: bool = Field(\n        default=True,\n        description=\"Indicates whether the request was successful or not.\"\n    )\n    errors: list[ErrorModel] | None = Field(\n        default=None,\n        description=\"List of errors encountered during the request.\"\n    )\n</code></pre>"},{"location":"backend/api/responses/#app.responses.MessageResponse","title":"<code>MessageResponse</code>","text":"<p>               Bases: <code>GeneralResponse</code></p> <p>Represents a response message inheriting properties from <code>GeneralResponse</code>.</p> <p>This class is used to handle message responses with associated data and extends the general response functionality by including a specific 'data' attribute.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>str</code> <p>The content of the response message.</p> Source code in <code>backend/app/responses.py</code> <pre><code>class MessageResponse(GeneralResponse):\n    \"\"\"\n    Represents a response message inheriting properties from `GeneralResponse`.\n\n    This class is used to handle message responses with associated data and extends\n    the general response functionality by including a specific 'data' attribute.\n\n    :ivar data: The content of the response message.\n    :type data: str\n    \"\"\"\n    data: str = Field(...)\n</code></pre>"},{"location":"backend/api/responses/#app.responses.ResultResponse","title":"<code>ResultResponse</code>","text":"<p>               Bases: <code>GeneralResponse</code></p> <p>Represents a response containing result data, inheriting from GeneralResponse.</p> <p>This class is used to encapsulate response data specific to result information. It extends the functionality provided by GeneralResponse and includes additional data fields related to results. The purpose of this class is to standardize the structure of result-related responses and ensure consistent access to result data in the response object.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>ResultDataModel</code> <p>Contains the specific result data encapsulated in the ResultDataModel.</p> Source code in <code>backend/app/responses.py</code> <pre><code>class ResultResponse(GeneralResponse):\n    \"\"\"\n    Represents a response containing result data, inheriting from GeneralResponse.\n\n    This class is used to encapsulate response data specific to result information.\n    It extends the functionality provided by GeneralResponse and includes additional\n    data fields related to results. The purpose of this class is to standardize the\n    structure of result-related responses and ensure consistent access to result\n    data in the response object.\n\n    :ivar data: Contains the specific result data encapsulated in the ResultDataModel.\n    :type data: ResultDataModel\n    \"\"\"\n    data: ResultDataModel\n</code></pre>"},{"location":"backend/api/security/","title":"security","text":""},{"location":"backend/api/security/#app.security.decode_token","title":"<code>decode_token(token)</code>","text":"<p>Decode a JSON Web Token (JWT).</p> <p>This function takes a JSON Web Token (JWT) string and decodes it using the specified secret and algorithm. The decoded token data is returned, allowing further processing or validation.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The JWT string to decode.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Decoded token data.</p> Source code in <code>backend/app/security.py</code> <pre><code>def decode_token(token: str):\n    \"\"\"\n    Decode a JSON Web Token (JWT).\n\n    This function takes a JSON Web Token (JWT) string and decodes it using\n    the specified secret and algorithm. The decoded token data is returned,\n    allowing further processing or validation.\n\n    :param token: The JWT string to decode.\n    :type token: str\n    :return: Decoded token data.\n    :rtype: dict\n    \"\"\"\n    token_data = jwt.decode(token, token_secret, algorithms=[\"HS256\"])\n    return token_data\n</code></pre>"},{"location":"backend/api/models/data/","title":"data","text":""},{"location":"backend/api/models/data/#app.data.model.GeneralDataModel","title":"<code>GeneralDataModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>GeneralDataModel is a data model class that represents a generic data structure with a list of items and their total count.</p> <p>This class is designed for use cases where a representation of a collection of items alongside a count of those items is needed. It can serve as a base structure for applications working with paginated datasets, collections, or other similar utilities.</p> <p>Attributes:</p> Name Type Description <code>items</code> <code>list[Any]</code> <p>A list of items representing the data collection.</p> <code>totalCount</code> <code>int</code> <p>The total number of items in the collection.</p> Source code in <code>backend/app/data/model.py</code> <pre><code>class GeneralDataModel(BaseModel):\n    \"\"\"\n    GeneralDataModel is a data model class that represents a generic data structure\n    with a list of items and their total count.\n\n    This class is designed for use cases where a representation of a collection\n    of items alongside a count of those items is needed. It can serve as a base\n    structure for applications working with paginated datasets, collections, or\n    other similar utilities.\n\n    :ivar items: A list of items representing the data collection.\n    :type items: list[Any]\n    :ivar totalCount: The total number of items in the collection.\n    :type totalCount: int\n    \"\"\"\n    items: list[Any]\n    totalCount: int\n</code></pre>"},{"location":"backend/api/models/errors/","title":"errors","text":""},{"location":"backend/api/models/errors/#app.errors.model.ErrorModel","title":"<code>ErrorModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an error model containing details of an error.</p> <p>This class is used to encapsulate metadata for error conditions, such as the error code and the error message. It provides a structured way to convey error information within applications or across systems.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>int</code> <p>Error code for the error.</p> <code>message</code> <code>str</code> <p>Error message for the error.</p> Source code in <code>backend/app/errors/model.py</code> <pre><code>class ErrorModel(BaseModel):\n    \"\"\"\n    Represents an error model containing details of an error.\n\n    This class is used to encapsulate metadata for error conditions, such as\n    the error code and the error message. It provides a structured way to\n    convey error information within applications or across systems.\n\n    :ivar code: Error code for the error.\n    :type code: int\n    :ivar message: Error message for the error.\n    :type message: str\n    \"\"\"\n    code: int = Field(\n        description=\"Error code for the error.\",\n    )\n    message: str = Field(\n        description=\"Error message for the error.\",\n    )\n</code></pre>"},{"location":"backend/api/models/project/","title":"project","text":""},{"location":"backend/api/models/project/#app.project.model.EnProject","title":"<code>EnProject</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Represents a project entity with details regarding its name, description, location, energy unit, CO2 unit, currency, geographical coordinates, and favorite status.</p> <p>This class is intended to encapsulate core information about a project, such as its basic details and metadata, allowing for clear organization and representation in a database. The attributes include constraints for data validation.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the project must be between 1 and 100 characters.</p> <code>description</code> <code>str | None</code> <p>An optional description of the project, up to 255 characters.</p> <code>country</code> <code>str</code> <p>The country where the project is located, max length of 40 characters.</p> <code>unit_energy</code> <code>str</code> <p>The energy unit associated with the project, max length of 10 characters.</p> <code>unit_co2</code> <code>str</code> <p>The CO2 unit associated with the project, max length of 10 characters.</p> <code>currency</code> <code>str</code> <p>The currency used in the project, max length of 8 characters.</p> <code>longitude</code> <code>float</code> <p>The longitude coordinate of the project location. Can be null.</p> <code>latitude</code> <code>float</code> <p>The latitude coordinate of the project location. Can be null.</p> <code>is_favorite</code> <code>bool</code> <p>Indicates if the project is marked as a favorite. Defaults to False.</p> Source code in <code>backend/app/project/model.py</code> <pre><code>class EnProject(SQLModel):\n    \"\"\"\n    Represents a project entity with details regarding its name, description, location,\n    energy unit, CO2 unit, currency, geographical coordinates, and favorite status.\n\n    This class is intended to encapsulate core information about a project, such as\n    its basic details and metadata, allowing for clear organization and representation\n    in a database. The attributes include constraints for data validation.\n\n    :ivar name: The name of the project must be between 1 and 100 characters.\n    :type name: str\n    :ivar description: An optional description of the project, up to 255 characters.\n    :type description: str | None\n    :ivar country: The country where the project is located, max length of 40 characters.\n    :type country: str\n    :ivar unit_energy: The energy unit associated with the project, max length of 10 characters.\n    :type unit_energy: str\n    :ivar unit_co2: The CO2 unit associated with the project, max length of 10 characters.\n    :type unit_co2: str\n    :ivar currency: The currency used in the project, max length of 8 characters.\n    :type currency: str\n    :ivar longitude: The longitude coordinate of the project location. Can be null.\n    :type longitude: float\n    :ivar latitude: The latitude coordinate of the project location. Can be null.\n    :type latitude: float\n    :ivar is_favorite: Indicates if the project is marked as a favorite. Defaults to False.\n    :type is_favorite: bool\n    \"\"\"\n    name: str = Field(min_length=1, max_length=100)\n    description: str | None = Field(default=None, min_length=1, max_length=255, nullable=True)\n    country: str = Field(min_length=1, max_length=40)\n    unit_energy: str = Field(min_length=1, max_length=10)\n    unit_co2: str = Field(min_length=1, max_length=10)\n    currency: str = Field(min_length=1, max_length=8)\n    longitude: float = Field(nullable=True)\n    latitude: float = Field(nullable=True)\n    is_favorite: bool = Field(default=False)\n</code></pre>"},{"location":"backend/api/models/project/#app.project.model.EnProjectDB","title":"<code>EnProjectDB</code>","text":"<p>               Bases: <code>EnProject</code></p> <p>Represents the EnProjectDB entity that defines the structure of the \"projects\" database table and inherits from the EnProject class.</p> <p>This class is used to model and manipulate project data within the database, providing details such as project ID, associated user ID, creation timestamp, and update timestamp.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Unique identifier for the project.</p> <code>user_id</code> <code>int</code> <p>ID of the user associated with the project.</p> <code>date_created</code> <code>datetime</code> <p>Timestamp indicating when the project was created.</p> <code>date_updated</code> <code>datetime | None</code> <p>Timestamp indicating when the project was last updated or None if not updated.</p> Source code in <code>backend/app/project/model.py</code> <pre><code>class EnProjectDB(EnProject, table=True):\n    \"\"\"\n    Represents the EnProjectDB entity that defines the structure of the \"projects\" database\n    table and inherits from the EnProject class.\n\n    This class is used to model and manipulate project data within the database, providing\n    details such as project ID, associated user ID, creation timestamp, and update timestamp.\n\n    :ivar id: Unique identifier for the project.\n    :type id: int\n    :ivar user_id: ID of the user associated with the project.\n    :type user_id: int\n    :ivar date_created: Timestamp indicating when the project was created.\n    :type date_created: datetime\n    :ivar date_updated: Timestamp indicating when the project was last updated or None if not updated.\n    :type date_updated: datetime | None\n    \"\"\"\n    __tablename__ = \"projects\"\n\n    id: int = Field(default=None, primary_key=True)\n    user_id: int = Field(foreign_key=\"users.id\")\n    date_created: datetime = Field(default=datetime.now)\n    date_updated: datetime | None = Field(default=None)\n\n    def get_return_data(self):\n        return self.dict(exclude={\"user_id\"})\n</code></pre>"},{"location":"backend/api/models/project/#app.project.model.EnProjectUpdate","title":"<code>EnProjectUpdate</code>","text":"<p>               Bases: <code>EnProject</code></p> <p>Represents an updated project with additional configurable fields.</p> <p>This class is a subclass of <code>EnProject</code> and is designed to provide additional fields and configuration options for a project's update. It allows for modification of the project's name, country, energy and CO2 units, currency, as well as geographical coordinates (longitude and latitude).</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str | None</code> <p>Name of the project. This is an optional field that must have a length between 1 and 100 characters if provided.</p> <code>country</code> <code>str | None</code> <p>Country associated with the project. This is an optional field that must have a length between 1 and 40 characters if provided.</p> <code>unit_energy</code> <code>str | None</code> <p>Unit of energy measurement for the project. This is an optional field that must have a length between 1 and 10 characters if provided.</p> <code>unit_co2</code> <code>str | None</code> <p>Unit of CO2 measurement for the project. This is an optional field that must have a length between 1 and 10 characters if provided.</p> <code>currency</code> <code>str | None</code> <p>Currency used for the project. This is a required field that must have a length between 1 and 8 characters.</p> <code>longitude</code> <code>float | None</code> <p>Longitude value of the project's geographical location. This is an optional field.</p> <code>latitude</code> <code>float | None</code> <p>Latitude value of the project's geographical location. This is an optional field.</p> Source code in <code>backend/app/project/model.py</code> <pre><code>class EnProjectUpdate(EnProject):\n    \"\"\"\n    Represents an updated project with additional configurable fields.\n\n    This class is a subclass of `EnProject` and is designed to provide\n    additional fields and configuration options for a project's update. It\n    allows for modification of the project's name, country, energy and CO2\n    units, currency, as well as geographical coordinates (longitude and\n    latitude).\n\n    :ivar name: Name of the project. This is an optional field that must have\n        a length between 1 and 100 characters if provided.\n    :ivar country: Country associated with the project. This is an optional\n        field that must have a length between 1 and 40 characters if provided.\n    :ivar unit_energy: Unit of energy measurement for the project. This is an\n        optional field that must have a length between 1 and 10 characters if\n        provided.\n    :ivar unit_co2: Unit of CO2 measurement for the project. This is an\n        optional field that must have a length between 1 and 10 characters if\n        provided.\n    :ivar currency: Currency used for the project. This is a required field\n        that must have a length between 1 and 8 characters.\n    :ivar longitude: Longitude value of the project's geographical location.\n        This is an optional field.\n    :ivar latitude: Latitude value of the project's geographical location.\n        This is an optional field.\n    \"\"\"\n    name: str | None = Field(default=None, min_length=1, max_length=100, nullable=True)\n    country: str | None = Field(default=None, min_length=1, max_length=40, nullable=True)\n    unit_energy: str | None = Field(default=None, min_length=1, max_length=10, nullable=True)\n    unit_co2: str | None = Field(default=None, min_length=1, max_length=10, nullable=True)\n    currency: str | None = Field(min_length=1, max_length=8)\n    longitude: float | None = Field(default=None, nullable=True)\n    latitude: float | None = Field(default=None, nullable=True)\n</code></pre>"},{"location":"backend/api/models/results/","title":"results","text":""},{"location":"backend/api/models/results/#app.results.model.EnDataFrame","title":"<code>EnDataFrame</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a data model for a DataFrame-like structure with enhanced time series data.</p> <p>This class is designed to manage and store time series data associated with a specific name and a corresponding index of datetime values.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the data frame.</p> <code>index</code> <code>list[datetime]</code> <p>List of datetime objects representing the index of the data frame.</p> <code>data</code> <code>list[EnTimeSeries]</code> <p>List of EnTimeSeries objects representing the time series data.</p> Source code in <code>backend/app/results/model.py</code> <pre><code>class EnDataFrame(BaseModel):\n    \"\"\"\n    Represents a data model for a DataFrame-like structure with enhanced time series data.\n\n    This class is designed to manage and store time series data associated with a specific\n    name and a corresponding index of datetime values.\n\n    :ivar name: Name of the data frame.\n    :type name: str\n    :ivar index: List of datetime objects representing the index of the data frame.\n    :type index: list[datetime]\n    :ivar data: List of EnTimeSeries objects representing the time series data.\n    :type data: list[EnTimeSeries]\n    \"\"\"\n    name: str\n    index: list[datetime]\n    data: list[EnTimeSeries]\n</code></pre>"},{"location":"backend/api/models/results/#app.results.model.EnTimeSeries","title":"<code>EnTimeSeries</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a time series data model with a name and corresponding data points.</p> <p>This class provides a structure for storing time series data which includes a descriptive name and a list of numerical data points. It can be used for various time-based data analysis and storage requirements.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the time series.</p> <code>data</code> <code>list[float]</code> <p>A list of numerical data points representing the time series.</p> Source code in <code>backend/app/results/model.py</code> <pre><code>class EnTimeSeries(BaseModel):\n    \"\"\"\n    Represents a time series data model with a name and corresponding data points.\n\n    This class provides a structure for storing time series data which includes\n    a descriptive name and a list of numerical data points. It can be used for\n    various time-based data analysis and storage requirements.\n\n    :ivar name: The name of the time series.\n    :type name: str\n    :ivar data: A list of numerical data points representing the time series.\n    :type data: list[float]\n    \"\"\"\n    name: str\n    data: list[float]\n</code></pre>"},{"location":"backend/api/models/results/#app.results.model.ResultDataModel","title":"<code>ResultDataModel</code>","text":"<p>               Bases: <code>GeneralDataModel</code></p> <p>Represents a specialized data model for storing results.</p> <p>Inherits from the <code>GeneralDataModel</code> and is used specifically for storing a collection of <code>EnDataFrame</code> objects. This class helps organize and manage the result data in a structured manner.</p> <p>Attributes:</p> Name Type Description <code>items</code> <code>list[EnDataFrame]</code> <p>A collection of <code>EnDataFrame</code> objects representing the data stored in the model.</p> Source code in <code>backend/app/results/model.py</code> <pre><code>class ResultDataModel(GeneralDataModel):\n    \"\"\"\n    Represents a specialized data model for storing results.\n\n    Inherits from the `GeneralDataModel` and is used specifically\n    for storing a collection of `EnDataFrame` objects. This class\n    helps organize and manage the result data in a structured manner.\n\n    :ivar items: A collection of `EnDataFrame` objects representing\n        the data stored in the model.\n    :type items: list[EnDataFrame]\n    \"\"\"\n    items: list[EnDataFrame]\n</code></pre>"},{"location":"backend/api/models/scenario/","title":"scenario","text":""},{"location":"backend/api/models/scenario/#app.scenario.model.EnScenario","title":"<code>EnScenario</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an energy scenario with detailed specifications and attributes.</p> <p>The EnScenario class models a scenario in an energy system setting, incorporating various attributes such as name, start date, time steps, interval, and associated energy system models. This facilitates structured handling of scenario data within an energy modeling system.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the energy scenario. Must be between 1 and 100 characters.</p> <code>start_date</code> <code>date</code> <p>The starting date for the scenario. Defaults to the current date.</p> <code>time_steps</code> <code>int | None</code> <p>The number of time steps in the scenario. Can be None for no specific limit or defaults to 8760.</p> <code>interval</code> <code>float</code> <p>The interval between each time step in hours. Defaults to 1.0.</p> <code>project_id</code> <code>int</code> <p>Identifier for the project to which the scenario belongs.</p> <code>energysystem_model</code> <code>EnEnergysystem</code> <p>The associated energy system model for the scenario.</p> Source code in <code>backend/app/scenario/model.py</code> <pre><code>class EnScenario(BaseModel):\n    \"\"\"\n    Represents an energy scenario with detailed specifications and attributes.\n\n    The EnScenario class models a scenario in an energy system setting, incorporating\n    various attributes such as name, start date, time steps, interval, and associated\n    energy system models. This facilitates structured handling of scenario data within\n    an energy modeling system.\n\n    :ivar name: Name of the energy scenario. Must be between 1 and 100 characters.\n    :type name: str\n    :ivar start_date: The starting date for the scenario. Defaults to the current date.\n    :type start_date: date\n    :ivar time_steps: The number of time steps in the scenario. Can be None for no specific\n                      limit or defaults to 8760.\n    :type time_steps: int | None\n    :ivar interval: The interval between each time step in hours. Defaults to 1.0.\n    :type interval: float\n    :ivar project_id: Identifier for the project to which the scenario belongs.\n    :type project_id: int\n    :ivar energysystem_model: The associated energy system model for the scenario.\n    :type energysystem_model: EnEnergysystem\n    \"\"\"\n    name: str = Field(min_length=1, max_length=100)\n    start_date: date = Field(default=datetime.now().date()) # start\n    time_steps: int | None = Field(default=8760, nullable=True) # number\n    interval: float = Field(default=1.0)  # interval\n    project_id: int\n    energysystem_model: EnEnergysystem = Field(default={})\n</code></pre>"},{"location":"backend/api/models/scenario/#app.scenario.model.EnScenarioDB","title":"<code>EnScenarioDB</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Represents the database model for energy scenario information.</p> <p>This class defines a database model for storing information about energy scenarios. It utilizes SQLModel with table mapping enabled to represent the corresponding table in the database. The class includes various fields that describe properties of the energy scenario, such as its name, associated project and user IDs, start date, time steps, and other relevant details.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key of the scenario record.</p> <code>name</code> <code>str</code> <p>Name of the energy scenario, must be between 1 and 100 characters in length.</p> <code>start_date</code> <code>date</code> <p>Start date of the energy scenario. This is a required field.</p> <code>time_steps</code> <code>int | None</code> <p>Number of time steps in the energy scenario. Defaults to 8760 if not provided and is nullable.</p> <code>interval</code> <code>float</code> <p>Time interval associated with the energy scenario. Defaults to 1.</p> <code>project_id</code> <code>int</code> <p>Foreign key referencing the associated project for the scenario.</p> <code>user_id</code> <code>int</code> <p>Foreign key referencing the user associated with the scenario.</p> <code>energysystem_model</code> <code>EnEnergysystem</code> <p>JSONB column storing the energy system model associated with the scenario. Defaults to an empty dictionary.</p> Source code in <code>backend/app/scenario/model.py</code> <pre><code>class EnScenarioDB(SQLModel, table=True):\n    \"\"\"\n    Represents the database model for energy scenario information.\n\n    This class defines a database model for storing information about\n    energy scenarios. It utilizes SQLModel with table mapping enabled\n    to represent the corresponding table in the database. The class\n    includes various fields that describe properties of the energy\n    scenario, such as its name, associated project and user IDs, start\n    date, time steps, and other relevant details.\n\n    :ivar id: Primary key of the scenario record.\n    :type id: int\n    :ivar name: Name of the energy scenario, must be between 1 and 100\n        characters in length.\n    :type name: str\n    :ivar start_date: Start date of the energy scenario. This is a required\n        field.\n    :type start_date: date\n    :ivar time_steps: Number of time steps in the energy scenario.\n        Defaults to 8760 if not provided and is nullable.\n    :type time_steps: int | None\n    :ivar interval: Time interval associated with the energy scenario.\n        Defaults to 1.\n    :type interval: float\n    :ivar project_id: Foreign key referencing the associated project for\n        the scenario.\n    :type project_id: int\n    :ivar user_id: Foreign key referencing the user associated with the\n        scenario.\n    :type user_id: int\n    :ivar energysystem_model: JSONB column storing the energy system\n        model associated with the scenario. Defaults to an empty\n        dictionary.\n    :type energysystem_model: EnEnergysystem\n    \"\"\"\n    __tablename__ = \"scenarios\"\n\n    id: int = Field(default=None, primary_key=True)\n    name: str = Field(min_length=1, max_length=100)\n    start_date: date = Field(nullable=False)\n    time_steps: int | None = Field(default=8760, nullable=True)\n    interval: float = Field(default=1)\n    project_id: int = Field(foreign_key=\"projects.id\")\n    user_id: int = Field(foreign_key=\"users.id\")\n    energysystem_model: EnEnergysystem = Field(sa_column=Column(JSONB), default={})\n</code></pre>"},{"location":"backend/api/models/scenario/#app.scenario.model.EnScenarioUpdate","title":"<code>EnScenarioUpdate</code>","text":"<p>               Bases: <code>EnScenario</code></p> <p>Represents an updated energy scenario with validated parameters.</p> <p>This class extends the functionality of the <code>EnScenario</code> class to allow for scenario updates with specific attributes constrained by validation requirements. It is primarily used for defining and updating the parameters of an energy simulation scenario, ensuring proper formats and validations such as field lengths and data type constraints.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str | None</code> <p>Optional name of the scenario, which must be a string with a minimum length of 1 character and a maximum length of 100 characters.</p> <code>interval</code> <code>float | None</code> <p>Optional interval defining the time step size, where the value is a float.</p> <code>start_date</code> <code>date | None</code> <p>Optional start date for the scenario, represented as a date object.</p> <code>time_steps</code> <code>int | None</code> <p>Optional total number of time steps in the simulation.</p> <code>energysystem_model</code> <code>EnEnergysystem | None</code> <p>Optional reference to an energy system model associated with the scenario.</p> <code>project_id</code> <code>None</code> <p>Reserved attribute for the project ID, currently none.</p> <code>user_id</code> <code>None</code> <p>Reserved attribute for the user ID, currently none.</p> Source code in <code>backend/app/scenario/model.py</code> <pre><code>class EnScenarioUpdate(EnScenario):\n    \"\"\"\n    Represents an updated energy scenario with validated parameters.\n\n    This class extends the functionality of the `EnScenario` class to allow for\n    scenario updates with specific attributes constrained by validation requirements.\n    It is primarily used for defining and updating the parameters of an energy simulation\n    scenario, ensuring proper formats and validations such as field lengths and data type\n    constraints.\n\n    :ivar name: Optional name of the scenario, which must be a string with a\n        minimum length of 1 character and a maximum length of 100 characters.\n    :type name: str | None\n    :ivar interval: Optional interval defining the time step size, where the value\n        is a float.\n    :type interval: float | None\n    :ivar start_date: Optional start date for the scenario, represented as a date object.\n    :type start_date: date | None\n    :ivar time_steps: Optional total number of time steps in the simulation.\n    :type time_steps: int | None\n    :ivar energysystem_model: Optional reference to an energy system model\n        associated with the scenario.\n    :type energysystem_model: EnEnergysystem | None\n    :ivar project_id: Reserved attribute for the project ID, currently none.\n    :type project_id: None\n    :ivar user_id: Reserved attribute for the user ID, currently none.\n    :type user_id: None\n    \"\"\"\n    name: str | None = Field(default=None, min_length=1, max_length=100, nullable=True)\n    interval: float | None = Field(default=1, nullable=True)\n    start_date: date | None = Field(default=None, nullable=True)\n    time_steps: int | None = Field(default=None, nullable=True)\n    energysystem_model: EnEnergysystem | None = Field(default=None, nullable=True)\n    project_id: None = None\n    user_id: None = None\n</code></pre>"},{"location":"backend/api/models/simulation/","title":"simulation","text":""},{"location":"backend/api/models/simulation/#app.simulation.model.EnSimulation","title":"<code>EnSimulation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the simulation entity in the application.</p> <p>The <code>EnSimulation</code> class models a simulation instance with its various properties, including token, status, start and end dates, and association to a specific scenario. It provides a structured representation of simulation for storing and retrieving purposes.</p> <p>Attributes:</p> Name Type Description <code>sim_token</code> <code>str</code> <p>Unique token identifying the simulation.</p> <code>status</code> <code>str</code> <p>Current status of the simulation, e.g., started, completed.</p> <code>start_date</code> <code>datetime</code> <p>Date and time when the simulation was started.</p> <code>end_date</code> <code>datetime | None</code> <p>Date and time when the simulation was ended (optional).</p> <code>scenario_id</code> <code>int</code> <p>Identifier of the related scenario in the database.</p> Source code in <code>backend/app/simulation/model.py</code> <pre><code>class EnSimulation(BaseModel):\n    \"\"\"\n    Represents the simulation entity in the application.\n\n    The `EnSimulation` class models a simulation instance with its various\n    properties, including token, status, start and end dates, and\n    association to a specific scenario. It provides a structured\n    representation of simulation for storing and retrieving purposes.\n\n    :ivar sim_token: Unique token identifying the simulation.\n    :type sim_token: str\n    :ivar status: Current status of the simulation, e.g., started, completed.\n    :type status: str\n    :ivar start_date: Date and time when the simulation was started.\n    :type start_date: datetime\n    :ivar end_date: Date and time when the simulation was ended (optional).\n    :type end_date: datetime | None\n    :ivar scenario_id: Identifier of the related scenario in the database.\n    :type scenario_id: int\n    \"\"\"\n    sim_token: str = Field(nullable=False)\n    status: str = Field(default=Status.STARTED.value, nullable=False)\n    start_date: datetime = Field(nullable=False)\n    end_date: datetime | None = Field(default=None, nullable=True)\n    scenario_id: int = Field(default=None, nullable=False, foreign_key=\"scenarios.id\")\n</code></pre>"},{"location":"backend/api/models/simulation/#app.simulation.model.EnSimulationDB","title":"<code>EnSimulationDB</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Representation of a simulation entry in the database.</p> <p>This class defines the data structure and table mapping for simulation entries in the database. It includes fields for basic simulation attributes such as its unique identifier, status, dates, and related scenario. This model is used to manage and interact with the simulation data persisted in the database.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Unique identifier for the simulation.</p> <code>sim_token</code> <code>str</code> <p>Token associated with the simulation, used for identification or access.</p> <code>status</code> <code>str</code> <p>Current status of the simulation. Default is <code>Status.STARTED.value</code>.</p> <code>start_date</code> <code>datetime</code> <p>Date and time when the simulation started.</p> <code>end_date</code> <code>datetime | None</code> <p>Date and time when the simulation ended, if available.</p> <code>scenario_id</code> <code>int</code> <p>Identifier of the related scenario. Links the simulation record to a scenario in the database.</p> Source code in <code>backend/app/simulation/model.py</code> <pre><code>class EnSimulationDB(SQLModel, table=True):\n    \"\"\"\n    Representation of a simulation entry in the database.\n\n    This class defines the data structure and table mapping for\n    simulation entries in the database. It includes fields\n    for basic simulation attributes such as its unique identifier,\n    status, dates, and related scenario. This model is used to\n    manage and interact with the simulation data persisted in the\n    database.\n\n    :ivar id: Unique identifier for the simulation.\n    :type id: int\n    :ivar sim_token: Token associated with the simulation, used for\n        identification or access.\n    :type sim_token: str\n    :ivar status: Current status of the simulation. Default is\n        `Status.STARTED.value`.\n    :type status: str\n    :ivar start_date: Date and time when the simulation started.\n    :type start_date: datetime\n    :ivar end_date: Date and time when the simulation ended, if available.\n    :type end_date: datetime | None\n    :ivar scenario_id: Identifier of the related scenario. Links the\n        simulation record to a scenario in the database.\n    :type scenario_id: int\n    \"\"\"\n    __tablename__ = \"simulations\"\n\n    id: int = Field(default=None, primary_key=True)\n    sim_token: str = Field(nullable=False)\n    status: str = Field(default=Status.STARTED.value, nullable=False)\n    start_date: datetime = Field(nullable=False)\n    end_date: datetime | None = Field(default=None, nullable=True)\n    scenario_id: int = Field(default=None, nullable=False, foreign_key=\"scenarios.id\")\n</code></pre>"},{"location":"backend/api/models/simulation/#app.simulation.model.EnSimulationUpdate","title":"<code>EnSimulationUpdate</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Represents an energy simulation update model used to track the status and completion date of a simulation.</p> <p>This class models the data structure for storing information about an energy simulation's current status and its potential end date. It inherits from SQLModel to enable database interactions and data serialization.</p> <p>Attributes:</p> Name Type Description <code>status</code> <code>str</code> <p>Indicates the current status of the energy simulation.</p> <code>end_date</code> <code>datetime | None</code> <p>Represents the simulation's end date if available.</p> Source code in <code>backend/app/simulation/model.py</code> <pre><code>class EnSimulationUpdate(SQLModel):\n    \"\"\"\n    Represents an energy simulation update model used to track the status\n    and completion date of a simulation.\n\n    This class models the data structure for storing information about an\n    energy simulation's current status and its potential end date. It\n    inherits from SQLModel to enable database interactions and data\n    serialization.\n\n    :ivar status: Indicates the current status of the energy simulation.\n    :type status: str\n    :ivar end_date: Represents the simulation's end date if available.\n    :type end_date: datetime | None\n    \"\"\"\n    status: str = Field(nullable=False)\n    end_date: datetime | None = Field(default=None, nullable=True)\n</code></pre>"},{"location":"backend/api/models/user/","title":"user","text":""},{"location":"backend/api/models/user/#app.user.model.EnUser","title":"<code>EnUser</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Represents a user entity with various attributes and validation mechanisms for the user-related data fields.</p> <p>This class is primarily used to model user information and enforce constraints on attributes such as username, password, email, and names. It includes mechanisms to handle secure storage and validation of sensitive data like passwords and email addresses. Additionally, methods are provided for verifying passwords and extracting specific token-relevant user data.</p> <p>Attributes:</p> Name Type Description <code>username</code> <code>str</code> <p>The unique username for the user.</p> <code>firstname</code> <code>str | None</code> <p>The optional first name of the user.</p> <code>lastname</code> <code>str | None</code> <p>The optional last name of the user.</p> <code>password</code> <code>str</code> <p>The hashed password for the user.</p> <code>mail</code> <code>str</code> <p>The valid email address associated with the user.</p> Source code in <code>backend/app/user/model.py</code> <pre><code>class EnUser(SQLModel):\n    \"\"\"\n    Represents a user entity with various attributes and validation mechanisms for\n    the user-related data fields.\n\n    This class is primarily used to model user information and enforce constraints\n    on attributes such as username, password, email, and names. It includes mechanisms\n    to handle secure storage and validation of sensitive data like passwords and email\n    addresses. Additionally, methods are provided for verifying passwords and extracting\n    specific token-relevant user data.\n\n    :ivar username: The unique username for the user.\n    :type username: str\n    :ivar firstname: The optional first name of the user.\n    :type firstname: str, optional\n    :ivar lastname: The optional last name of the user.\n    :type lastname: str, optional\n    :ivar password: The hashed password for the user.\n    :type password: str\n    :ivar mail: The valid email address associated with the user.\n    :type mail: str\n    \"\"\"\n    username: str = Field(min_length=3, max_length=128)\n    firstname: str | None = Field(default=None, min_length=0, max_length=64)\n    lastname: str | None = Field(default=None, min_length=0, max_length=64)\n    password: str = Field(min_length=8, max_length=PASSWORD_MAX_LENGTH)\n    mail: str = Field(min_length=8, max_length=128)\n\n    def verify_password(self, plain_password: str) -&gt; bool:\n        return pbkdf2_sha256.verify(plain_password, self.password)\n\n    def get_token_information(self) -&gt; dict:\n        return self.model_dump(include={\"username\"})\n\n    @field_validator('mail', mode='after')\n    @classmethod\n    def is_mail_address(cls, value: str) -&gt; str:\n        \"\"\"\n        Validates and ensures the provided email address is in a valid format.\n        This function checks whether the given string contains the '@' symbol,\n        indicating it is properly structured as an email address. If the validation\n        fails, an HTTPException is raised with an appropriate status code and\n        detail message.\n\n        :param value: The email address to be validated.\n        :type value: str\n        :return: The validated email address if it is valid.\n        :rtype: str\n        :raises HTTPException: If the email address does not contain the '@' symbol.\n        \"\"\"\n        if value.find(\"@\") == -1:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Invalid mail address.\"\n            )\n        return value\n\n    @field_validator('password', mode='after')\n    @classmethod\n    def is_good_password(cls, value: str) -&gt; str:\n        \"\"\"\n        Validates the strength of a password after it has been assigned or modified. The\n        method ensures that the password meets specific security requirements, such as\n        minimum and maximum length, uppercase and lowercase characters, numeric\n        characters, and the inclusion of special symbols.\n\n        :param value: The password string to be validated.\n        :type value: str\n        :return: The original password string if it meets all validation criteria.\n        :rtype: str\n        :raises HTTPException: If the password fails any validation check, such as length,\n            lack of uppercase letters, lowercase letters, digits, or special characters.\n        \"\"\"\n        punctionation = [\"/\", \"$\", \"\u00a7\", \"'\", \",\", \".\", \"@\", \"(\", \")\", \"!\", \"#\", \"*\", \"?\", \"=\", \"&amp;\", \"%\", \"'\", \":\", \";\", \"&lt;\", \"&gt;\", \"+\", \"-\", \"_\"]\n\n        if len(value) &lt; 3:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Password must be at least 3 characters long.\"\n            )\n\n        if len(value) &gt; PASSWORD_MAX_LENGTH:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Password should not exceed 128 characters.\"\n            )\n\n        if not any(c.isupper() for c in value):\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"There should be at least one uppercase character in password.\"\n            )\n\n        if not any(c.islower() for c in value):\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"There should be at least one lowercase character in password.\"\n            )\n\n        if not any(c.isdigit() for c in value):\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"There should be at least one digit in password.\"\n            )\n\n        if not any(c in punctionation for c in value):\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"There should be at least one special character in password.\"\n            )\n\n        return value\n</code></pre>"},{"location":"backend/api/models/user/#app.user.model.EnUser.is_good_password","title":"<code>is_good_password(value)</code>  <code>classmethod</code>","text":"<p>Validates the strength of a password after it has been assigned or modified. The method ensures that the password meets specific security requirements, such as minimum and maximum length, uppercase and lowercase characters, numeric characters, and the inclusion of special symbols.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The password string to be validated.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The original password string if it meets all validation criteria.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the password fails any validation check, such as length, lack of uppercase letters, lowercase letters, digits, or special characters.</p> Source code in <code>backend/app/user/model.py</code> <pre><code>@field_validator('password', mode='after')\n@classmethod\ndef is_good_password(cls, value: str) -&gt; str:\n    \"\"\"\n    Validates the strength of a password after it has been assigned or modified. The\n    method ensures that the password meets specific security requirements, such as\n    minimum and maximum length, uppercase and lowercase characters, numeric\n    characters, and the inclusion of special symbols.\n\n    :param value: The password string to be validated.\n    :type value: str\n    :return: The original password string if it meets all validation criteria.\n    :rtype: str\n    :raises HTTPException: If the password fails any validation check, such as length,\n        lack of uppercase letters, lowercase letters, digits, or special characters.\n    \"\"\"\n    punctionation = [\"/\", \"$\", \"\u00a7\", \"'\", \",\", \".\", \"@\", \"(\", \")\", \"!\", \"#\", \"*\", \"?\", \"=\", \"&amp;\", \"%\", \"'\", \":\", \";\", \"&lt;\", \"&gt;\", \"+\", \"-\", \"_\"]\n\n    if len(value) &lt; 3:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Password must be at least 3 characters long.\"\n        )\n\n    if len(value) &gt; PASSWORD_MAX_LENGTH:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Password should not exceed 128 characters.\"\n        )\n\n    if not any(c.isupper() for c in value):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"There should be at least one uppercase character in password.\"\n        )\n\n    if not any(c.islower() for c in value):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"There should be at least one lowercase character in password.\"\n        )\n\n    if not any(c.isdigit() for c in value):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"There should be at least one digit in password.\"\n        )\n\n    if not any(c in punctionation for c in value):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"There should be at least one special character in password.\"\n        )\n\n    return value\n</code></pre>"},{"location":"backend/api/models/user/#app.user.model.EnUser.is_mail_address","title":"<code>is_mail_address(value)</code>  <code>classmethod</code>","text":"<p>Validates and ensures the provided email address is in a valid format. This function checks whether the given string contains the '@' symbol, indicating it is properly structured as an email address. If the validation fails, an HTTPException is raised with an appropriate status code and detail message.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The email address to be validated.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The validated email address if it is valid.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the email address does not contain the '@' symbol.</p> Source code in <code>backend/app/user/model.py</code> <pre><code>@field_validator('mail', mode='after')\n@classmethod\ndef is_mail_address(cls, value: str) -&gt; str:\n    \"\"\"\n    Validates and ensures the provided email address is in a valid format.\n    This function checks whether the given string contains the '@' symbol,\n    indicating it is properly structured as an email address. If the validation\n    fails, an HTTPException is raised with an appropriate status code and\n    detail message.\n\n    :param value: The email address to be validated.\n    :type value: str\n    :return: The validated email address if it is valid.\n    :rtype: str\n    :raises HTTPException: If the email address does not contain the '@' symbol.\n    \"\"\"\n    if value.find(\"@\") == -1:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Invalid mail address.\"\n        )\n    return value\n</code></pre>"},{"location":"backend/api/models/user/#app.user.model.EnUserDB","title":"<code>EnUserDB</code>","text":"<p>               Bases: <code>EnUser</code></p> <p>Represents a database model for storing user information.</p> <p>This class inherits from <code>EnUser</code> and serves as a database table for user-related data. It defines the structure of the <code>users</code> table, including various user attributes like ID, date of joining, last login, and flags for active status, superuser, and staff roles.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The unique identifier for each user.</p> <code>date_joined</code> <code>datetime | None</code> <p>The datetime when the user registered. Defaults to None.</p> <code>last_login</code> <code>datetime | None</code> <p>The last login datetime for the user. Defaults to None.</p> <code>is_active</code> <code>bool</code> <p>Whether the user account is active. Defaults to False.</p> <code>is_superuser</code> <code>bool</code> <p>Whether the user has superuser privileges. Defaults to False.</p> <code>is_staff</code> <code>bool</code> <p>Whether the user is part of the staff. Defaults to False.</p> Source code in <code>backend/app/user/model.py</code> <pre><code>class EnUserDB(EnUser, table=True):\n    \"\"\"\n    Represents a database model for storing user information.\n\n    This class inherits from `EnUser` and serves as a database table\n    for user-related data. It defines the structure of the `users`\n    table, including various user attributes like ID, date of joining,\n    last login, and flags for active status, superuser, and staff roles.\n\n    :ivar id: The unique identifier for each user.\n    :type id: int\n    :ivar date_joined: The datetime when the user registered. Defaults to None.\n    :type date_joined: datetime | None\n    :ivar last_login: The last login datetime for the user. Defaults to None.\n    :type last_login: datetime | None\n    :ivar is_active: Whether the user account is active. Defaults to False.\n    :type is_active: bool\n    :ivar is_superuser: Whether the user has superuser privileges. Defaults to False.\n    :type is_superuser: bool\n    :ivar is_staff: Whether the user is part of the staff. Defaults to False.\n    :type is_staff: bool\n    \"\"\"\n    __tablename__ = \"users\"\n\n    id: int = Field(default=None, primary_key=True, index=True)\n    date_joined: datetime | None = Field(default=None)\n    last_login: datetime | None = Field(default=None)\n    is_active: bool = Field(default=False)\n    is_superuser: bool = Field(default=False)\n    is_staff: bool = Field(default=False)\n</code></pre>"},{"location":"backend/api/models/user/#app.user.model.EnUserUpdate","title":"<code>EnUserUpdate</code>","text":"<p>               Bases: <code>EnUser</code></p> <p>Represents an update to an EnUser.</p> <p>This class serves as a model for updating an existing user's details in the system. It extends the <code>EnUser</code> class, inheriting its attributes and adding optional fields specific to updating a user's information. Each attribute can be set to None if the corresponding field is not being updated.</p> <p>Attributes:</p> Name Type Description <code>username</code> <code>str | None</code> <p>Optional updated username for the user.</p> <code>firstname</code> <code>str | None</code> <p>Optional updated first name for the user.</p> <code>lastname</code> <code>str | None</code> <p>Optional updated last name for the user.</p> <code>password</code> <code>str | None</code> <p>Optional updated password for the user.</p> <code>mail</code> <code>str | None</code> <p>Optional updated email address for the user.</p> Source code in <code>backend/app/user/model.py</code> <pre><code>class EnUserUpdate(EnUser):\n    \"\"\"\n    Represents an update to an EnUser.\n\n    This class serves as a model for updating an existing user's details in the\n    system. It extends the `EnUser` class, inheriting its attributes and adding\n    optional fields specific to updating a user's information. Each attribute can\n    be set to None if the corresponding field is not being updated.\n\n    :ivar username: Optional updated username for the user.\n    :type username: str | None\n    :ivar firstname: Optional updated first name for the user.\n    :type firstname: str | None\n    :ivar lastname: Optional updated last name for the user.\n    :type lastname: str | None\n    :ivar password: Optional updated password for the user.\n    :type password: str | None\n    :ivar mail: Optional updated email address for the user.\n    :type mail: str | None\n    \"\"\"\n    username: str | None = None\n    firstname: str | None = None\n    lastname: str | None = None\n    password: str | None = None\n    mail: str | None = None\n</code></pre>"},{"location":"backend/api/router/admin/","title":"admin","text":""},{"location":"backend/api/router/admin/#app.admin.router.root","title":"<code>root()</code>  <code>async</code>","text":"<p>Handles the root route of the admin router.</p> <p>This endpoint raises an HTTPException with a 418 status code and a detail message indicating \"I'm a teapot.\" This method does not return any content as it is designed to only trigger the exception. The implementation is aligned with the HTTP 418 status code, which is used as an Easter egg for humorous purposes.</p> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Always raised with status code 418 and detail \"I'm a teapot\".</p> Source code in <code>backend/app/admin/router.py</code> <pre><code>@admin_router.get(\"/\")\nasync def root():\n    \"\"\"\n    Handles the root route of the admin router.\n\n    This endpoint raises an HTTPException with a 418 status code and a detail message\n    indicating \"I'm a teapot.\" This method does not return any content as it is designed\n    to only trigger the exception. The implementation is aligned with the HTTP 418 status\n    code, which is used as an Easter egg for humorous purposes.\n\n    :return: None\n    :raises HTTPException: Always raised with status code 418 and detail \"I'm a teapot\".\n    \"\"\"\n    raise HTTPException(status_code=418, detail=\"I'm a teapot.\")\n</code></pre>"},{"location":"backend/api/router/oep/","title":"oep","text":""},{"location":"backend/api/router/oep/#app.oep.router.get_oep_client","title":"<code>get_oep_client()</code>","text":"<p>Provides a generator function to yield an instance of the OepClient class.</p> <p>This function accesses environment variables to retrieve the necessary credentials and configurations required for creating an OepClient instance. It utilizes <code>os.getenv</code> to obtain the <code>OEP_TOKEN</code> and <code>OEP_TOPIC</code> values for authentication and topic management, respectively. The OepClient instance is yielded, allowing the caller to manage resources appropriately.</p> <p>:yield:     OepClient: A generator that yields an instance of the OepClient class     configured with a token and a default schema retrieved from the     environment variables.</p> Source code in <code>backend/app/oep/router.py</code> <pre><code>def get_oep_client():\n    \"\"\"\n    Provides a generator function to yield an instance of the OepClient class.\n\n    This function accesses environment variables to retrieve the necessary\n    credentials and configurations required for creating an OepClient instance.\n    It utilizes `os.getenv` to obtain the `OEP_TOKEN` and `OEP_TOPIC` values for\n    authentication and topic management, respectively. The OepClient instance is\n    yielded, allowing the caller to manage resources appropriately.\n\n    :yield:\n        OepClient: A generator that yields an instance of the OepClient class\n        configured with a token and a default schema retrieved from the\n        environment variables.\n    \"\"\"\n    yield OepClient(\n        token=os.getenv(\"OEP_TOKEN\"),\n        default_schema=os.getenv(\"OEP_TOPIC\")\n    )\n</code></pre>"},{"location":"backend/api/router/oep/#app.oep.router.get_oep_data","title":"<code>get_oep_data(token, table_name, oep_cli=Depends(get_oep_client))</code>  <code>async</code>","text":"<p>Get OEP Data from a specified table.</p> <p>This endpoint retrieves data from a specified table using the provided <code>table_name</code>. The OEP client instance is used to interact with the database, and token-based authentication is required for accessing the endpoint. The data response includes the retrieved items, their total count, and a success status indicator.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>A bearer token for authentication.</p> required <code>table_name</code> <code>str</code> <p>The name of the table to retrieve data from.</p> required <code>oep_cli</code> <code>OepClient</code> <p>An instance of the OEP client to interact with the backend database.</p> <code>Depends(get_oep_client)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>A <code>DataResponse</code> object containing the data, total count, and success status.</p> Source code in <code>backend/app/oep/router.py</code> <pre><code>@oep_router.get(\"/{table_name}\")\nasync def get_oep_data(token: Annotated[str, Depends(oauth2_scheme)], table_name: str,\n                       oep_cli: OepClient = Depends(get_oep_client)) -&gt; DataResponse:\n    \"\"\"\n    Get OEP Data from a specified table.\n\n    This endpoint retrieves data from a specified table using the provided `table_name`.\n    The OEP client instance is used to interact with the database, and token-based\n    authentication is required for accessing the endpoint. The data response includes\n    the retrieved items, their total count, and a success status indicator.\n\n    :param token: A bearer token for authentication.\n    :param table_name: The name of the table to retrieve data from.\n    :param oep_cli: An instance of the OEP client to interact with the backend database.\n    :return: A `DataResponse` object containing the data, total count, and success status.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    data = oep_cli.select_from_table(table=table_name)\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=data,\n            totalCount=len(data)\n        ),\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/oep/#app.oep.router.get_oep_metadata","title":"<code>get_oep_metadata(token, table_name, oep_cli=Depends(get_oep_client))</code>  <code>async</code>","text":"<p>Retrieve metadata for a specific table.</p> <p>This endpoint fetches metadata for the provided table name using the OEP client. It requires authentication via the provided token. If the token is invalid or not provided, an authentication error will be raised.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The authentication token obtained via the OAuth2 scheme.</p> required <code>table_name</code> <code>str</code> <p>The name of the table for which metadata is to be retrieved.</p> required <code>oep_cli</code> <code>OepClient</code> <p>Instance of the OepClient dependency for interacting with the OEP API.</p> <code>Depends(get_oep_client)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>A DataResponse containing the retrieved metadata and its total count.</p> Source code in <code>backend/app/oep/router.py</code> <pre><code>@oep_router.get(\"/meta/{table_name}\")\nasync def get_oep_metadata(token: Annotated[str, Depends(oauth2_scheme)], table_name: str,\n                           oep_cli: OepClient = Depends(get_oep_client)) -&gt; DataResponse:\n    \"\"\"\n    Retrieve metadata for a specific table.\n\n    This endpoint fetches metadata for the provided table name using the OEP client.\n    It requires authentication via the provided token. If the token is invalid or\n    not provided, an authentication error will be raised.\n\n    :param token: The authentication token obtained via the OAuth2 scheme.\n    :param table_name: The name of the table for which metadata is to be retrieved.\n    :param oep_cli: Instance of the OepClient dependency for interacting with the OEP API.\n    :return: A DataResponse containing the retrieved metadata and its total count.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    data = oep_cli.get_metadata(table=table_name)\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=data,\n            totalCount=len(data)\n        ),\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/project/","title":"project","text":""},{"location":"backend/api/router/project/#app.project.router.create_project","title":"<code>create_project(token, project_data, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Creates a new project and stores it in the database. The function checks the authentication token, decodes it, retrieves the authenticated user's details, and associates the project data with the user. The new project is saved to the database, and a success response is returned.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>Authentication token obtained from the user. Used to validate user identity and permission.</p> required <code>project_data</code> <code>EnProject</code> <p>Project data containing information required to create a new project in the database.</p> required <code>db</code> <code>Session</code> <p>Database session dependency. Used for interacting with the database.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>An object containing a success message indicating the project has been created.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Raised with a 401 status code if the user is not authenticated due to missing or invalid token.</p> Source code in <code>backend/app/project/router.py</code> <pre><code>@projects_router.post(\"/\", response_model=MessageResponse)\nasync def create_project(token: Annotated[str, Depends(oauth2_scheme)], project_data: EnProject,\n                         db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Creates a new project and stores it in the database. The function checks\n    the authentication token, decodes it, retrieves the authenticated user's\n    details, and associates the project data with the user. The new project is\n    saved to the database, and a success response is returned.\n\n    :param token: Authentication token obtained from the user. Used to validate\n                  user identity and permission.\n    :type token: str\n    :param project_data: Project data containing information required to create a\n                         new project in the database.\n    :type project_data: EnProject\n    :param db: Database session dependency. Used for interacting with the database.\n    :type db: Session\n    :raises HTTPException: Raised with a 401 status code if the user is not\n                           authenticated due to missing or invalid token.\n    :return: An object containing a success message indicating the project has\n             been created.\n    :rtype: MessageResponse\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    token_data = decode_token(token)\n    statement = select(EnUserDB).where(EnUserDB.username == token_data[\"username\"])\n    token_user = db.exec(statement).first()\n    project = EnProjectDB(**project_data.model_dump())\n\n    # set auxiliary data\n    project.user_id = token_user.id\n    project.date_created = datetime.now()\n\n    db.add(project)\n    db.commit()\n\n    return MessageResponse(\n        data=\"Project created.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/project/#app.project.router.delete_project","title":"<code>delete_project(token, project_id, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Deletes a project and all associated scenarios from the database. It requires the authenticated user to be the owner of the project to execute this operation.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>A string representing the authentication token of the requesting user.</p> required <code>project_id</code> <code>int</code> <p>An integer representing the ID of the project to be deleted.</p> required <code>db</code> <code>Session</code> <p>A SQLAlchemy session object for database operations.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A <code>MessageResponse</code> object confirming successful deletion of the project and all its related scenarios.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <ul> <li>If authentication token is missing (<code>401 Unauthorized</code>). - If the authenticated user is not authorized to delete the specified project (<code>401 Unauthorized</code>).</li> </ul> Source code in <code>backend/app/project/router.py</code> <pre><code>@projects_router.delete(\"/{project_id}\", response_model=MessageResponse)\nasync def delete_project(token: Annotated[str, Depends(oauth2_scheme)], project_id: int,\n                         db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Deletes a project and all associated scenarios from the database. It requires the\n    authenticated user to be the owner of the project to execute this operation.\n\n    :param token: A string representing the authentication token of the requesting user.\n    :param project_id: An integer representing the ID of the project to be deleted.\n    :param db: A SQLAlchemy session object for database operations.\n    :return: A `MessageResponse` object confirming successful deletion of the project\n             and all its related scenarios.\n\n    :raises HTTPException:\n        - If authentication token is missing (`401 Unauthorized`).\n        - If the authenticated user is not authorized to delete the specified project (`401 Unauthorized`).\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    if not validate_project_owner(project_id, token, db):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    project = db.get(EnProjectDB, project_id)\n\n    scenarios = db.exec(select(EnScenarioDB).where(EnScenarioDB.project_id == project.id))\n    for scenario in scenarios:\n        db.delete(scenario)\n\n    db.delete(project)\n    db.commit()\n\n    return MessageResponse(\n        data=\"Project deleted and all scenarios deleted.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/project/#app.project.router.read_project","title":"<code>read_project(project_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Retrieves project details by the given project ID. This endpoint fetches details about a project from the database after validating the provided authentication token and confirming ownership of the project by the authenticated user.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The unique identifier of the project to retrieve.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>Authentication token provided by the user for accessing the endpoint.</p> required <code>db</code> <code>Session</code> <p>Database session used for accessing stored data.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>The response containing project data wrapped in a structured response model.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If authentication fails or if the user is not authorized to access the specified project.</p> Source code in <code>backend/app/project/router.py</code> <pre><code>@projects_router.get(\"/{project_id}\", response_model=DataResponse)\nasync def read_project(project_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                       db: Session = Depends(get_db_session)) -&gt; DataResponse:\n    \"\"\"\n    Retrieves project details by the given project ID. This endpoint fetches details about a\n    project from the database after validating the provided authentication token and confirming\n    ownership of the project by the authenticated user.\n\n    :param project_id: The unique identifier of the project to retrieve.\n    :type project_id: int\n    :param token: Authentication token provided by the user for accessing the endpoint.\n    :type token: str\n    :param db: Database session used for accessing stored data.\n    :type db: Session\n    :return: The response containing project data wrapped in a structured response model.\n    :rtype: DataResponse\n    :raises HTTPException: If authentication fails or if the user is not authorized to access\n        the specified project.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    if not validate_project_owner(project_id, token, db):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=[db.get(EnProjectDB, project_id).get_return_data()],\n            totalCount=1,\n        ),\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/project/#app.project.router.read_projects","title":"<code>read_projects(token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Fetches and returns a list of projects associated with the authenticated user. The function validates the provided token, retrieves the associated user details, and fetches all projects corresponding to the user. The result includes details of all retrieved projects wrapped in a standardized response.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The authentication token extracted from the request.</p> required <code>db</code> <code>Session</code> <p>The database session dependency used to execute queries.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>A standardized response containing a list of projects for the authenticated user, along with the total count of projects.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the provided token is missing or invalid.</p> Source code in <code>backend/app/project/router.py</code> <pre><code>@projects_router.get(\"s/\", response_model=DataResponse)\nasync def read_projects(token: Annotated[str, Depends(oauth2_scheme)],\n                        db: Session = Depends(get_db_session)) -&gt; DataResponse:\n    \"\"\"\n    Fetches and returns a list of projects associated with the authenticated user.\n    The function validates the provided token, retrieves the associated user\n    details, and fetches all projects corresponding to the user. The result\n    includes details of all retrieved projects wrapped in a standardized response.\n\n    :param token: The authentication token extracted from the request.\n    :type token: str\n    :param db: The database session dependency used to execute queries.\n    :type db: Session\n    :return: A standardized response containing a list of projects for\n        the authenticated user, along with the total count of projects.\n    :rtype: DataResponse\n    :raises HTTPException: If the provided token is missing or invalid.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    token_data = decode_token(token)\n    statement = select(EnUserDB).where(EnUserDB.username == token_data[\"username\"])\n    token_user = db.exec(statement).first()\n\n    statement = select(EnProjectDB).where(EnProjectDB.user_id == token_user.id)\n    projects = db.exec(statement)\n\n    response_data = []\n    for project in projects:\n        response_data.append(project.get_return_data())\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=response_data,\n            totalCount=len(response_data)\n        ),\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/project/#app.project.router.update_project","title":"<code>update_project(token, project_id, project_data, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Updates the details of an existing project. This endpoint allows authenticated and authorized users to modify the properties of a given project. The function fetches the project by its ID, validates the user's ownership of the project, and updates the provided information in the database.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The authentication token of the user making the request.</p> required <code>project_id</code> <code>int</code> <p>The unique identifier of the project to be updated.</p> required <code>project_data</code> <code>EnProjectUpdate</code> <p>The new data to update the project with.</p> required <code>db</code> <code>Session</code> <p>The database session used for querying and updating project details.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A <code>MessageResponse</code> object indicating the success of the operation.</p> Source code in <code>backend/app/project/router.py</code> <pre><code>@projects_router.patch(\"/{project_id}\", response_model=MessageResponse)\nasync def update_project(token: Annotated[str, Depends(oauth2_scheme)], project_id: int, project_data: EnProjectUpdate,\n                         db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Updates the details of an existing project. This endpoint allows authenticated\n    and authorized users to modify the properties of a given project. The function\n    fetches the project by its ID, validates the user's ownership of the project,\n    and updates the provided information in the database.\n\n    :param token: The authentication token of the user making the request.\n    :param project_id: The unique identifier of the project to be updated.\n    :param project_data: The new data to update the project with.\n    :param db: The database session used for querying and updating project details.\n    :return: A `MessageResponse` object indicating the success of the operation.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    if not validate_project_owner(project_id, token, db):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    db_project = db.get(EnProjectDB, project_id)\n    if not db_project:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Project not found.\")\n\n    new_project_data = project_data.model_dump(exclude_none=True)\n\n    db_project.sqlmodel_update(new_project_data)\n    db_project.date_updated = datetime.now()\n\n    db.add(db_project)\n    db.commit()\n    db.refresh(db_project)\n\n    return MessageResponse(\n        data=\"Project Updated.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/project/#app.project.router.validate_project_owner","title":"<code>validate_project_owner(project_id, token, db)</code>","text":"<p>Validates whether the user associated with a given token is the owner of a project identified by the provided project_id. Verifies the token's authenticity, fetches the project from the database, and compares its ownership details to ensure the user has the necessary permissions to access or modify the project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>ID of the project whose ownership is being validated</p> required <code>token</code> <code>str</code> <p>JWT token provided for authentication and identifying the user</p> required <code>db</code> <code>Session</code> <p>Database session object used to query project and user information</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Returns True if the token user is the owner of the project, otherwise raises an exception</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the project is not found in the database (404)</p> <code>HTTPException</code> <p>If the user associated with the token does not own the project (403)</p> Source code in <code>backend/app/project/router.py</code> <pre><code>def validate_project_owner(project_id: int, token: str, db):\n    \"\"\"\n    Validates whether the user associated with a given token is the owner of a project\n    identified by the provided project_id. Verifies the token's authenticity, fetches\n    the project from the database, and compares its ownership details to ensure the user\n    has the necessary permissions to access or modify the project.\n\n    :param project_id: ID of the project whose ownership is being validated\n    :type project_id: int\n    :param token: JWT token provided for authentication and identifying the user\n    :type token: str\n    :param db: Database session object used to query project and user information\n    :type db: Session\n    :return: Returns True if the token user is the owner of the project, otherwise raises an exception\n    :rtype: bool\n\n    :raises HTTPException: If the project is not found in the database (404)\n    :raises HTTPException: If the user associated with the token does not own the project (403)\n    \"\"\"\n    # Get Database-Session and token-data\n    token_data = decode_token(token)\n\n    # Get User-data from the Database\n    statement = select(EnUserDB).where(EnUserDB.username == token_data[\"username\"])\n    token_user = db.exec(statement).first()\n\n    # get the mentioned project-data\n    project = db.get(EnProjectDB, project_id)\n    if not project:\n        raise HTTPException(status_code=404, detail=\"Project not found\")\n\n    # check if the project_id and the token_id are the same and return the value\n    if project.user_id == token_user.id:\n        return True\n    else:\n        raise HTTPException(status_code=403, detail=\"Permission denied\")\n</code></pre>"},{"location":"backend/api/router/results/","title":"results","text":""},{"location":"backend/api/router/results/#app.results.router.get_results","title":"<code>get_results(simulation_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Retrieve the results of a simulation based on the given simulation id. This endpoint checks the current status of the simulation and provides appropriate responses based on that status. If the simulation is finished, the results are returned. If the status indicates in-progress, failed, or canceled, it responds with corresponding error messages. Errors are also returned if the simulation does not exist or if the request is unauthenticated.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_id</code> <code>int</code> <p>The unique identifier of the simulation.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The OAuth2 token for authentication.</p> required <code>db</code> <code>Session</code> <p>Database session dependency, used to query the database.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>ResultResponse | ErrorResponse</code> <p>A ResultResponse object containing simulation results if successful, or an ErrorResponse object containing error details if an error occurs.</p> Source code in <code>backend/app/results/router.py</code> <pre><code>@results_router.get(\"/{simulation_id}\", response_model=ResultResponse | ErrorResponse)\nasync def get_results(simulation_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                      db: Session = Depends(get_db_session)) -&gt; ResultResponse | ErrorResponse:\n    \"\"\"\n    Retrieve the results of a simulation based on the given simulation id. This endpoint checks\n    the current status of the simulation and provides appropriate responses based on that status.\n    If the simulation is finished, the results are returned. If the status indicates in-progress,\n    failed, or canceled, it responds with corresponding error messages. Errors are also returned\n    if the simulation does not exist or if the request is unauthenticated.\n\n    :param simulation_id: The unique identifier of the simulation.\n    :param token: The OAuth2 token for authentication.\n    :param db: Database session dependency, used to query the database.\n    :return: A ResultResponse object containing simulation results if successful, or an\n             ErrorResponse object containing error details if an error occurs.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    simulation = db.get(EnSimulationDB, simulation_id)\n    if not simulation:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Simulation not found\")\n\n    if simulation.status == Status.STARTED.value:\n        return ErrorResponse(\n            errors=[ErrorModel(\n                code=status.HTTP_425_TOO_EARLY,\n                message=f\"Simulation {simulation_id} has not finished yet.\"\n            )]\n        )\n    elif simulation.status == Status.FAILED.value:\n        # TODO: Bessere R\u00fcckgabe von Fehlern bei \"failed\"\n        return ErrorResponse(\n            errors=[ErrorModel(\n                code=status.HTTP_409_CONFLICT,\n                message=f\"Simulation {simulation_id} has failed.\"\n            )]\n        )\n    elif simulation.status == Status.CANCELED.value:\n        return ErrorResponse(\n            errors=[ErrorModel(\n                code=status.HTTP_409_CONFLICT,\n                message=f\"Simulation {simulation_id} has cancelled.\"\n            )]\n        )\n    elif simulation.status == Status.FINISHED.value:\n        return ResultResponse(\n            data=get_results_from_dump(simulation.id, db),\n            success=True\n        )\n    else:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Simulation unknown status.\")\n</code></pre>"},{"location":"backend/api/router/results/#app.results.router.get_results_from_dump","title":"<code>get_results_from_dump(simulation_id, db)</code>","text":"<p>Fetches results from a simulation dump file based on the simulation ID. This function retrieves the energy system data from a serialized dump file stored in the local directory based on a simulation token. It processes the dump files, restores the energy system, and aggregates result sequences for each identified energy bus into structured data. The results are returned in the form of a ResultDataModel.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_id</code> <code>int</code> <p>ID of the simulation for which results are being fetched</p> required <code>db</code> <code>Session</code> <p>Database session used to query the simulation information</p> required <p>Returns:</p> Type Description <code>ResultDataModel</code> <p>A ResultDataModel containing the result data extracted from the dump and the total count of data entries</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Raised with status code 404 if the simulation ID does not exist or if the required dump file is not found</p> Source code in <code>backend/app/results/router.py</code> <pre><code>def get_results_from_dump(simulation_id: int, db: Session) -&gt; ResultDataModel:\n    \"\"\"\n    Fetches results from a simulation dump file based on the simulation ID. This function\n    retrieves the energy system data from a serialized dump file stored in the local directory\n    based on a simulation token. It processes the dump files, restores the energy system,\n    and aggregates result sequences for each identified energy bus into structured data.\n    The results are returned in the form of a ResultDataModel.\n\n    :param simulation_id: ID of the simulation for which results are being fetched\n    :type simulation_id: int\n    :param db: Database session used to query the simulation information\n    :type db: Session\n    :return: A ResultDataModel containing the result data extracted from the dump and the\n        total count of data entries\n    :rtype: ResultDataModel\n\n    :raises HTTPException: Raised with status code 404 if the simulation ID does not exist\n        or if the required dump file is not found\n    \"\"\"\n    simulation = db.get(EnSimulationDB, simulation_id)\n\n    if not simulation:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Simulation not found\")\n\n    simulation_token = simulation.sim_token\n    simulations_path = os.path.abspath(os.path.join(os.getenv(\"LOCAL_DATADIR\"), simulation_token, \"dump\"))\n    #print(f\"simulations_path: {simulations_path}\")\n\n    if not os.path.isfile(os.path.join(simulations_path, \"oemof_es.dump\")):\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Dumpfile not found\")\n\n    es = solph.EnergySystem()\n    es.restore(\n        dpath=simulations_path,\n        filename='oemof_es.dump'\n    )\n\n    busses = []\n    result_data = []\n\n    for node in es.nodes:\n        if isinstance(node, solph.Bus):\n            print(f\"Bus: {node}\")\n            busses.append(node)\n\n    # TODO: Dat muss nochmal \u00fcberdacht werden. Schon gut, aber irgendwie weird.\n    for bus in busses:\n        graph_data = []\n\n        for t, g in solph.views.node(es.results[\"main\"], node=bus)[\"sequences\"].items():\n            print(f\"G:{len(g)}\")\n            idx_asset = abs(t[0].index(bus) - 1)\n            if idx_asset &gt; 0:\n                time_series = EnTimeSeries(\n                    name=str(t[0][1]),\n                    data=nan_to_num(g.values) * pow(-1, idx_asset)\n                )\n            else:\n                time_series = EnTimeSeries(\n                    name=str(t[0][0]),\n                    data=nan_to_num(g.values) * pow(-1, idx_asset)\n                )\n\n            print(len(time_series.data))\n            graph_data.append(time_series)\n\n        bus_data: EnDataFrame = EnDataFrame(\n            name=f\"{bus}\",\n            index=es.timeindex.to_pydatetime(),\n            data=graph_data\n        )\n\n        result_data.append(bus_data)\n\n    return_data: ResultDataModel = ResultDataModel(\n        items=result_data,\n        totalCount=len(result_data),\n    )\n\n    return return_data\n</code></pre>"},{"location":"backend/api/router/scenario/","title":"scenario","text":""},{"location":"backend/api/router/scenario/#app.scenario.router.create_scenario","title":"<code>create_scenario(token, scenario_data, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Handles the creation of a new scenario within the system. It performs authentication, validates whether the token corresponds to an authorized user for the given project, and inserts the new scenario data into the database if all checks pass. Additionally, for debugging purposes, it saves the scenario data into a local JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>Bearer token used for authentication and validation of the user request</p> required <code>scenario_data</code> <code>EnScenario</code> <p>Instance of EnScenario containing details of the scenario to be created</p> required <code>db</code> <code>Session</code> <p>Database session object used to perform database operations</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A MessageResponse object indicating whether the scenario creation was successful, along with a success status</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Raised with status code 401 for scenarios such as missing authentication or unauthorized access</p> Source code in <code>backend/app/scenario/router.py</code> <pre><code>@scenario_router.post(\"/\", response_model=MessageResponse, status_code=status.HTTP_201_CREATED)\nasync def create_scenario(token: Annotated[str, Depends(oauth2_scheme)], scenario_data: EnScenario,\n                          db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Handles the creation of a new scenario within the system. It performs authentication, validates\n    whether the token corresponds to an authorized user for the given project, and inserts the new\n    scenario data into the database if all checks pass. Additionally, for debugging purposes, it\n    saves the scenario data into a local JSON file.\n\n    :param token: Bearer token used for authentication and validation of the user request\n    :type token: str\n    :param scenario_data: Instance of EnScenario containing details of the scenario to be created\n    :type scenario_data: EnScenario\n    :param db: Database session object used to perform database operations\n    :type db: Session\n    :return: A MessageResponse object indicating whether the scenario creation was successful,\n             along with a success status\n    :rtype: MessageResponse\n    :raises HTTPException: Raised with status code 401 for scenarios such as missing authentication\n                           or unauthorized access\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    project_id = scenario_data.project_id\n\n    token_data = decode_token(token)\n    statement = select(EnUserDB).where(EnUserDB.username == token_data[\"username\"])\n    token_user = db.exec(statement).first()\n\n    if not validate_project_owner(project_id, token, db):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    scenario = EnScenarioDB(**scenario_data.model_dump())\n    scenario.user_id = token_user.id\n\n    with open(os.path.join(os.getenv(\"LOCAL_DATADIR\"), \"debug.json\"), \"wt\") as f:\n        f.write(scenario.model_dump_json())\n\n    db.add(scenario)\n    db.commit()\n\n    return MessageResponse(\n        data=\"Scenario created.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/scenario/#app.scenario.router.delete_scenario","title":"<code>delete_scenario(token, scenario_id, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Deletes a scenario by its ID for authorized users only. This endpoint ensures that the caller owns the specified scenario before performing the deletion. If the scenario exists and the authorization is confirmed, it is removed from the database, and a success message is returned.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>Access token for authentication and authorization.</p> required <code>scenario_id</code> <code>int</code> <p>Unique identifier of the scenario to be deleted.</p> required <code>db</code> <code>Session</code> <p>Database session used for querying and deleting the scenario.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>MessageResponse confirming successful deletion.</p> Source code in <code>backend/app/scenario/router.py</code> <pre><code>@scenario_router.delete(\"/{scenario_id}\", response_model=MessageResponse)\nasync def delete_scenario(token: Annotated[str, Depends(oauth2_scheme)], scenario_id: int,\n                          db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Deletes a scenario by its ID for authorized users only. This endpoint ensures that the caller\n    owns the specified scenario before performing the deletion. If the scenario exists and the\n    authorization is confirmed, it is removed from the database, and a success message is returned.\n\n    :param token: Access token for authentication and authorization.\n    :type token: str\n    :param scenario_id: Unique identifier of the scenario to be deleted.\n    :type scenario_id: int\n    :param db: Database session used for querying and deleting the scenario.\n    :type db: Session\n    :return: MessageResponse confirming successful deletion.\n    :rtype: MessageResponse\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    validate_scenario_result, validate_scenario_code, validate_scenario_msg = validate_scenario_owner(scenario_id, db,\n                                                                                                      token)\n    if not validate_scenario_result:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    scenario = db.get(EnScenarioDB, scenario_id)\n    db.delete(scenario)\n    db.commit()\n\n    return MessageResponse(\n        data=\"Scenario deleted.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/scenario/#app.scenario.router.read_scenario","title":"<code>read_scenario(scenario_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Handles the retrieval of a specific scenario by its ID. It validates the user's authentication and ownership of the scenario and its associated project before returning the scenario details.</p> <p>Parameters:</p> Name Type Description Default <code>scenario_id</code> <code>int</code> <p>The ID of the scenario to be retrieved.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>Bearer token for user authentication and authorization.</p> required <code>db</code> <code>Session</code> <p>SQLAlchemy database session dependency.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>A response containing the scenario details, wrapped in a DataResponse.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Raised with status 401 if the token is invalid, the user is not authenticated, or not authorized to access the scenario.</p> <code>HTTPException</code> <p>Raised with status 404 if the specified scenario is not found.</p> Source code in <code>backend/app/scenario/router.py</code> <pre><code>@scenario_router.get(\"/{scenario_id}\", response_model=DataResponse)\nasync def read_scenario(scenario_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                        db: Session = Depends(get_db_session)) -&gt; DataResponse:\n    \"\"\"\n    Handles the retrieval of a specific scenario by its ID. It validates the user's\n    authentication and ownership of the scenario and its associated project before\n    returning the scenario details.\n\n    :param scenario_id: The ID of the scenario to be retrieved.\n    :type scenario_id: int\n    :param token: Bearer token for user authentication and authorization.\n    :type token: str\n    :param db: SQLAlchemy database session dependency.\n    :type db: Session\n    :return: A response containing the scenario details, wrapped in a DataResponse.\n    :rtype: DataResponse\n    :raises HTTPException: Raised with status 401 if the token is invalid, the user\n        is not authenticated, or not authorized to access the scenario.\n    :raises HTTPException: Raised with status 404 if the specified scenario is not found.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    validate_scenario_result, validate_scenario_code, validate_scenario_msg = validate_scenario_owner(scenario_id, db,\n                                                                                                      token)\n    if not validate_scenario_result:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    scenario = db.get(EnScenarioDB, scenario_id)\n    if not scenario:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Scenario not found.\")\n\n    if not validate_project_owner(scenario.project_id, token, db):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=[scenario.model_dump()],\n            totalCount=1\n        ),\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/scenario/#app.scenario.router.read_scenarios","title":"<code>read_scenarios(project_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Reads and retrieves scenarios associated with the given project identifier. The function requires the user to be authenticated and authorized as the owner of the project. It fetches scenarios from the database, maps them to the required model, and returns the response encapsulated in a data model.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The unique identifier of the project whose scenarios are to be retrieved.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The bearer token used for authentication and authorization.</p> required <code>db</code> <code>Session</code> <p>The SQLAlchemy Session dependency used to interact with the database.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>A DataResponse object containing the retrieved scenarios, the total count of scenarios, and a success status.</p> Source code in <code>backend/app/scenario/router.py</code> <pre><code>@scenario_router.get(\"s/{project_id}\", response_model=DataResponse)\nasync def read_scenarios(project_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                         db: Session = Depends(get_db_session)) -&gt; DataResponse:\n    \"\"\"\n    Reads and retrieves scenarios associated with the given project identifier.\n    The function requires the user to be authenticated and authorized as the\n    owner of the project. It fetches scenarios from the database, maps them\n    to the required model, and returns the response encapsulated in a data model.\n\n    :param project_id: The unique identifier of the project whose scenarios are to be retrieved.\n    :param token: The bearer token used for authentication and authorization.\n    :param db: The SQLAlchemy Session dependency used to interact with the database.\n    :return: A DataResponse object containing the retrieved scenarios, the total count\n        of scenarios, and a success status.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    if not validate_project_owner(project_id, token, db):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    statement = select(EnScenarioDB).where(EnScenarioDB.project_id == project_id)\n    scenarios = db.exec(statement)\n\n    response_data = []\n    for scenario in scenarios:\n        response_data.append(scenario.model_dump())\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=response_data,\n            totalCount=len(response_data)\n        ),\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/scenario/#app.scenario.router.update_scenario","title":"<code>update_scenario(token, scenario_id, scenario_data, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Updates an existing scenario given its ID. This function verifies the authentication token, validates scenario ownership, and checks the existence of the scenario in the database. The scenario details are updated only if all validations pass. The updated data is then saved to the database.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>Authentication bearer token for verifying the user's session.</p> required <code>scenario_id</code> <code>int</code> <p>Integer representing the unique identifier of the scenario to update.</p> required <code>scenario_data</code> <code>EnScenarioUpdate</code> <p>Pydantic model object containing the updated scenario data fields.</p> required <code>db</code> <code>Session</code> <p>Dependency-injected SQLAlchemy database session object.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A response message indicating whether the scenario was updated successfully.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Raised with appropriate status codes if authentication fails, ownership validation fails, or the scenario is not found.</p> Source code in <code>backend/app/scenario/router.py</code> <pre><code>@scenario_router.patch(\"/{scenario_id}\", response_model=MessageResponse)\nasync def update_scenario(token: Annotated[str, Depends(oauth2_scheme)], scenario_id: int,\n                          scenario_data: EnScenarioUpdate, db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Updates an existing scenario given its ID. This function verifies the authentication token,\n    validates scenario ownership, and checks the existence of the scenario in the database.\n    The scenario details are updated only if all validations pass. The updated data is then\n    saved to the database.\n\n    :param token: Authentication bearer token for verifying the user's session.\n    :type token: str\n    :param scenario_id: Integer representing the unique identifier of the scenario to update.\n    :type scenario_id: int\n    :param scenario_data: Pydantic model object containing the updated scenario data fields.\n    :type scenario_data: EnScenarioUpdate\n    :param db: Dependency-injected SQLAlchemy database session object.\n    :type db: Session\n    :return: A response message indicating whether the scenario was updated successfully.\n    :rtype: MessageResponse\n    :raises HTTPException: Raised with appropriate status codes if authentication fails,\n                           ownership validation fails, or the scenario is not found.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    validate_scenario_result, validate_scenario_code, validate_scenario_msg = validate_scenario_owner(scenario_id, db,\n                                                                                                      token)\n    if not validate_scenario_result:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    db_scenario = db.get(EnScenarioDB, scenario_id)\n    if not db_scenario:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Scenario not found.\")\n\n    new_scenario_data = scenario_data.model_dump(exclude_unset=True)\n\n    db_scenario.sqlmodel_update(new_scenario_data)\n\n    db.add(db_scenario)\n    db.commit()\n    db.refresh(db_scenario)\n\n    return MessageResponse(\n        data=\"Scenario updated.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/scenario/#app.scenario.router.validate_scenario_owner","title":"<code>validate_scenario_owner(scenario_id, db, token)</code>","text":"<p>Validates whether the owner of a given scenario matches the user from the provided authentication token. This function ensures that the logged-in user has the authorization to access or modify the scenario.</p> <p>Parameters:</p> Name Type Description Default <code>scenario_id</code> <code>int</code> <p>ID of the scenario to validate ownership for.</p> required <code>db</code> <code>Session</code> <p>Database session for executing queries and retrieving data.</p> required <code>token</code> <code>str</code> <p>Authentication token representing the logged-in user.</p> required <p>Returns:</p> Type Description <code>tuple(bool, int, str)</code> <p>A tuple containing three values: - A boolean indicating whether the user is the owner of the scenario. - An HTTP status code indicating the result of the validation. - A string message explaining the result (empty string if validation is successful).</p> Source code in <code>backend/app/scenario/router.py</code> <pre><code>def validate_scenario_owner(scenario_id, db, token) -&gt; (bool, int, str):\n    \"\"\"\n    Validates whether the owner of a given scenario matches the user from the provided\n    authentication token. This function ensures that the logged-in user has the\n    authorization to access or modify the scenario.\n\n    :param scenario_id: ID of the scenario to validate ownership for.\n    :type scenario_id: int\n    :param db: Database session for executing queries and retrieving data.\n    :type db: Session\n    :param token: Authentication token representing the logged-in user.\n    :type token: str\n    :return: A tuple containing three values:\n             - A boolean indicating whether the user is the owner of the scenario.\n             - An HTTP status code indicating the result of the validation.\n             - A string message explaining the result (empty string if validation\n               is successful).\n    :rtype: tuple(bool, int, str)\n    \"\"\"\n    token_data = decode_token(token)\n\n    statement = select(EnUserDB).where(EnUserDB.username == token_data[\"username\"])\n    user = db.exec(statement).first()\n    if not user:\n        return False, status.HTTP_404_NOT_FOUND, \"User not found.\"\n\n    scenario = db.get(EnScenarioDB, scenario_id)\n\n    if scenario.user_id == user.id:\n        return True, status.HTTP_200_OK, \"\"\n    else:\n        return False, status.HTTP_401_UNAUTHORIZED, \"User not authorized.\"\n</code></pre>"},{"location":"backend/api/router/simulation/","title":"simulation","text":""},{"location":"backend/api/router/simulation/#app.simulation.router.check_container_status","title":"<code>check_container_status(docker_container, simulation_id, db)</code>","text":"<p>Check the status of a Docker container and update the status of an associated simulation in the database accordingly.</p> <p>This function waits for the completion of a Docker container and retrieves its exit code. If the exit code indicates an error, an HTTPException is raised with the container logs. Otherwise, it updates the simulation's status to finished, sets the end date, and commits the changes to the database.</p> <p>Parameters:</p> Name Type Description Default <code>docker_container</code> <p>Docker container object representing the container to be monitored</p> required <code>simulation_id</code> <p>The unique identifier of the simulation associated with the Docker container</p> required <code>db</code> <p>Database session object used for querying and persisting updates</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>backend/app/simulation/router.py</code> <pre><code>def check_container_status(docker_container, simulation_id, db):\n    \"\"\"\n    Check the status of a Docker container and update the status of an associated simulation\n    in the database accordingly.\n\n    This function waits for the completion of a Docker container and retrieves its exit code.\n    If the exit code indicates an error, an HTTPException is raised with the container logs.\n    Otherwise, it updates the simulation's status to finished, sets the end date, and commits\n    the changes to the database.\n\n    :param docker_container: Docker container object representing the container to be monitored\n    :param simulation_id: The unique identifier of the simulation associated with the Docker container\n    :param db: Database session object used for querying and persisting updates\n    :return: None\n    \"\"\"\n    result_dict = docker_container.wait()\n\n    simulation = db.get(EnSimulationDB, simulation_id)\n\n    if result_dict[\"StatusCode\"] &gt; 0:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=docker_container.logs())\n    else:\n        simulation.status = Status.FINISHED.value\n        simulation.end_date = datetime.now()\n        db.commit()\n        db.refresh(simulation)\n</code></pre>"},{"location":"backend/api/router/simulation/#app.simulation.router.delete_simulation","title":"<code>delete_simulation(token, simulation_id, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Deletes a simulation from the database based on the given simulation ID. The user must be authenticated via a token for the operation to proceed.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The authenticated token required to access the endpoint.</p> required <code>simulation_id</code> <code>int</code> <p>The ID of the simulation to be deleted.</p> required <code>db</code> <code>Session</code> <p>The database session used to retrieve and delete the simulation record.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A response indicating whether the simulation was successfully deleted.</p> Source code in <code>backend/app/simulation/router.py</code> <pre><code>@simulation_router.delete(\"/{simulation_id}\")\nasync def delete_simulation(token: Annotated[str, Depends(oauth2_scheme)], simulation_id: int,\n                            db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Deletes a simulation from the database based on the given simulation ID. The user must be authenticated\n    via a token for the operation to proceed.\n\n    :param token: The authenticated token required to access the endpoint.\n    :param simulation_id: The ID of the simulation to be deleted.\n    :param db: The database session used to retrieve and delete the simulation record.\n\n    :return: A response indicating whether the simulation was successfully deleted.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n        # return DataResponse(\n        #     data=None,\n        #     success=False,\n        #     errors=[ErrorModel(\n        #         code=status.HTTP_401_UNAUTHORIZED,\n        #         message=\"Not authenticated.\"\n        #     )],\n        # )\n\n    simulation = db.get(EnSimulationDB, simulation_id)\n    db.delete(simulation)\n    db.commit()\n\n    return MessageResponse(\n        data=\"Simulation deleted.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/simulation/#app.simulation.router.get_simulation","title":"<code>get_simulation(simulation_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Fetches and returns simulation data based on the specified simulation ID. The request must include a valid authentication token. The function verifies user rights before retrieving the simulation. If the simulation does not exist or the user lacks the necessary permissions, appropriate HTTP exceptions are raised.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_id</code> <code>int</code> <p>The ID of the simulation to be fetched.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The authentication token for validating the request.</p> required <code>db</code> <code>Session</code> <p>Database session dependency injected to access the database.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>A <code>DataResponse</code> object containing the simulation data and metadata.</p> Source code in <code>backend/app/simulation/router.py</code> <pre><code>@simulation_router.get(\"/{simulation_id}\", response_model=DataResponse)\nasync def get_simulation(simulation_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                         db: Session = Depends(get_db_session)) -&gt; DataResponse:\n    \"\"\"\n    Fetches and returns simulation data based on the specified simulation ID. The request\n    must include a valid authentication token. The function verifies user rights before\n    retrieving the simulation. If the simulation does not exist or the user lacks the\n    necessary permissions, appropriate HTTP exceptions are raised.\n\n    :param simulation_id: The ID of the simulation to be fetched.\n    :param token: The authentication token for validating the request.\n    :param db: Database session dependency injected to access the database.\n    :return: A `DataResponse` object containing the simulation data and metadata.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    simulation = db.exec(select(EnSimulationDB).where(EnSimulationDB.id == simulation_id)).first()\n    if not simulation:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"No Simulation found.\")\n\n    if not validate_user_rights(token=token, scenario_id=simulation.scenario_id, db=db):\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=[simulation],\n            totalCount=1,\n        ),\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/simulation/#app.simulation.router.get_simulation_status","title":"<code>get_simulation_status(simulation_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>This function retrieves the status of a specific simulation based on the provided simulation ID. It performs authentication and authorization checks to ensure proper access control. If the simulation exists and the user has the required access permissions, it fetches and returns the simulation's status wrapped in a success response.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_id</code> <code>int</code> <p>ID of the simulation to retrieve status for.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>Access token provided by the client for authorization.</p> required <code>db</code> <code>Session</code> <p>Database session required to access simulation data.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A <code>MessageResponse</code> instance containing the simulation's status if found and accessible.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <ul> <li>401 Unauthorized if the provided token is invalid or the user lacks appropriate rights. - 404 Not Found if the simulation with the specified ID does not exist.</li> </ul> Source code in <code>backend/app/simulation/router.py</code> <pre><code>@simulation_router.get(\"/status/{simulation_id}\", response_model=MessageResponse)\nasync def get_simulation_status(simulation_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                                db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    This function retrieves the status of a specific simulation based on the provided simulation ID.\n    It performs authentication and authorization checks to ensure proper access control. If the\n    simulation exists and the user has the required access permissions, it fetches and returns\n    the simulation's status wrapped in a success response.\n\n    :param simulation_id: ID of the simulation to retrieve status for.\n    :param token: Access token provided by the client for authorization.\n    :param db: Database session required to access simulation data.\n    :return: A `MessageResponse` instance containing the simulation's status if found and accessible.\n    :raises HTTPException:\n        - 401 Unauthorized if the provided token is invalid or the user lacks appropriate rights.\n        - 404 Not Found if the simulation with the specified ID does not exist.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    simulation = db.exec(select(EnSimulationDB).where(EnSimulationDB.id == simulation_id)).first()\n    if not simulation:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"No Simulation found.\")\n\n    if not validate_user_rights(token=token, scenario_id=simulation.scenario_id, db=db):\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    selected_simulation = db.get(EnSimulationDB, simulation_id)\n\n    return MessageResponse(\n        data=selected_simulation.status,\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/simulation/#app.simulation.router.get_simulations","title":"<code>get_simulations(scenario_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Handles fetching simulation data for a specific scenario, ensuring the user is authenticated and authorized to access the data. If the user is not authenticated or authorized, it raises corresponding HTTP exceptions. If no simulations are found for the provided scenario ID, a 404 Not Found error is returned.</p> <p>Parameters:</p> Name Type Description Default <code>scenario_id</code> <code>int</code> <p>The ID of the scenario for which simulations are retrieved.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The authentication token provided by the user, validated using the oauth2 scheme.</p> required <code>db</code> <code>Session</code> <p>The database session dependency object for querying and accessing the database.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>A DataResponse object containing the simulation data (items and count) with a success flag.</p> Source code in <code>backend/app/simulation/router.py</code> <pre><code>@simulation_router.get(\"s/{scenario_id}\", response_model=DataResponse)\nasync def get_simulations(scenario_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                          db: Session = Depends(get_db_session)) -&gt; DataResponse:\n    \"\"\"\n    Handles fetching simulation data for a specific scenario, ensuring the user is\n    authenticated and authorized to access the data. If the user is not authenticated\n    or authorized, it raises corresponding HTTP exceptions. If no simulations are found\n    for the provided scenario ID, a 404 Not Found error is returned.\n\n    :param scenario_id: The ID of the scenario for which simulations are retrieved.\n    :param token: The authentication token provided by the user, validated\n                  using the oauth2 scheme.\n    :param db: The database session dependency object for querying and accessing\n               the database.\n    :return: A DataResponse object containing the simulation data (items and count)\n             with a success flag.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    if not validate_user_rights(token=token, scenario_id=scenario_id, db=db):\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    simulations = db.exec(select(EnSimulationDB).where(EnSimulationDB.scenario_id == scenario_id)).all()\n    if not simulations:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"No Simulations found.\")\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=simulations,\n            totalCount=len(simulations),\n        ),\n        success=True,\n    )\n</code></pre>"},{"location":"backend/api/router/simulation/#app.simulation.router.start_simulation","title":"<code>start_simulation(scenario_id, background_tasks, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Starts a new simulation for a given scenario and ensures any currently running simulations for the same scenario are stopped. It creates a new simulation entry in the database, generates a unique task ID, and initiates the simulation task.</p> <p>Parameters:</p> Name Type Description Default <code>scenario_id</code> <code>int</code> <p>The ID of the scenario for which the simulation is being started.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>The background tasks object provided by FastAPI's dependency injection.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The authentication token used to authenticate and authorize the user.</p> required <code>db</code> <code>Session</code> <p>The session used for database interaction, provided by dependency injection.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A response containing success information and details of the initiated task.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If authentication or authorization fails.</p> Source code in <code>backend/app/simulation/router.py</code> <pre><code>@simulation_router.post(\"/start/{scenario_id}\", response_model=MessageResponse)\nasync def start_simulation(scenario_id: int, background_tasks: BackgroundTasks,\n                           token: Annotated[str, Depends(oauth2_scheme)],\n                           db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Starts a new simulation for a given scenario and ensures any currently running simulations\n    for the same scenario are stopped. It creates a new simulation entry in the database, generates\n    a unique task ID, and initiates the simulation task.\n\n    :param scenario_id: The ID of the scenario for which the simulation is being started.\n    :type scenario_id: int\n    :param background_tasks: The background tasks object provided by FastAPI's dependency injection.\n    :type background_tasks: BackgroundTasks\n    :param token: The authentication token used to authenticate and authorize the user.\n    :type token: str\n    :param db: The session used for database interaction, provided by dependency injection.\n    :type db: Session\n    :return: A response containing success information and details of the initiated task.\n    :rtype: MessageResponse\n    :raises HTTPException: If authentication or authorization fails.\n    \"\"\"\n    if not token:\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    if not validate_user_rights(token=token, scenario_id=scenario_id, db=db):\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    # Get old Simulation and stop it\n    running_simulations = db.exec(select(EnSimulationDB).where(EnSimulationDB.scenario_id == scenario_id).where(\n        EnSimulationDB.status == Status.STARTED.value)).all()\n\n    if running_simulations:\n        for running_simulation in running_simulations:\n            running_simulation.status = Status.CANCELED.value\n            running_simulation.end_date = datetime.now()\n            db.commit()\n\n    simulation_token = uuid()\n\n    # Create a new Simulation\n    simulation = EnSimulationDB(\n        sim_token=simulation_token,\n        start_date=datetime.now(),\n        end_date=None,\n        scenario_id=scenario_id,\n    )\n\n    db.add(simulation)\n    db.commit()\n    db.refresh(simulation)\n\n    # Start eines Celery Tasks f\u00fcr die Durchf\u00fchrung der Simulation\n    task = simulation_task.apply_async((scenario_id, simulation.id), task_id=simulation_token)\n    logger.info(\"Task UUID:\", task.id)\n\n    return MessageResponse(\n        data=f\"Simulation with id:{simulation.id} and task id:{task.id} started.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/simulation/#app.simulation.router.stop_simulation","title":"<code>stop_simulation(simulation_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Stops a simulation with the specified simulation ID. This operation first validates the user's authentication and authorization using the provided token, then retrieves the simulation from the database. If the simulation is found and the user has the appropriate rights, the simulation task is manually stopped through the 'revoke' method. A success message is returned upon successful completion.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_id</code> <code>int</code> <p>The identifier of the simulation to be stopped.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>A token to validate user authentication and authorization.</p> required <code>db</code> <code>Session</code> <p>The database session dependency used to access and query the database.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A message response indicating a success message and the ID of the stopped simulation.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Raises a 401 Unauthorized error if the token is missing or invalid, or if the user is not authorized. Raises a 404 Not Found error if the specified simulation ID does not exist.</p> Source code in <code>backend/app/simulation/router.py</code> <pre><code>@simulation_router.post(\"/stop/{simulation_id}\", response_model=MessageResponse)\nasync def stop_simulation(simulation_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                          db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Stops a simulation with the specified simulation ID. This operation first\n    validates the user's authentication and authorization using the provided\n    token, then retrieves the simulation from the database. If the simulation is\n    found and the user has the appropriate rights, the simulation task is\n    manually stopped through the 'revoke' method. A success message is returned\n    upon successful completion.\n\n    :param simulation_id: The identifier of the simulation to be stopped.\n    :type simulation_id: int\n    :param token: A token to validate user authentication and authorization.\n    :type token: str\n    :param db: The database session dependency used to access and query the\n        database.\n    :type db: Session\n    :return: A message response indicating a success message and the ID of the\n        stopped simulation.\n    :rtype: MessageResponse\n    :raises HTTPException: Raises a 401 Unauthorized error if the token is missing\n        or invalid, or if the user is not authorized. Raises a 404 Not Found error\n        if the specified simulation ID does not exist.\n    \"\"\"\n    if not token:\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    simulation = db.get(EnSimulationDB, simulation_id)\n    if not simulation:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"No Simulation found.\")\n\n    if not validate_user_rights(token=token, scenario_id=simulation.scenario_id, db=db):\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    # Task manuell stoppen\n    revoke(simulation.sim_token, terminate=True)\n\n    return MessageResponse(\n        data=f\"Simulation with id:{simulation.sim_token} stopped.\",\n        success=True,\n    )\n</code></pre>"},{"location":"backend/api/router/simulation/#app.simulation.router.stop_simulations","title":"<code>stop_simulations(scenario_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Stop active simulations for a specified scenario.</p> <p>This endpoint allows stopping all running simulations associated with a specific scenario. Authorization and user permission checks are performed before proceeding. If more than one simulation is found, a conflict error is reported. Additionally, background tasks associated with the simulations are terminated.</p> <p>Parameters:</p> Name Type Description Default <code>scenario_id</code> <code>int</code> <p>ID of the scenario whose simulations are to be stopped.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>Authentication token for user validation.</p> required <code>db</code> <code>Session</code> <p>Database session for querying and updating simulation data.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>Response object indicating success or failure of the operation along with details of any encountered errors.</p> Source code in <code>backend/app/simulation/router.py</code> <pre><code>@simulation_router.post(\"s/stop/{scenario_id}\", response_model=MessageResponse)\nasync def stop_simulations(scenario_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                           db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Stop active simulations for a specified scenario.\n\n    This endpoint allows stopping all running simulations associated with a specific\n    scenario. Authorization and user permission checks are performed before proceeding.\n    If more than one simulation is found, a conflict error is reported. Additionally,\n    background tasks associated with the simulations are terminated.\n\n    :param scenario_id: ID of the scenario whose simulations are to be stopped.\n    :type scenario_id: int\n    :param token: Authentication token for user validation.\n    :type token: str\n    :param db: Database session for querying and updating simulation data.\n    :type db: Session\n    :return: Response object indicating success or failure of the operation along\n             with details of any encountered errors.\n    :rtype: MessageResponse\n    \"\"\"\n    errors = []\n    if not token:\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    if not validate_user_rights(token=token, scenario_id=scenario_id, db=db):\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    simulations = db.exec(select(EnSimulationDB).where(EnSimulationDB.status == Status.STARTED.value).where(\n        EnSimulationDB.scenario_id == scenario_id)).all()\n    if not simulations:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"No Simulation found.\")\n\n    if len(simulations) &gt; 1:\n        errors.append(ErrorModel(\n            code=status.HTTP_409_CONFLICT,\n            message=\"Mehr als 2 Simulationen laufen, du Bob hast vergessen beim Starten die alte zu beenden!\"\n        ))\n\n    # TODO: Wie stoppe ich Background-Tasks?\n    # Task manuell stoppen\n    for simulation in simulations:\n        revoke(simulation.sim_token, terminate=True)\n\n    return MessageResponse(\n        data=f\"Simulation stopped.\",\n        success=True,\n        errors=errors\n    )\n</code></pre>"},{"location":"backend/api/router/simulation/#app.simulation.router.validate_user_rights","title":"<code>validate_user_rights(token, scenario_id, db)</code>","text":"<p>Validates a user's rights to access a specific scenario within a project. The function first validates whether the user is the owner of the given scenario, and subsequently verifies ownership of the associated project. Raises appropriate HTTP exceptions if the user is unauthorized or if the specified scenario or project does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Authentication token of the user.</p> required <code>scenario_id</code> <code>int</code> <p>ID of the scenario to validate access for.</p> required <code>db</code> <code>Session</code> <p>Database session/connection object used for querying related data.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>A boolean indicating whether the user is authorized to access the scenario.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the user is unauthorized or the specified scenario or project is not found.</p> Source code in <code>backend/app/simulation/router.py</code> <pre><code>def validate_user_rights(token, scenario_id, db) -&gt; bool:\n    \"\"\"\n    Validates a user's rights to access a specific scenario within a project. The function first\n    validates whether the user is the owner of the given scenario, and subsequently verifies ownership of the\n    associated project. Raises appropriate HTTP exceptions if the user is unauthorized or if the specified\n    scenario or project does not exist.\n\n    :param token: Authentication token of the user.\n    :type token: str\n    :param scenario_id: ID of the scenario to validate access for.\n    :type scenario_id: int\n    :param db: Database session/connection object used for querying related data.\n    :type db: Session\n    :return: A boolean indicating whether the user is authorized to access the scenario.\n    :rtype: bool\n    :raises HTTPException: If the user is unauthorized or the specified scenario or project is not found.\n    \"\"\"\n\n    validation_scenario = validate_scenario_owner(\n        token=token,\n        scenario_id=scenario_id,\n        db=db\n    )\n    if not validation_scenario:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    scenario = db.exec(select(EnScenarioDB).where(EnScenarioDB.id == scenario_id)).first()\n    if not scenario:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Scenario not found.\")\n\n    project = db.exec(select(EnProjectDB).where(EnProjectDB.id == scenario.project_id)).first()\n    if not project:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Project not found.\")\n\n    validation_project = validate_project_owner(\n        token=token,\n        project_id=project.id,\n        db=db,\n    )\n    if not validation_project:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    return True\n</code></pre>"},{"location":"backend/api/router/user/","title":"user","text":""},{"location":"backend/api/router/user/#app.user.router.delete_user","title":"<code>delete_user(token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Deletes a user based on the credentials and token provided. The function retrieves the user's data from the database using the information decoded from the token. If the user does not exist, an HTTP exception is raised. If the user exists, the function proceeds to delete the user from the database and commits the transaction.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>An access token for the user requesting deletion.</p> required <code>db</code> <code>Session</code> <p>A SQLAlchemy session dependency for interacting with the database.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A <code>MessageResponse</code> indicating the outcome of the operation.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the user is not found, with status code 404.</p> Source code in <code>backend/app/user/router.py</code> <pre><code>@users_router.delete(\"/\", response_model=MessageResponse)\nasync def delete_user(token: Annotated[str, Depends(oauth2_scheme)],\n                      db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Deletes a user based on the credentials and token provided. The function\n    retrieves the user's data from the database using the information decoded\n    from the token. If the user does not exist, an HTTP exception is raised.\n    If the user exists, the function proceeds to delete the user from the\n    database and commits the transaction.\n\n    :param token: An access token for the user requesting deletion.\n    :param db: A SQLAlchemy session dependency for interacting with the database.\n    :return: A `MessageResponse` indicating the outcome of the operation.\n    :rtype: MessageResponse\n    :raises HTTPException: If the user is not found, with status code 404.\n    \"\"\"\n    token_data = decode_token(token)\n\n    if not \"id\" in token_data:\n        statement = select(EnUserDB).where(EnUserDB.username == token_data[\"username\"])\n        user = db.exec(statement).first()\n    else:\n        user = db.get(EnUser, token_data[\"id\"])\n\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"User not found.\")\n        # return DataResponse(\n        #     data=None,\n        #     success=False,\n        #     errors=[ErrorModel(\n        #         code=status.HTTP_404_NOT_FOUND,\n        #         message=\"User not found.\"\n        #     )]\n        # )\n\n    db.delete(user)\n    db.commit()\n\n    return MessageResponse(\n        data=f\"User was successfully deleted.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/user/#app.user.router.update_user","title":"<code>update_user(token, user, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Updates the user information in the database based on the provided token and user data. The token is used to authenticate and retrieve the corresponding user. The user details in the database are updated with the provided data, and the updated information is returned.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The authentication token identifying the user to be updated.</p> required <code>user</code> <code>EnUserUpdate</code> <p>The updated details of the user.</p> required <code>db</code> <code>Session</code> <p>The database session used for executing queries.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>Response containing the updated user details in a data response format.</p> Source code in <code>backend/app/user/router.py</code> <pre><code>@users_router.patch(\"/\", response_model=DataResponse)\nasync def update_user(token: Annotated[str, Depends(oauth2_scheme)], user: EnUserUpdate,\n                      db: Session = Depends(get_db_session)) -&gt; DataResponse:\n    \"\"\"\n    Updates the user information in the database based on the provided token and\n    user data. The token is used to authenticate and retrieve the corresponding\n    user. The user details in the database are updated with the provided data,\n    and the updated information is returned.\n\n    :param token: The authentication token identifying the user to be updated.\n    :type token: str\n    :param user: The updated details of the user.\n    :type user: EnUserUpdate\n    :param db: The database session used for executing queries.\n    :type db: Session\n    :return: Response containing the updated user details in a data response format.\n    :rtype: DataResponse\n    \"\"\"\n    token_data = decode_token(token)\n\n    statement = select(EnUserDB).where(EnUserDB.username == token_data[\"username\"])\n    user_db = db.exec(statement).first()\n\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"User not found.\")\n        # return DataResponse(\n        #     data=None,\n        #     success=False,\n        #     errors=[ErrorModel(\n        #         code=status.HTTP_404_NOT_FOUND,\n        #         message=\"User not found.\"\n        #     )]\n        # )\n\n    for field, value in user.model_dict().items():\n        print(field, \":\", value)\n        setattr(user_db, field, value)\n\n    db.commit()\n    db.refresh(user_db)\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=[user.model_dump()],\n            totalCount=1,\n        ),\n        success=True,\n    )\n</code></pre>"},{"location":"backend/api/router/user/#app.user.router.user_login","title":"<code>user_login(username=Form(...), password=Form(...), db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Authenticates a user and generates an access token upon successful login.</p> <p>This function allows the user to log into the system by providing the correct credentials. Upon successful authentication, an access token is generated and returned with additional details. If the credentials are invalid or the user does not exist, appropriate exceptions are raised.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username of the user attempting to log in.</p> <code>Form(...)</code> <code>password</code> <code>str</code> <p>The password associated with the username.</p> <code>Form(...)</code> <code>db</code> <code>Session</code> <p>The database session dependency that allows for database queries.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>JSONResponse</code> <p>A JSON response containing a success message, an access token, and the token type if authentication is successful.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Raised with status code 404 if the user does not exist, or with status code 401 if the password is incorrect.</p> Source code in <code>backend/app/user/router.py</code> <pre><code>@users_router.post(\"/auth/login\")\nasync def user_login(username: str = Form(...), password: str = Form(...), db: Session = Depends(get_db_session)):\n    \"\"\"\n    Authenticates a user and generates an access token upon successful login.\n\n    This function allows the user to log into the system by providing the correct\n    credentials. Upon successful authentication, an access token is generated\n    and returned with additional details. If the credentials are invalid or the\n    user does not exist, appropriate exceptions are raised.\n\n    :param username: The username of the user attempting to log in.\n    :type username: str\n    :param password: The password associated with the username.\n    :type password: str\n    :param db: The database session dependency that allows for database queries.\n    :type db: Session\n    :return: A JSON response containing a success message, an access token,\n        and the token type if authentication is successful.\n    :rtype: JSONResponse\n    :raises HTTPException: Raised with status code 404 if the user does not exist,\n        or with status code 401 if the password is incorrect.\n    \"\"\"\n    statement = select(EnUserDB).where(EnUserDB.username == username)\n    user_db = db.exec(statement).first()\n\n    if not user_db:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"User not found.\")\n\n    if user_db.verify_password(password):\n        user_db.last_login = datetime.now()\n        db.add(user_db)\n        db.commit()\n        db.refresh(user_db)\n\n        token = jwt.encode(user_db.get_token_information(), token_secret, algorithm=\"HS256\")\n\n        # return DataResponse(\n        #     data={\n        #         \"message\": \"User login successful.\",\n        #         \"access_token\": token,\n        #         \"token_type\": \"bearer\"\n        #     },\n        #     success=True,\n        #     errors=None\n        # )\n\n        return JSONResponse(\n            content={\n                \"message\": \"User login successful.\",\n                \"access_token\": token,\n                \"token_type\": \"bearer\"},\n            status_code=status.HTTP_200_OK\n        )\n    else:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Password incorrect.\")\n</code></pre>"},{"location":"backend/api/router/user/#app.user.router.user_read","title":"<code>user_read(token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Handles a GET API endpoint to read user information from the database.</p> <p>This function authenticates the request using the provided token and retrieves the corresponding user data from the database. If the token is invalid or the user is not found, appropriate HTTP exceptions are raised. On successful retrieval, it returns the user data wrapped in a response model.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>A token string obtained through user authentication.</p> required <code>db</code> <code>Session</code> <p>The database session used for querying user data.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>A DataResponse instance containing user information if authentication and retrieval are successful.</p> Source code in <code>backend/app/user/router.py</code> <pre><code>@users_router.get(\"/\", response_model=DataResponse)\nasync def user_read(token: Annotated[str, Depends(oauth2_scheme)],\n                    db: Session = Depends(get_db_session)) -&gt; DataResponse:\n    \"\"\"\n    Handles a GET API endpoint to read user information from the database.\n\n    This function authenticates the request using the provided token and retrieves\n    the corresponding user data from the database. If the token is invalid or the\n    user is not found, appropriate HTTP exceptions are raised. On successful retrieval,\n    it returns the user data wrapped in a response model.\n\n    :param token: A token string obtained through user authentication.\n    :type token: str\n\n    :param db: The database session used for querying user data.\n    :type db: Session\n\n    :return: A DataResponse instance containing user information if authentication\n             and retrieval are successful.\n    :rtype: DataResponse\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n        # return DataResponse(\n        #     data=None,\n        #     success=False,\n        #     errors=[ErrorModel(\n        #         code=status.HTTP_401_UNAUTHORIZED,\n        #         message=\"Not authenticated.\"\n        #     )]\n        # )\n    else:\n        token_data = decode_token(token)\n\n    statement = select(EnUserDB).where(EnUserDB.username == token_data[\"username\"])\n    user = db.exec(statement).first()\n\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"User not found.\")\n        # return DataResponse(\n        #     data=None,\n        #     success=False,\n        #     errors=[ErrorModel(\n        #         code=status.HTTP_404_NOT_FOUND,\n        #         message=\"User not found.\"\n        #     )]\n        # )\n    else:\n        return DataResponse(\n            data=GeneralDataModel(\n                items=[user.model_dump()],\n                totalCount=1,\n            ),\n            success=True,\n        )\n</code></pre>"},{"location":"backend/api/router/user/#app.user.router.user_register","title":"<code>user_register(user, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Registers a new user in the system. The function verifies whether the username and email provided by the user are unique before proceeding with the creation of a new user record. If the username or email is already in use, an exception is raised with the appropriate error details. A successful registration results in the creation of a persisted user entity in the database. Passwords are securely hashed before storage to ensure data protection.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>EnUser</code> <p>An instance of EnUser containing the user's registration details, including username, email, and password. Type: EnUser</p> required <code>db</code> <code>Session</code> <p>Dependency-injected database session to interact with the database. Type: Session</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A response model indicating the success of the operation. Returns a MessageResponse object on success.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <ul> <li>If the username is already in use (HTTP status 409). - If the email is already in use (HTTP status 409). - If user registration fails due to an unknown issue (HTTP status 404).</li> </ul> Source code in <code>backend/app/user/router.py</code> <pre><code>@users_router.post(\"/auth/register\", status_code=status.HTTP_201_CREATED, response_model=MessageResponse)\nasync def user_register(user: EnUser, db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Registers a new user in the system. The function verifies whether the username\n    and email provided by the user are unique before proceeding with the creation\n    of a new user record. If the username or email is already in use, an exception\n    is raised with the appropriate error details. A successful registration results\n    in the creation of a persisted user entity in the database. Passwords are\n    securely hashed before storage to ensure data protection.\n\n    :param user: An instance of EnUser containing the user's registration details,\n                 including username, email, and password.\n                 Type: EnUser\n    :param db: Dependency-injected database session to interact with the database.\n               Type: Session\n    :return: A response model indicating the success of the operation.\n             Returns a MessageResponse object on success.\n\n    :raises HTTPException:\n        - If the username is already in use (HTTP status 409).\n        - If the email is already in use (HTTP status 409).\n        - If user registration fails due to an unknown issue (HTTP status 404).\n    \"\"\"\n    # Test against same username\n    statement = select(EnUserDB).where(EnUserDB.username == user.username)\n    results = db.exec(statement).first()\n\n    if results is not None:\n        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=\"User already exists.\")\n        # return DataResponse(\n        #     data=None,\n        #     success=False,\n        #     errors=[ErrorModel(\n        #         code=status.HTTP_409_CONFLICT,\n        #         message=\"User already exists.\"\n        #     )]\n        # )\n\n    # Test against same mail\n    statement = select(EnUserDB).where(EnUserDB.mail == user.mail)\n    results = db.exec(statement).first()\n\n    if results is not None:\n        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=\"Mail already in use.\")\n        # return DataResponse(\n        #     data=None,\n        #     success=False,\n        #     errors=[ErrorModel(\n        #         code=status.HTTP_409_CONFLICT,\n        #         message=\"Mail already in use.\"\n        #     )]\n        # )\n\n    db_user = EnUserDB(**user.model_dump())\n    db_user.username = user.username.lower()\n    db_user.password = pbkdf2_sha256.hash(user.password)\n    db_user.date_joined = datetime.now()\n\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n\n    if db_user.id is not None:\n        return MessageResponse(\n            data=\"\",\n            success=True\n        )\n    else:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"User registration failed.\")\n</code></pre>"},{"location":"ensys/","title":"ensys","text":""},{"location":"ensys/#what-is-it","title":"What is it?","text":"<p>A python backend script to configure oemof-energysystems from a web interface via an api. The calculation of the energysystem is possible with an short python-script to build the real oemof-objects and calaculate the model at an high performance center.</p> <p>Bachlorthesis from Andreas Lubojanski at the University of Applied Science Nordhausen.</p> <p>Help for future docs: For full documentation visit mkdocs.org.</p>"},{"location":"ensys/#project-layout","title":"Project layout","text":"<p>The system is configured by a webinterface and these file is dumped to an binary file with all params. These file is given to an Modelbuilder (see Modelbuilder) and builds the oemof-objects with the given arguments. After this step the model is optimised and calculated.  All results are stored with the model in a given file.</p>"},{"location":"ensys/#ablauf-und-aufteilung","title":"Ablauf und Aufteilung","text":"<pre><code>sequenceDiagram\n  autonumber\n  Nutzer-&gt;&gt;Webinterface: Erzeugung der Struktur &lt;br&gt; Eingabe des Parametrisierung\n  Webinterface-&gt;&gt;Nutzer: Ensys-Energysystem als bin\u00e4re Datei\n  Nutzer-&gt;&gt;Rechenzentrum: HPC-Parameter &lt;br&gt; Ensys-Konfigurationsdatei\n  Rechenzentrum-&gt;&gt;Rechenzentrum: Erstellung, Optimierung und &lt;br&gt; Berechnung des Energysystem &lt;br&gt; aus der Konfigurationsdatei\n  Rechenzentrum-&gt;&gt;Nutzer: Information, die Daten bearbeitet wurden\n  Nutzer-&gt;&gt;Nutzer: Erstellung der Ausgabe &lt;br&gt; Plots, Datenslices etc.</code></pre>"},{"location":"ensys/release-notes/","title":"Release Notes","text":""},{"location":"ensys/release-notes/#release-notes","title":"Release Notes","text":""},{"location":"ensys/release-notes/#003-pre-release-beta","title":"0.03 Pre-Release (beta)","text":"<p>Added support to start the Software with an json or binary file which contains the configuration of the energysystem</p>"},{"location":"ensys/release-notes/#002-pre-release-beta","title":"0.02 Pre-Release (beta)","text":"<p>Implementation with pydantic support and all features for the \"Institut f\u00fcr Regenerative Energietechnik\".</p>"},{"location":"ensys/release-notes/#001-pre-release-alpha","title":"0.01 Pre-Release (alpha)","text":"<p>First implementatio.</p>"},{"location":"ensys/common/config/","title":"ConfigContainer","text":""},{"location":"ensys/common/config/#code","title":"Code","text":"config.py<pre><code>from pydantic import BaseModel\n\n\nclass EnsysConfigContainer(BaseModel):\n    def __init__(self):\n        super().__init__()\n\n    def to_oemof(self):\n        pass\n</code></pre>"},{"location":"ensys/common/config/#parentclass","title":"Parentclass","text":"<p>The Parent of the ConfigContainer is the \"BaseModel\" from the Package \"pydantic\". This decision was made because pydantic has a lot of built-in features to generate json-Object for the Webinterface.</p>"},{"location":"ensys/common/config/#functions","title":"Functions","text":""},{"location":"ensys/common/config/#to_oemofself","title":"to_oemof(self)","text":"<p>A object function for later use in child-classes, i.e. EnsysFlow, to implement a call to directly return an oemof.solph-Object.</p>"},{"location":"ensys/common/modelbuilder/","title":"Ensys Modelbuilder","text":""},{"location":"ensys/common/modelbuilder/#class","title":"Class","text":"<p>modelbuilder.py<pre><code>class ModelBuilder:\n    def __init__(self,\n                 ConfigFile,\n                 DumpFile,\n                 ):\n        \"\"\"Init Modelbuilder and if given load and optimise the configuration.\"\"\"\n        xf = open(ConfigFile, 'rb')\n        es = load(xf)\n        xf.close()\n\n        BuildEnergySystem(es, DumpFile)\n</code></pre> The modelbuilder loads the given configuration from the binary file at the initialisation of the object. After that the oemof-model is built and optimised, results are stored in the filepath which is also given.</p>"},{"location":"ensys/common/modelbuilder/#functions","title":"Functions","text":""},{"location":"ensys/common/modelbuilder/#buildenergysystemes-file-solvergurobi-solver_verbosefalse","title":"BuildEnergySystem(es, file, solver=\"gurobi\", solver_verbose=False)","text":"modelbuilder.py<pre><code>def BuildEnergySystem(es, file, solver=\"gurobi\", solver_verbose=False):\n    ##########################################################################\n    # Build an Energysystem from the config\n    ##########################################################################\n    logger.info(\"Build an Energysystem from config file.\")\n    filename = os.path.basename(file)\n    wdir = os.path.dirname(file)\n\n    oemof_es = solph.EnergySystem(\n        label=es.label,\n        timeindex=es.timeindex,\n        timeincrement=es.timeincrement\n    )\n\n    except_vars = [\"label\", \"timeindex\", \"timeincrement\"]\n    oemof_types = [solph.Bus, solph.GenericStorage, solph.Sink, solph.Source, solph.Transformer]\n\n    for attr in vars(es):\n        if attr not in except_vars:\n            logger.info(\"Build \" + attr)\n\n            arg_value = getattr(es, attr)\n\n            for value in arg_value:\n                if type(value) in oemof_types:\n                    oemof_es.add(arg_value)\n                else:\n                    kwargs = BuildOemofKwargs(value, oemof_es)\n\n                    if isinstance(value, EnsysBus):\n                        oemof_obj = solph.Bus(**kwargs)\n                    elif isinstance(value, EnsysSource):\n                        oemof_obj = solph.Source(**kwargs)\n                    elif isinstance(value, EnsysSink):\n                        oemof_obj = solph.Sink(**kwargs)\n                    elif isinstance(value, EnsysTransformer):\n                        oemof_obj = solph.Transformer(**kwargs)\n                    elif isinstance(value, EnsysStorage):\n                        oemof_obj = solph.GenericStorage(**kwargs)\n                    else:\n                        oemof_obj = None\n\n                    if oemof_obj is not None:\n                        oemof_es.add(oemof_obj)\n\n    logger.info(\"Building completed.\")\n\n    ##########################################################################\n    # Print the EnergySystem as Graph\n    ##########################################################################\n    filepath = \"images/energy_system\"\n    logger.info(\"Print energysystem as graph\")\n\n    ESGraphRenderer(energy_system=oemof_es, filepath=filepath)\n\n    ##########################################################################\n    # Initiate the energy system model\n    ##########################################################################\n    logger.info(\"Initiate the energy system model.\")\n    model = solph.Model(oemof_es)\n\n    logger.info(\"Solve the optimization problem.\")\n    t_start = time.time()\n    model.solve(solver=solver, solve_kwargs={\"tee\": solver_verbose})\n    t_end = time.time()\n\n    logger.info(\"Completed after \" + str(round(t_end - t_start, 2)) + \" seconds.\")\n\n    logger.info(\"Store the energy system with the results.\")\n\n    ##########################################################################\n    # The processing module of the outputlib can be used to extract the results\n    # from the model transfer them into a homogeneous structured dictionary.\n    ##########################################################################\n    oemof_es.results[\"main\"] = solph.processing.results(model)\n    oemof_es.results[\"meta\"] = solph.processing.meta_results(model)\n    oemof_es.results[\"verification\"] = solph.processing.create_dataframe(model)\n\n    logger.info(\"Dump file with results to: \" + os.path.join(wdir, filename))\n\n    oemof_es.dump(dpath=wdir, filename=filename)\n    logger.info(\"Fin.\")\n</code></pre>"},{"location":"ensys/common/modelbuilder/#buildoemofkwargsensys_obj-oemof_es-solphenergysystem","title":"BuildOemofKwargs(ensys_obj, oemof_es: solph.EnergySystem)","text":"modelbuilder.py<pre><code>def BuildOemofKwargs(ensys_obj, oemof_es: solph.EnergySystem):\n    \"\"\"Build a dict of arguments for the init of the oemof objects.\"\"\"\n    kwargs = {}\n    io_keys = [\"inputs\", \"outputs\", \"conversion_factors\"]\n\n    args = vars(ensys_obj)\n\n    for key in args:\n        value = args[key]\n        if value is not None:\n            if key in io_keys:\n                kwargs[key] = BuildIO(value, oemof_es)\n            elif key == \"nonconvex\":\n                if value is False or value is True:\n                    kwargs[key] = value\n                else:\n                    kwargs[key] = value.to_oemof()\n            elif key == \"investment\":\n                if isinstance(value, solph.Investment):\n                    kwargs[key] = value\n                else:\n                    kwargs[key] = value.to_oemof()\n            else:\n                kwargs[key] = value\n\n    return kwargs\n</code></pre>"},{"location":"ensys/common/modelbuilder/#buildioensys_io-es","title":"BuildIO(ensys_io, es)","text":"modelbuilder.py<pre><code>def BuildIO(ensys_io, es):\n    \"\"\"Build Input/Output-Dicts for oemof-Objects.\"\"\"\n    oemof_io = {}\n    keys = list(ensys_io.keys())\n\n    for key in keys:\n        for node in es.nodes:\n            if node.label == key:\n                bus = es.nodes[es.nodes.index(node)]\n                if isinstance(ensys_io[key], EnsysFlow):\n                    oemof_io[bus] = ensys_io[key].to_oemof()\n                else:\n                    oemof_io[bus] = ensys_io[key]\n\n    return oemof_io\n</code></pre>"},{"location":"ensys/common/modelbuilder/#searchnodenodeslist-nodename","title":"SearchNode(nodeslist, nodename)","text":"modelbuilder.py<pre><code>def SearchNode(nodeslist, nodename):\n    \"\"\"Search a specific node in  list and return this Node.\"\"\"\n    for node in nodeslist:\n        if node.label == nodename:\n            return nodeslist[nodeslist.index(node)]\n\n    return None\n</code></pre>"},{"location":"ensys/components/bus/","title":"EnsysBus Container","text":"<p>Configuration container for access the specific arguments from the webinterface. All parameters are changeable and depend on the specific component.</p>"},{"location":"ensys/components/bus/#sample-object-with-default-parameters","title":"Sample Object with default Parameters","text":"<pre><code>bel = EnsysBus(\n          label = \"electricity\",\n          balanced = True\n      )\n</code></pre>"},{"location":"ensys/components/bus/#parameter","title":"Parameter:","text":"<p>A list of alle parameters to configure the object with a short description.</p>"},{"location":"ensys/components/bus/#label","title":"Label","text":"<p>Specific Label of the Bus.</p> <p>Default: <pre><code>label: str = \"Default Bus\"   \n</code></pre></p>"},{"location":"ensys/components/bus/#balanced","title":"Balanced","text":"<p>If the bus is balanced the input equals the output in the simulation, this is the default value for every Bus.</p> <p>Default:</p> <pre><code>balanced: bool = True   \n</code></pre>"},{"location":"ensys/components/energysystem/","title":"EnsysEnergysystem Container","text":""},{"location":"ensys/components/energysystem/#sample-object-with-default-parameters","title":"Sample Object with default Parameters","text":"<pre><code>    es = EnsysEnergysystem(\n        label=\"ensys Energysystem\",\n        busses=[bel, bgas],\n        sinks=[excess_bel, demand_el],\n        sources=[import_el, rgas],\n        storages=[storage],\n        transformers=[pp_gas],\n        timeindex=date_time_index\n    )\n</code></pre>"},{"location":"ensys/components/energysystem/#parameters","title":"Parameters","text":""},{"location":"ensys/components/energysystem/#label","title":"Label","text":"<p>The label for this Energysystem, usually set for better recognition.</p> <pre><code>label: str = \"Default Energysystem\"\n</code></pre>"},{"location":"ensys/components/energysystem/#busses","title":"Busses","text":"<p>A List of EnsysConfigContainers for a Bus-Object, known as 'EnsysBus'.</p> <pre><code>busses: list[EnsysBus] = None\n</code></pre>"},{"location":"ensys/components/energysystem/#sinks","title":"Sinks","text":"<p>A List of EnsysConfigContainers for a Sink-Object, known as 'EnsysSink'.</p> <pre><code>sinks: list[EnsysSink] = None\n</code></pre>"},{"location":"ensys/components/energysystem/#sources","title":"Sources","text":"<p>A List of EnsysConfigContainers for a Source-Object, known as 'EnsysSource'.</p> <pre><code>sources: list[EnsysSource] = None\n</code></pre>"},{"location":"ensys/components/energysystem/#transformers","title":"Transformers","text":"<p>A List of EnsysConfigContainers for a Transformer-Object, known as 'EnsysTransformer'.</p> <pre><code>transformers: list[EnsysTransformer] = None\n</code></pre>"},{"location":"ensys/components/energysystem/#storages","title":"Storages","text":"<p>A List of EnsysConfigContainers for a Storage-Object, known as 'EnsysStorage'.</p> <pre><code>storages: list[EnsysStorage] = None\n</code></pre>"},{"location":"ensys/components/energysystem/#timeindex","title":"Timeindex","text":"<p>A pandas-datetimeindex object to set the timespan for the given data. This parameter must be set!</p>"},{"location":"ensys/components/energysystem/#timeincrement","title":"Timeincrement","text":"<p>Parameter to set to a given timeindex the increment step.</p>"},{"location":"ensys/components/flow/","title":"EnsysFlow Container","text":"<p>Configuration container for access the specific arguments from the webinterface. All parameters are changeable and depend on the specific component.</p>"},{"location":"ensys/components/flow/#sample-object-with-default-parameters","title":"Sample Object with Default Parameters","text":"<p>If min/max are set with all arguments. <pre><code>flow = EnsysFlow(\n            label = \"Sample Flow\",\n            nominal_value = 13000,\n            min = 0.0,\n            max = 1.0,\n            positive_gradient = None,\n            negative_gradient = None,\n            summed_max = None,\n            summed_min = None,\n            variable_costs = 0.01,\n            investment = None,\n            nonconvex = None,\n       )\n</code></pre></p> <p>If the parameter 'fix' is used, minimal arguments. <pre><code>flow = EnsysFlow(\n            nominal_value=1,\n            fix=data[\"demand_el\"]\n       )\n</code></pre></p>"},{"location":"ensys/components/flow/#parameters","title":"Parameters:","text":"<p>A list of alle parameters to configure the object with a short description.</p>"},{"location":"ensys/components/flow/#label","title":"Label","text":"<p>Specific Label of the Flow. This Parameter is not specific for these element, usually it is not set!  Default: <pre><code>label: str = \"Default Bus\"   \n</code></pre></p>"},{"location":"ensys/components/flow/#nominal-value","title":"Nominal Value","text":"<p>Default:</p> <pre><code>nominal_value: float = None   \n</code></pre>"},{"location":"ensys/components/flow/#fix","title":"Fix","text":"<p>Parameter to set a fix Datasource, i.e. a pandas series or a numeric value. This value must be 'None' if the following parameters, 'min' or 'max' are set!</p> <pre><code>fix = None   \n</code></pre>"},{"location":"ensys/components/flow/#min","title":"Min","text":"<p>Normed minimum value of the flow.  The flow absolute minimum will be calculated by multiplying 'nominal_value' with 'min'</p> <pre><code>min: float = 0.0   \n</code></pre>"},{"location":"ensys/components/flow/#max","title":"Max","text":"<p>Normed maximum value of the flow.  The flow absolute maximum will be calculated by multiplying 'nominal_value' with 'max'</p> <pre><code>max: float = 1.0   \n</code></pre>"},{"location":"ensys/components/flow/#positive-gradient","title":"Positive Gradient","text":"<p>A dictionary containing the following two keys:</p> <ul> <li> <p>ub:      The normed 'Upper Bound' on the positive value of two consecutive flow values.</p> </li> <li> <p>costs: Removed Key!</p> </li> </ul> <pre><code>positive_gradient: dict = None   \n</code></pre> <p>The parameter default value is set in die init-Function of the Object!</p>"},{"location":"ensys/components/flow/#negative-gradient","title":"Negative Gradient","text":"<p>A dictionary containing the following two keys:</p> <ul> <li> <p>ub:      The normed 'Upper Bound' on the negative value of two consecutive flow values.</p> </li> <li> <p>costs: Removed Key!</p> </li> </ul> <pre><code>negative_gradient: dict = None   \n</code></pre> <p>The parameter default value is set in die init-Function of the Object!</p>"},{"location":"ensys/components/flow/#summed-max","title":"Summed Max","text":"<p>Specific maximum value summed over all timesteps.  Will be multiplied with the 'nominal_value' to get the absolute limit. <pre><code>summed_max: float = None   \n</code></pre></p>"},{"location":"ensys/components/flow/#summed-min","title":"Summed Min","text":"<p>Specific minimum value summed over all timesteps.  Will be multiplied with the 'nominal_value' to get the absolute limit. <pre><code>summed_min: float = None   \n</code></pre></p>"},{"location":"ensys/components/flow/#variable-costs","title":"Variable Costs","text":"<p>The costs associated with one unit of the flow.  If this is set the costs will be added to the objective expression of the optimization problem.</p> <pre><code>variable_costs: float = None   \n</code></pre>"},{"location":"ensys/components/flow/#investment","title":"Investment","text":"<p>Object indicating if a 'nominal_value' of the flow is determined by the optimization problem. </p> <p>Note: This will refer all attributes to an investment variable instead of to the 'nominal_value'.  The 'nominal_value' should not be set (or set to None) if an investment object is used.</p> <pre><code>investment: EnsysInvestment = None   \n</code></pre>"},{"location":"ensys/components/flow/#non-convex","title":"Non Convex","text":"<p>If a nonconvex flow object is added here, the flow constraints will be altered significantly as the mathematical model for the flow will be different, i.e. constraint etc. from NonConvexFlow will be used instead of Flow.</p> <p>Note: at the moment this does not work if the investment attribute is set. If a NonConvex-Object is set, the Investment will be set to 'None' at the init-Function.</p> <pre><code>nonconvex: EnsysNonconvex = None   \n</code></pre>"},{"location":"ensys/components/investment/","title":"EnsysInvestment Container","text":"<p>Configuration container for access the specific arguments from the webinterface. All parameters are changeable and depend on the specific component.</p>"},{"location":"ensys/components/investment/#sample-object-with-default-parameters","title":"Sample Object with default Parameters","text":"<pre><code>epc_pp_gas = economics.annuity(capex=2000, n=20, wacc=0.05)\nlogger.info(\"epc_pp_gas: \" + str(epc_pp_gas))\n\npp_gas = EnsysTransformer(\n    label=\"pp_gas\",\n    inputs={bgas.label: EnsysFlow()},\n    outputs={bel.label: EnsysFlow(\n        variable_costs=0.1,\n        investment=EnsysInvestment(ep_costs=epc_pp_gas)\n    )},\n    conversion_factors={bel.label: 0.3}\n)\n</code></pre>"},{"location":"ensys/components/investment/#parameters","title":"Parameters:","text":"<p>A list of alle parameters to configure the object with a short description.</p>"},{"location":"ensys/components/investment/#maximum","title":"Maximum","text":"<p>Maximum of the addditional invested capacity</p> <p>Default: <pre><code>maximum:float = float(\"+inf\"),\n</code></pre></p>"},{"location":"ensys/components/investment/#minimum","title":"Minimum","text":"<p>Minimum of the additional invested capacity <pre><code>minimum: float = 0.0\n</code></pre></p>"},{"location":"ensys/components/investment/#ep_costs","title":"ep_costs","text":"<p>Equivalent perdiodical costs for the investment per flow capacity.</p> <p>Default: <pre><code>ep_costs: float = 0.0\n</code></pre></p>"},{"location":"ensys/components/investment/#existing","title":"Existing","text":"<p>Existing / installed capacity. The invested capacity is added on top of this value. Not applicable if nonconvex is set to True.</p> <p>Default: <pre><code>existing: float = 0.0\n</code></pre></p>"},{"location":"ensys/components/investment/#nonconvex","title":"Nonconvex","text":"<p>If True, a binary variable for the status of the investment is created.  This enables additional fix investment costs (offset) independent of the invested flow capacity. Therefore, use the offset parameter.</p> <p>Default: <pre><code>nonconvex: bool = False\n</code></pre></p>"},{"location":"ensys/components/investment/#offset","title":"Offset","text":"<p>Additional fix investment costs.  Only applicable if nonconvex is set to True. Default: <pre><code>offset: float = 0.0\n</code></pre></p>"},{"location":"ensys/components/nonconvex/","title":"EnsysNonConvex Container","text":"<p>Configuration container for access the specific arguments from the webinterface. All parameters are changeable and depend on the specific component.</p>"},{"location":"ensys/components/nonconvex/#sample-object-with-default-parameters","title":"Sample Object with default Parameters","text":"<pre><code>\"To be done!\"\n</code></pre>"},{"location":"ensys/components/nonconvex/#parameters","title":"Parameters:","text":"<p>A list of alle parameters to configure the object with a short description.</p>"},{"location":"ensys/components/nonconvex/#startup-costs","title":"Startup Costs","text":"<p>Costs associated with a start of the flow (representing a unit).</p> <p>Default: <pre><code>maximum:float = float(\"+inf\"),\n</code></pre></p>"},{"location":"ensys/components/nonconvex/#shutdown-costs","title":"Shutdown Costs","text":"<p>Costs associated with the shutdown of the flow (representing a unit). <pre><code>minimum: float = 0.0\n</code></pre></p>"},{"location":"ensys/components/nonconvex/#activity-costs","title":"Activity costs","text":"<p>Costs associated with the active operation of the flow, independently from the actual output.</p> <p>Default: <pre><code>activity_costs: float = None\n</code></pre></p>"},{"location":"ensys/components/nonconvex/#minimum-uptime","title":"Minimum Uptime","text":"<p>Minimum time that a flow must be greater then its minimum flow after startup. Be aware that minimum up and downtimes can contradict each other and may lead to infeasible problems.</p> <p>Default: <pre><code>minimum_uptime: int = 1\n</code></pre></p>"},{"location":"ensys/components/nonconvex/#minimum-downtime","title":"Minimum Downtime","text":"<p>Minimum time a flow is forced to zero after shutting down. Be aware that minimum up and downtimes can contradict each other and may to infeasible problems.</p> <p>Default: <pre><code>minimum_downtime: int = 1\n</code></pre></p>"},{"location":"ensys/components/nonconvex/#maximum-startups","title":"Maximum Startups","text":"<p>Maximum number of start-ups.</p> <p>Default: <pre><code>maximum_startups: int = 0\n</code></pre></p>"},{"location":"ensys/components/nonconvex/#maximum-shutdowns","title":"Maximum Shutdowns","text":"<p>Maximum number of shutdowns.</p> <p>Default: <pre><code>maximum_shutdowns: int = 0\n</code></pre></p>"},{"location":"ensys/components/nonconvex/#inital-status","title":"Inital Status","text":"<p>Integer value indicating the status of the flow in the first time step (0 = off, 1 = on).  For minimum up and downtimes, the initial status is set for the respective values in the edge regions e.g. if a minimum uptime of four timesteps is defined, the initial status is fixed for the four first and last timesteps of the optimization period.  If both, up and downtimes are defined, the initial status is set for the maximum of both e.g. for six timesteps if a minimum downtime of six timesteps is defined in addition to a four timestep minimum uptime.</p> <p>Default: <pre><code>initial_status: bool = False\n</code></pre></p> <p>Is set to '1' or '0' in the init-Function.</p>"},{"location":"ensys/components/nonconvex/#positive-gradient","title":"Positive Gradient","text":"<p>A dictionary containing the following two keys:</p> <ul> <li>'ub': numeric (iterable, scalar or None), the normed upper bound on the positive difference (flow[t-1] &lt; flow[t]) of two consecutive flow values.</li> <li>'costs': numeric (scalar or None), the gradient cost per unit.</li> </ul> <p>Default: <pre><code>positive_gradient: dict = None\n</code></pre></p>"},{"location":"ensys/components/nonconvex/#negative-gradient","title":"Negative Gradient","text":"<p>A dictionary containing the following two keys:</p> <ul> <li>'ub': numeric (iterable, scalar or None), the normed upper bound on the negative difference (flow[t-1] &gt; flow[t]) of two consecutive flow values.</li> <li>'costs': numeric (scalar or None), the gradient cost per unit.</li> </ul> <p>Default: <pre><code>negative_gradient: dict = None\n</code></pre></p>"},{"location":"ensys/components/sink/","title":"EnsysSink Container","text":"<p>Configuration container for access the specific arguments from the webinterface. All parameters are changeable and depend on the specific component.</p>"},{"location":"ensys/components/sink/#sample-object-with-default-parameters","title":"Sample Object with default Parameters","text":"<p>Common object for a demand of energy.</p> <pre><code>data = pd.DataFrame()\n\ndemand_el = EnsysSink(\n    label = \"demand\",\n    inputs = {\n        bel.label: EnsysFlow(\n            fix = data[\"demand_el\"],\n            nominal_value = 1\n    )}\n)\n</code></pre> <p>Common object for a sink for all excess energy. <pre><code>excess_bel = EnsysSink(\n    label = \"excess_bel\",\n    inputs = {bel.label: EnsysFlow(\n        balanced = False\n    )}\n)\n</code></pre></p>"},{"location":"ensys/components/sink/#parameters","title":"Parameters:","text":"<p>A list of alle parameters to configure the object with a short description.</p>"},{"location":"ensys/components/sink/#label","title":"Label","text":"<p>Specific Label of the Sink.</p> <p>Default: <pre><code>label: str = \"Default Sink\"   \n</code></pre></p>"},{"location":"ensys/components/sink/#inputs","title":"Inputs","text":"<p>A dictionary of various Flows, mostly one single flow from a Bus.</p> <p>The structure of the dictionary is given as <pre><code>    bus = EnsysBus(**kwargs)\n\n    dict = {bus.label: EnsysFlow(**kwargs)}\n</code></pre></p>"},{"location":"ensys/components/source/","title":"EnsysSource Container","text":"<p>Configuration container for access the specific arguments from the webinterface. All parameters are changeable and depend on the specific component.</p>"},{"location":"ensys/components/source/#sample-object-with-default-parameters","title":"Sample Object with default Parameters","text":"<p>Common object for an import of energy from somewhere, i.e. other facilities.</p> <pre><code>data = pd.DataFrame()\n\nimport_el = EnsysSource(\n    label = \"import\",\n    inputs = {\n        bel.label: EnsysFlow(\n            fix = data[\"import_el\"],\n            nominal_value = 1\n    )}\n)\n</code></pre>"},{"location":"ensys/components/source/#parameters","title":"Parameters:","text":"<p>A list of alle parameters to configure the object with a short description.</p>"},{"location":"ensys/components/source/#label","title":"Label","text":"<p>Specific Label of the Source.</p> <p>Default: <pre><code>label: str = \"Default Source\"   \n</code></pre></p>"},{"location":"ensys/components/source/#inputs","title":"Inputs","text":"<p>A dictionary of various Flows, mostly one single flow to a Bus.</p> <p>The structure of the dictionary is given as <pre><code>    bus = EnsysBus(**kwargs)\n\n    dict = {bus.label: EnsysFlow(**kwargs)}\n</code></pre></p>"},{"location":"ensys/components/storage/","title":"EnsysStorage Container","text":"<p>Configuration container for access the specific arguments from the webinterface. All parameters are changeable and depend on the specific component.</p>"},{"location":"ensys/components/storage/#sample-object-with-default-parameters","title":"Sample Object with default Parameters","text":"<pre><code>storage = EnsysStorage(\n    label=\"storage\",\n    #nominal_storage_capacity=10000,\n    inputs={\n        bel.label: EnsysFlow(\n            variable_costs=0.0001\n        )\n    },\n    outputs={\n        bel.label: EnsysFlow()\n    },\n    loss_rate=0.01,\n    initial_storage_level=None,\n    inflow_conversion_factor=1,\n    outflow_conversion_factor=0.8,\n    invest_relation_input_capacity=1 / 6,\n    invest_relation_output_capacity=1 / 6,\n    investment=EnsysInvestment(ep_costs=epc_storage),\n)\n</code></pre> <p>If you uncommment the 'nominal_storage_capacity' the Object is not effected by any optimisation of the investment-parameter.</p>"},{"location":"ensys/components/storage/#parameters","title":"Parameters:","text":"<p>A list of alle parameters to configure the object with a short description.</p>"},{"location":"ensys/components/storage/#inputs-outputs","title":"Inputs / Outputs","text":"<p>Flow in and Out the Storage</p> <p>Default: <pre><code> inputs: dict[EnsysFlow] = None\n outputs: dict[EnsysFlow] = None\n</code></pre></p>"},{"location":"ensys/components/storage/#nominal-storage-capacity","title":"Nominal Storage Capacity","text":"<p>Absolute nominal capacity of the storage.</p> <p>Default: <pre><code>nominal_storage_capacity=None\n</code></pre></p>"},{"location":"ensys/components/storage/#invest_relation_input_capacity","title":"invest_relation_input_capacity","text":"<p>Ratio between the investment variable of the input Flow and the investment variable of the storage.</p> <p>Default: <pre><code>invest_relation_input_capacity=None\n</code></pre></p>"},{"location":"ensys/components/storage/#invest_relation_output_capacity","title":"invest_relation_output_capacity","text":"<p>Ratio between the investment variable of the output Flow and the investment variable of the storage.</p> <p>Default: <pre><code>invest_relation_output_capacity=None\n</code></pre></p>"},{"location":"ensys/components/storage/#invest_relation_input_output","title":"invest_relation_input_output","text":"<p>Ratio between the investment variable of the output Flow and the investment variable of the input flow. This ratio used to fix the flow investments to each other.  Values &lt; 1 set the input flow lower than the output and &gt; 1 will set the input flow higher than the output flow.</p> <p>Default: <pre><code>invest_relation_input_output=None\n</code></pre></p>"},{"location":"ensys/components/storage/#initial_storage_level","title":"initial_storage_level","text":"<p>The relative storage content in the timestep before the first time step of optimization (between 0 and 1).</p> <p>Default: <pre><code>initial_storage_level=None\n</code></pre></p>"},{"location":"ensys/components/storage/#balanced","title":"balanced","text":"<p>Couple storage level of first and last time step. (Total inflow and total outflow are balanced.)</p> <p>Default: <pre><code>balanced=True\n</code></pre></p>"},{"location":"ensys/components/storage/#loss_rate","title":"loss_rate","text":"<p>The relative loss of the storage content per time unit.</p> <p>Default: <pre><code>loss_rate: float = 0.0\n</code></pre></p>"},{"location":"ensys/components/storage/#fixed_losses_relative","title":"fixed_losses_relative","text":"<p>Losses independent of state of charge between two consecutive timesteps relative to nominal storage capacity.</p> <p>Default: <pre><code>fixed_losses_relative: float = None\n</code></pre></p>"},{"location":"ensys/components/storage/#fixed_losses_absolute","title":"fixed_losses_absolute","text":"<p>Losses independent of state of charge and independent of nominal storage capacity between two consecutive timesteps.</p> <p>Default: <pre><code>fixed_losses_absolute: float = None\n</code></pre></p>"},{"location":"ensys/components/storage/#inflow_conversion_factor","title":"inflow_conversion_factor","text":"<p>The relative conversion factor, i.e. efficiency associated with the inflow of the storage.</p> <p>Default: <pre><code>inflow_conversion_factor: float = 1\n</code></pre></p>"},{"location":"ensys/components/storage/#outflow_conversion_factor","title":"outflow_conversion_factor","text":"<p>see: inflow_conversion_factor</p> <p>Default: <pre><code>outflow_conversion_factor: float = 1\n</code></pre></p>"},{"location":"ensys/components/storage/#min_storage_level","title":"min_storage_level","text":"<p>The normed minimum storage content as fraction of the nominal storage capacity (between 0 and 1). To set different values in every time step use a sequence.</p> <p>Default: <pre><code>min_storage_level: float = None\n</code></pre></p>"},{"location":"ensys/components/storage/#max_storage_level","title":"max_storage_level","text":"<p>see: min_storage_level</p> <p>Default: <pre><code>max_storage_level: float = None\n</code></pre></p>"},{"location":"ensys/components/storage/#investment","title":"investment","text":"<p>Object indicating if a nominal_value of the flow is determined by the optimization problem. </p> <p>Note: This will refer all attributes to an investment variable instead of to the nominal_storage_capacity.  The nominal_storage_capacity should not be set (or set to None) if an investment object is used.</p> <p>Default: <pre><code>investment: EnsysInvestment = None\n</code></pre></p>"},{"location":"ensys/components/transformer/","title":"EnsysTransformer Container","text":"<p>Configuration container for access the specific arguments from the webinterface. All parameters are changeable and depend on the specific component.</p>"},{"location":"ensys/components/transformer/#sample-object-with-default-parameters","title":"Sample Object with default Parameters","text":"<p>This is a simple Transformer from natural gas into electricity.</p> <pre><code>bel = EnsysBus(\n    label=\"electricity\"\n)\n\nbgas = EnsysBus(\n    label=\"natural_gas\"\n)\n\nbcoal = EnsysBus(\n    label=\"hard_coal\"\n)\n\nbheat = EnsysBus(\n    label=\"heat\"\n)\n\npp_gas = EnysTransformer(\n    label='pp_gas',\n    inputs={bgas.label: EnsysFlow(), bcoal.label: EnsysFlow()},\n    outputs={bel.label: EnsysFlow(), bheat.label: EnsysFlow()},\n    conversion_factors={bel: 0.3, bheat: 0.5,\n                        bgas: 0.8, bcoal: 0.2})\n</code></pre>"},{"location":"ensys/components/transformer/#parameters","title":"Parameters:","text":"<p>A list of alle parameters to configure the object with a short description.</p>"},{"location":"ensys/components/transformer/#label","title":"Label","text":"<p>Specific Label of the Transformer.</p> <p>Default: <pre><code>label: str = \"Default Transformer\"   \n</code></pre></p>"},{"location":"ensys/components/transformer/#inputs-and-outputs","title":"Inputs and Outputs","text":"<p>A dictionary of various Flows, mostly one single flow from a Bus.</p> <p>The structure of the dictionary is given as <pre><code>    bus = EnsysBus(**kwargs)\n\n    dict = {bus.label: EnsysFlow(**kwargs)}\n</code></pre></p>"},{"location":"ensys/components/transformer/#conversion-factors","title":"Conversion Factors","text":"<p>Dictionary containing conversion factors for conversion of each flow.  Keys are the connected bus objects.  The dictionary values can either be a scalar or an iterable with length of time horizon for simulation.</p>"},{"location":"frontend/dev/","title":"Home","text":""},{"location":"frontend/dev/#dev-document","title":"Dev Document","text":""}]}