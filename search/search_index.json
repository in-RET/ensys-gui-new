{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>Warning</p> <p>This is the prototype documentation!</p> <p>Tip</p> <p>If you find some bugs don't hesitate to mail at Hochschule Nordhausen</p> <p></p>"},{"location":"#developed-and-maintained-by","title":"Developed and maintained by","text":""},{"location":"#contact","title":"Contact","text":"<p>Tip</p> <p>Using mail is the best way to get in contact.</p> <p>Thank you!</p> <p>Hochschule Nordhausen Institut f\u00fcr regenerative Energietechnik Weinberghof 4 99734 Nordhausen ensys@hs-nordhausen.de ensys.hs-nordhausen.de</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#software","title":"Software","text":"<p>to be done.</p>"},{"location":"about/#team","title":"Team","text":"<p>See Institut f\u00fcr Regnerative Energietechnik</p>"},{"location":"about/#oemofsolph","title":"oemof.solph","text":"<p>See oemof-Website.</p>"},{"location":"getting_started/","title":"Getting Started","text":""},{"location":"getting_started/#requirements","title":"Requirements","text":"<ul> <li>python3.11</li> <li>docker</li> </ul>"},{"location":"getting_started/#getting-started","title":"Getting started","text":"<ol> <li>Create an .env file like given below     <pre><code># postgres settings\nPOSTGRES_DB=ensys\nPOSTGRES_USER=ensys_pg\nPOSTGRES_PASSWORD=ensys_pg\nPOSTGRES_HOST=db\nPOSTGRES_PORT=5432\nDATABASE_URL=postgresql://$POSTGRES_USER:$POSTGRES_PASSWORD@$POSTGRES_HOST:$POSTGRES_PORT/$POSTGRES_DB\n\n# pgadmin settings\nPGADMIN_DEFAULT_EMAIL=&lt;pdadmin-login-mail&gt;\nPGADMIN_DEFAULT_PASSWORD=&lt;pgadmin-login-password&gt;\n\n# e-mail settings\nEMAIL_SENDER=&lt;mail-address&gt;\nEMAIL_HOST_IP=&lt;mail-host&gt;\nEMAIL_HOST_USER=&lt;mail-username&gt;\nEMAIL_HOST_PASSWORD=&lt;mail-password&gt;\n\n# api settings\nOS_VERSION=&lt;os-version (armlinux64 or amd64)&gt;\nLOCAL_WORKDIR=&lt;path-to-the-local-workdir (for example the root dir)&gt;\nLOCAL_DATADIR=&lt;path-to-the-storage-dir&gt;\nHOST_DATADIR=&lt;absolute-path-to-the-storage-dir&gt;\nGUROBI_LICENSE_FILE_PATH=&lt;absolute-path-to-the-gurobi-license-file&gt;\n\nSECRET_TOKEN=&lt;secret-token-string&gt;\n\n# oep\nOEP_TOKEN=&lt;oep-token-string&gt;\nOEP_TOPIC=sandbox\n\n# port settings\nWEB_PORT=9003\nPROXY_PORT=9004\nPGADMIN_PORT=9005\nAPI_PORT=9006\nREDIS_PORT=9007\nFLOWER_PORT=9008\n</code></pre></li> <li> <p>Start the docker-compose project     <pre><code>docker compose build -f docker-compose.dev.yaml up --build #for Development\ndocker compose build -f docker-compose.prod.yaml up --build #for production\n</code></pre></p> </li> <li> <p>Now you can access the various tools via a browser</p> <p>Note</p> <p>Links are only for local deployment</p> <ul> <li>Frontend</li> <li>Backend<ul> <li>Documentation:</li> <li>Swagger UI</li> <li>ReDocs</li> <li>pgAdmin</li> <li>flower</li> </ul> </li> </ul> </li> </ol>"},{"location":"possibilities/","title":"Developer Doc Help","text":"<p>Note</p> <p>Dient der Veranschaulichung ausgew\u00e4hlter M\u00f6glichkeiten</p> <p>Tip</p> <p>Weitere Informationen in folgenden Dokumenationen</p> <ul> <li>mkDocs</li> <li>mkDocs-Material</li> </ul>"},{"location":"possibilities/#heading","title":"Heading","text":"<p>Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. </p>"},{"location":"possibilities/#subsubheading","title":"Subsubheading","text":"<p>Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat. Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi.   </p>"},{"location":"possibilities/#subheading","title":"Subheading","text":"<p>Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis.   </p>"},{"location":"possibilities/#code-and-latex","title":"Code and LaTeX","text":"<pre><code>print(\"hallo welt\")\n\nx: str = \"dingsda\"\n\nif x == \"dingsda\":\n    print(\"Motor aus\")\nelif x == \"ninja\":\n    print(\"Motor an\")\nelse:\n    print(\"Motor m\u00fcde, Motor schlafen\")\n\nreturn xyz\n</code></pre> <p>Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.   </p> \\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\] <p>Nam liber tempor cum soluta nobis eleifend option congue nihil imperdiet doming id quod mazim placerat facer possim assum. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.   </p> <pre><code>$$\n\\sum^5_{i=1} x \\cdot y_i = e^x\n$$\n</code></pre> \\[ \\sum^5_{i=1} x \\cdot y_i = e^x \\] <p>Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.   </p>"},{"location":"possibilities/#mermaid","title":"Mermaid","text":""},{"location":"possibilities/#pap","title":"PAP","text":"<pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre>"},{"location":"possibilities/#sqeuence-diagram","title":"Sqeuence Diagram","text":"<pre><code>sequenceDiagram\n  autonumber\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n      John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!</code></pre>"},{"location":"possibilities/#tabs","title":"Tabs","text":"CC++ <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n  printf(\"Hello world!\\n\");\n  return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nint main(void) {\n  std::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>"},{"location":"possibilities/#lists-and-task-lists","title":"Lists and Task Lists","text":""},{"location":"possibilities/#lists","title":"Lists","text":"<ol> <li> <p>Vivamus id mi enim. Integer id turpis sapien. Ut condimentum lobortis     sagittis. Aliquam purus tellus, faucibus eget urna at, iaculis venenatis     nulla. Vivamus a pharetra leo.</p> <ol> <li> <p>Vivamus venenatis porttitor tortor sit amet rutrum. Pellentesque aliquet     quam enim, eu volutpat urna rutrum a. Nam vehicula nunc mauris, a     ultricies libero efficitur sed.</p> </li> <li> <p>Morbi eget dapibus felis. Vivamus venenatis porttitor tortor sit amet     rutrum. Pellentesque aliquet quam enim, eu volutpat urna rutrum a.</p> <ol> <li>Mauris dictum mi lacus</li> <li>Ut sit amet placerat ante</li> <li>Suspendisse ac eros arcu</li> </ol> </li> </ol> </li> </ol>"},{"location":"possibilities/#task-lists","title":"Task lists","text":"<ul> <li> Lorem ipsum dolor sit amet, consectetur adipiscing elit</li> <li> Vestibulum convallis sit amet nisi a tincidunt<ul> <li> In hac habitasse platea dictumst</li> <li> In scelerisque nibh non dolor mollis congue sed et metus</li> <li> Praesent sed risus massa</li> </ul> </li> <li> Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque</li> </ul>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#001-pre-release-alpha","title":"0.01 Pre-Release (alpha)","text":""},{"location":"backend/","title":"Backend","text":"<p>All information for the backend documentation can be found in the FastAPI web interface.</p> <p>Info</p> <p>Links are given for local deployment</p> <p>Therefore you should go to:</p> <ul> <li>Swagger UI (/docs)</li> <li>Redoc Documentation /redoc</li> </ul>"},{"location":"backend/api/celery/","title":"celery","text":""},{"location":"backend/api/celery/#app.celery.simulation_task","title":"<code>simulation_task(scenario_id, simulation_id)</code>","text":"<p>Perform simulation task including data preparation, energy system creation, optimization, and result processing.</p> <p>This function is a Celery task that interacts with a database to fetch simulation and scenario data. It creates an energy system model, optimizes using the oemof library, processes the results, and updates the database with the results of the simulation.</p> <p>Detailed actions performed by the function include: - Fetching scenario and simulation details from the database. - Preparing necessary directory structures and dumping input data. - Configuring and initializing the oemof energy system. - Solving an optimization model using specified solver parameters. - Writing optimization results to files for further analysis. - Updating the status of the simulation task in the database.</p> <p>Parameters:</p> Name Type Description Default <code>scenario_id</code> <code>int</code> <p>Identifier of the scenario to be simulated.</p> required <code>simulation_id</code> <code>int</code> <p>Identifier of the simulation instance.</p> required <p>Returns:</p> Type Description <code>NoneType</code> <p>None</p> Source code in <code>backend/app/celery.py</code> <pre><code>@celery_app.task(name=\"ensys.optimization\")\ndef simulation_task(scenario_id: int, simulation_id: int):\n    \"\"\"\n    Perform simulation task including data preparation, energy system creation, optimization,\n    and result processing.\n\n    This function is a Celery task that interacts with a database to fetch simulation and\n    scenario data. It creates an energy system model, optimizes using the oemof library,\n    processes the results, and updates the database with the results of the simulation.\n\n    Detailed actions performed by the function include:\n    - Fetching scenario and simulation details from the database.\n    - Preparing necessary directory structures and dumping input data.\n    - Configuring and initializing the oemof energy system.\n    - Solving an optimization model using specified solver parameters.\n    - Writing optimization results to files for further analysis.\n    - Updating the status of the simulation task in the database.\n\n    :param scenario_id: Identifier of the scenario to be simulated.\n    :type scenario_id: int\n    :param simulation_id: Identifier of the simulation instance.\n    :type simulation_id: int\n\n    :return: None\n    :rtype: NoneType\n    \"\"\"\n    task_counter.inc()\n    task_in_progress.inc()\n\n    db = Session(create_engine(os.getenv(\"DATABASE_URL\")))\n    scenario = db.get(EnScenarioDB, scenario_id)\n    simulation = db.get(EnSimulationDB, simulation_id)\n    simulation_token = simulation.sim_token\n\n    dump_path = os.path.join(os.getenv(\"LOCAL_DATADIR\"), simulation_token, \"dump\")\n    log_path = os.path.join(os.getenv(\"LOCAL_DATADIR\"), simulation_token, \"log\")\n    os.makedirs(dump_path, exist_ok=True)\n    os.makedirs(log_path, exist_ok=True)\n\n    logger = get_task_logger(__name__)\n\n    # Create Energysystem to be stored\n    simulation_model = EnModel(\n        energysystem=scenario.energysystem\n    )\n\n    simulation_folder = os.path.abspath(os.path.join(os.getenv(\"LOCAL_DATADIR\"), simulation_token))\n    os.makedirs(\n        name=simulation_folder,\n        exist_ok=True\n    )\n\n    with open(os.path.join(simulation_folder, \"es_\" + simulation_token + \".json\"), \"wt\") as f:\n        f.write(simulation_model.model_dump_json())\n\n    logger.info(\"read scenario data from database\")\n    scenario = db.exec(select(EnScenarioDB).where(EnScenarioDB.id == scenario_id)).first()\n\n    print(f\"Scenario Interval:{scenario.interval}\")\n    print(f\"Scenario Timesteps:{scenario.time_steps}\")\n    print(f\"Scenario Startdate:{scenario.start_date}\")\n    print(f\"Scenario Startdate:{type(scenario.start_date)}\")\n    print(f\"Scenario Startdate:{scenario.start_date.year}\")\n\n    logger.info(\"create oemof energy system\")\n    timeindex = solph.create_time_index(\n        start=scenario.start_date,\n        number=scenario.time_steps,\n        interval=scenario.interval,\n    )\n\n    print(f\"timeindex:{timeindex}\")\n    oemof_es: solph.EnergySystem = solph.EnergySystem(\n        timeindex=timeindex,\n        infer_last_interval=False\n    )\n\n    oemof_es = simulation_model.energysystem.to_oemof(oemof_es)\n\n    # create the model for optimization\n    logger.info(\"create simulation model\")\n    oemof_model = solph.Model(oemof_es)\n\n    # solve the optimization model\n    logger.info(\"solve optimization model\")\n    oemof_model.solve(\n        solver=str(simulation_model.solver.value),\n        solve_kwargs=simulation_model.solver_kwargs if hasattr(simulation_model, \"solver_kwargs\") else {\"tee\": True},\n        cmdline_opts={\"logfile\": os.path.join(log_path, \"solver.log\")}\n    )\n\n    logger.info(\"simulation finished\")\n    # write the lp file for specific analysis\n    logger.info(\"write lp file\")\n    oemof_model.write(\n        filename=os.path.join(dump_path, \"oemof_model.lp\"),\n        io_options={\"symbolic_solver_labels\": True}\n    )\n\n    logger.info(\"collect results\")\n    oemof_es.results[\"main\"] = solph.processing.results(oemof_model)\n    oemof_es.results[\"meta\"] = solph.processing.meta_results(oemof_model)\n\n    logger.info(\"dump results\")\n    oemof_es.dump(\n        dpath=dump_path,\n        filename=\"oemof_es.dump\"\n    )\n\n    logger.info(\"update database\")\n    simulation.status = Status.FINISHED.value\n    simulation.end_date = datetime.now()\n    db.commit()\n    db.refresh(simulation)\n    logger.info(\"backgroundtask finished\")\n\n    task_in_progress.dec()\n</code></pre>"},{"location":"backend/api/db/","title":"db","text":""},{"location":"backend/api/db/#app.db.get_db_session","title":"<code>get_db_session()</code>","text":"<p>Creates and provides a database session.</p> <p>This function is designed to yield a database session for interacting with the database. The session is created using the given database engine and is managed within a context to ensure proper cleanup after usage.</p> <p>Returns:</p> Type Description <code>Session</code> <p>Yields database session objects.</p> Source code in <code>backend/app/db.py</code> <pre><code>def get_db_session():\n    \"\"\"\n    Creates and provides a database session.\n\n    This function is designed to yield a database session for interacting with the\n    database. The session is created using the given database engine and is\n    managed within a context to ensure proper cleanup after usage.\n\n    :return: Yields database session objects.\n    :rtype: Session\n    \"\"\"\n    with Session(db_engine) as session:\n        yield session\n</code></pre>"},{"location":"backend/api/logger/","title":"logger","text":""},{"location":"backend/api/logger/#app.logger.EnsysLogger","title":"<code>EnsysLogger</code>","text":"<p>Handles creation and management of a logger instance with specific configurations.</p> <p>The <code>EnsysLogger</code> class provides functionality to create a logger instance tied to a specific name, logging level, and a file to store log outputs. Logs are formatted to include a timestamp and message, ensuring traceability and readability in UTF-8 encoded files. This class supports logging at various severity levels including debug, info, warning, error, and critical.</p> <p>Attributes:</p> Name Type Description <code>logger</code> <p>Internal logger instance used to handle logging messages.</p> Source code in <code>backend/app/logger.py</code> <pre><code>class EnsysLogger:\n    \"\"\"\n    Handles creation and management of a logger instance with specific configurations.\n\n    The `EnsysLogger` class provides functionality to create a logger instance tied to\n    a specific name, logging level, and a file to store log outputs. Logs are formatted\n    to include a timestamp and message, ensuring traceability and readability in UTF-8\n    encoded files. This class supports logging at various severity levels including debug,\n    info, warning, error, and critical.\n\n    :ivar logger: Internal logger instance used to handle logging messages.\n    :type logger: logging.Logger\n    \"\"\"\n    logger = None\n\n    def __init__(self, name, filename, level=logging.INFO):\n        \"\"\"\n        Initializes a logger instance with a given configuration. The logger is associated\n        with a specific name, writes logs to a specified file, and operates at the defined\n        logging level. The logging messages are encoded in UTF-8 format and include a\n        timestamp followed by the log message.\n\n        :param name: The name associated with the logger instance.\n        :type name: str\n        :param filename: The name of the file where logs will be written.\n        :type filename: str\n        :param level: The logging level for the logger. Defaults to logging.INFO.\n        :type level: int, optional\n        \"\"\"\n        logging.basicConfig(\n            filename=filename,\n            format='%(asctime)s %(message)s',\n            filemode='w',\n            level=level,\n            encoding='utf-8'\n        )\n\n        self.logger = logging.getLogger(name)\n\n    def debug(self, msg):\n        \"\"\"\n        Logs a debug message prefixed with the custom identifier \"[----D]\"\n\n        :param msg: The message to be logged.\n        :type msg: str\n        :return: None\n        \"\"\"\n        self.logger.debug(msg=f\"[----D] {msg}\")\n\n    def info(self, msg):\n        \"\"\"\n        Logs an informational message prefixed with the custom identifier \"[---I-]\"\n\n        :param msg: The message to log.\n        :type msg: str\n        :return: None\n        \"\"\"\n        self.logger.info(msg=f\"[---I-] {msg}\")\n\n    def warn(self, msg):\n        \"\"\"\n        Logs a warning message prefixed with the custom identifier \"[--W--]\".\n\n        :param msg: The message to be logged as a warning.\n        :type msg: str\n        :return: None\n        \"\"\"\n        self.logger.warning(msg=f\"[--W--] {msg}\")\n\n    def error(self, msg):\n        \"\"\"\n        Logs an error message prefixed with the custom identifier \"[-E---]\".\n\n        :param msg: The message string to be logged.\n        :type msg: str\n        :return: None\n        \"\"\"\n        self.logger.error(msg=f\"[-E---] {msg}\")\n\n    def critical(self, msg):\n        \"\"\"\n        Logs a critical severity message prefixed with the custom identifier \"[C----]\"\n\n        :param msg: The message to log. It provides the content describing the\n            critical issue or context.\n        :type msg: str\n\n        :return: None\n        \"\"\"\n        self.logger.critical(msg=f\"[C----]  {msg}\")\n</code></pre>"},{"location":"backend/api/logger/#app.logger.EnsysLogger.__init__","title":"<code>__init__(name, filename, level=logging.INFO)</code>","text":"<p>Initializes a logger instance with a given configuration. The logger is associated with a specific name, writes logs to a specified file, and operates at the defined logging level. The logging messages are encoded in UTF-8 format and include a timestamp followed by the log message.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name associated with the logger instance.</p> required <code>filename</code> <code>str</code> <p>The name of the file where logs will be written.</p> required <code>level</code> <code>(int, optional)</code> <p>The logging level for the logger. Defaults to logging.INFO.</p> <code>INFO</code> Source code in <code>backend/app/logger.py</code> <pre><code>def __init__(self, name, filename, level=logging.INFO):\n    \"\"\"\n    Initializes a logger instance with a given configuration. The logger is associated\n    with a specific name, writes logs to a specified file, and operates at the defined\n    logging level. The logging messages are encoded in UTF-8 format and include a\n    timestamp followed by the log message.\n\n    :param name: The name associated with the logger instance.\n    :type name: str\n    :param filename: The name of the file where logs will be written.\n    :type filename: str\n    :param level: The logging level for the logger. Defaults to logging.INFO.\n    :type level: int, optional\n    \"\"\"\n    logging.basicConfig(\n        filename=filename,\n        format='%(asctime)s %(message)s',\n        filemode='w',\n        level=level,\n        encoding='utf-8'\n    )\n\n    self.logger = logging.getLogger(name)\n</code></pre>"},{"location":"backend/api/logger/#app.logger.EnsysLogger.critical","title":"<code>critical(msg)</code>","text":"<p>Logs a critical severity message prefixed with the custom identifier \"[C----]\"</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to log. It provides the content describing the critical issue or context.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>backend/app/logger.py</code> <pre><code>def critical(self, msg):\n    \"\"\"\n    Logs a critical severity message prefixed with the custom identifier \"[C----]\"\n\n    :param msg: The message to log. It provides the content describing the\n        critical issue or context.\n    :type msg: str\n\n    :return: None\n    \"\"\"\n    self.logger.critical(msg=f\"[C----]  {msg}\")\n</code></pre>"},{"location":"backend/api/logger/#app.logger.EnsysLogger.debug","title":"<code>debug(msg)</code>","text":"<p>Logs a debug message prefixed with the custom identifier \"[----D]\"</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to be logged.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>backend/app/logger.py</code> <pre><code>def debug(self, msg):\n    \"\"\"\n    Logs a debug message prefixed with the custom identifier \"[----D]\"\n\n    :param msg: The message to be logged.\n    :type msg: str\n    :return: None\n    \"\"\"\n    self.logger.debug(msg=f\"[----D] {msg}\")\n</code></pre>"},{"location":"backend/api/logger/#app.logger.EnsysLogger.error","title":"<code>error(msg)</code>","text":"<p>Logs an error message prefixed with the custom identifier \"[-E---]\".</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message string to be logged.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>backend/app/logger.py</code> <pre><code>def error(self, msg):\n    \"\"\"\n    Logs an error message prefixed with the custom identifier \"[-E---]\".\n\n    :param msg: The message string to be logged.\n    :type msg: str\n    :return: None\n    \"\"\"\n    self.logger.error(msg=f\"[-E---] {msg}\")\n</code></pre>"},{"location":"backend/api/logger/#app.logger.EnsysLogger.info","title":"<code>info(msg)</code>","text":"<p>Logs an informational message prefixed with the custom identifier \"[---I-]\"</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to log.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>backend/app/logger.py</code> <pre><code>def info(self, msg):\n    \"\"\"\n    Logs an informational message prefixed with the custom identifier \"[---I-]\"\n\n    :param msg: The message to log.\n    :type msg: str\n    :return: None\n    \"\"\"\n    self.logger.info(msg=f\"[---I-] {msg}\")\n</code></pre>"},{"location":"backend/api/logger/#app.logger.EnsysLogger.warn","title":"<code>warn(msg)</code>","text":"<p>Logs a warning message prefixed with the custom identifier \"[--W--]\".</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>str</code> <p>The message to be logged as a warning.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>backend/app/logger.py</code> <pre><code>def warn(self, msg):\n    \"\"\"\n    Logs a warning message prefixed with the custom identifier \"[--W--]\".\n\n    :param msg: The message to be logged as a warning.\n    :type msg: str\n    :return: None\n    \"\"\"\n    self.logger.warning(msg=f\"[--W--] {msg}\")\n</code></pre>"},{"location":"backend/api/main/","title":"main","text":""},{"location":"backend/api/main/#app.main.lifespan","title":"<code>lifespan(fastapi_app)</code>  <code>async</code>","text":"<p>Manages the lifespan of a FastAPI application, handling setup during startup and cleanup during shutdown.</p> <p>This function is meant to be used as an async context manager for setting up and tearing down application-wide resources or configurations in a uniform way.</p> <p>Parameters:</p> Name Type Description Default <code>fastapi_app</code> <code>FastAPI</code> <p>Instance of the FastAPI application</p> required <p>Returns:</p> Type Description <code>AsyncIterator[None]</code> <p>Async context for managing the lifespan of the FastAPI application</p> Source code in <code>backend/app/main.py</code> <pre><code>@asynccontextmanager\nasync def lifespan(fastapi_app: FastAPI):\n    \"\"\"\n    Manages the lifespan of a FastAPI application, handling setup during startup and cleanup\n    during shutdown.\n\n    This function is meant to be used as an async context manager for setting up and tearing\n    down application-wide resources or configurations in a uniform way.\n\n    :param fastapi_app: Instance of the FastAPI application\n    :type fastapi_app: FastAPI\n    :return: Async context for managing the lifespan of the FastAPI application\n    :rtype: AsyncIterator[None]\n    \"\"\"\n    # startup event\n    yield\n</code></pre>"},{"location":"backend/api/main/#app.main.root","title":"<code>root()</code>  <code>async</code>","text":"<p>Handles the root endpoint of the FastAPI application, which responds with an HTML page providing a welcome message and links to documentation.</p> <p>Provides a simple HTML-based response notifying users about the available documentation resources. The background and content are customized with inline CSS styling for user visual experience.</p> <p>Returns:</p> Type Description <code>HTMLResponse</code> <p>HTMLResponse containing the welcome page content and HTTP status code 200.</p> Source code in <code>backend/app/main.py</code> <pre><code>@fastapi_app.get(\"/\", response_class=HTMLResponse)\nasync def root():\n    \"\"\"\n    Handles the root endpoint of the FastAPI application, which responds with an HTML page\n    providing a welcome message and links to documentation.\n\n    Provides a simple HTML-based response notifying users about the available documentation\n    resources. The background and content are customized with inline CSS styling for user\n    visual experience.\n\n    :return: HTMLResponse containing the welcome page content and HTTP status code 200.\n    :rtype: HTMLResponse\n    \"\"\"\n    html_content = \"\"\"\n    &lt;html&gt;\n        &lt;head&gt;\n            &lt;title&gt;EnSys FastAPI&lt;/title&gt;\n        &lt;/head&gt;\n        &lt;body style=\"background-color:#dcdcde; margin: auto; width: 75vh; height: 75%; display: flex; justify-content: center; align-items: center;\"&gt;\n        &lt;div style=\"background-color:#fcf9e8; width:100%; text-align: center; font-family: monospace; padding: 15px\"&gt;\n            &lt;h1&gt;Welcome&lt;/h1&gt;\n            &lt;p&gt;For documentation see '/docs', '/redoc' or &lt;a target=\"_blank\" href=\"https://in-ret.github.io/ensys-gui-new/\"&gt;this link&lt;/a&gt;.&lt;p&gt;\n        &lt;/div&gt;\n        &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n\n    return HTMLResponse(\n        content=html_content,\n        status_code=status.HTTP_200_OK\n    )\n</code></pre>"},{"location":"backend/api/responses/","title":"responses","text":""},{"location":"backend/api/responses/#app.responses.DataResponse","title":"<code>DataResponse</code>","text":"<p>               Bases: <code>GeneralResponse</code></p> <p>Represents a response containing general data, inheriting from the GeneralResponse.</p> <p>This class is used for defining a response structure that includes the general data model. It enforces the inclusion of the general data field, ensuring proper structure and expected data handling as part of the response. It can be extended or utilized wherever a general data response entity is required.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>GeneralDataModel</code> <p>The general data model that represents the main content of the response.</p> Source code in <code>backend/app/responses.py</code> <pre><code>class DataResponse(GeneralResponse):\n    \"\"\"\n    Represents a response containing general data, inheriting from the\n    GeneralResponse.\n\n    This class is used for defining a response structure that includes the\n    general data model. It enforces the inclusion of the general data field,\n    ensuring proper structure and expected data handling as part of the response.\n    It can be extended or utilized wherever a general data response entity\n    is required.\n\n    :ivar data: The general data model that represents the main content of\n                the response.\n    :type data: GeneralDataModel\n    \"\"\"\n    data: GeneralDataModel = Field(...)\n</code></pre>"},{"location":"backend/api/responses/#app.responses.ErrorResponse","title":"<code>ErrorResponse</code>","text":"<p>               Bases: <code>GeneralResponse</code></p> <p>Represents an error response detailing the result of a failed operation.</p> <p>This class extends the GeneralResponse and is intended to provide a standard structure for reporting errors or unsuccessful operations in the application. It includes attributes that indicate the success status and any data related to the error response.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>None</code> <p>Data returned by the request. Default is None.</p> <code>success</code> <code>bool</code> <p>Indicates whether the request was successful or not. Default is False.</p> Source code in <code>backend/app/responses.py</code> <pre><code>class ErrorResponse(GeneralResponse):\n    \"\"\"\n    Represents an error response detailing the result of a failed operation.\n\n    This class extends the GeneralResponse and is intended to provide a standard\n    structure for reporting errors or unsuccessful operations in the application.\n    It includes attributes that indicate the success status and any data related\n    to the error response.\n\n    :ivar data: Data returned by the request. Default is None.\n    :type data: None\n    :ivar success: Indicates whether the request was successful or not. Default is False.\n    :type success: bool\n    \"\"\"\n    data: None = Field(\n        default=None,\n        description=\"Data returned by the request.\"\n    )\n    success: bool = Field(\n        default=False,\n        description=\"Indicates whether the request was successful or not.\"\n    )\n</code></pre>"},{"location":"backend/api/responses/#app.responses.GeneralResponse","title":"<code>GeneralResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the general response structure for API requests.</p> <p>This class encapsulates the standard response format, including the data returned, success status, and any errors that occurred during the request. It is utilized as the base model for structuring API responses.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>None</code> <p>Data returned by the request.</p> <code>success</code> <code>bool</code> <p>Indicates whether the request was successful or not.</p> <code>errors</code> <code>list[ErrorModel] | None</code> <p>List of errors encountered during the request.</p> Source code in <code>backend/app/responses.py</code> <pre><code>class GeneralResponse(BaseModel):\n    \"\"\"\n    Represents the general response structure for API requests.\n\n    This class encapsulates the standard response format, including the data\n    returned, success status, and any errors that occurred during the request.\n    It is utilized as the base model for structuring API responses.\n\n    :ivar data: Data returned by the request.\n    :type data: None\n    :ivar success: Indicates whether the request was successful or not.\n    :type success: bool\n    :ivar errors: List of errors encountered during the request.\n    :type errors: list[ErrorModel] | None\n    \"\"\"\n    data: None = Field(\n        default=None,\n        description=\"Data returned by the request.\"\n    )\n    success: bool = Field(\n        default=True,\n        description=\"Indicates whether the request was successful or not.\"\n    )\n    errors: list[ErrorModel] | None = Field(\n        default=None,\n        description=\"List of errors encountered during the request.\"\n    )\n</code></pre>"},{"location":"backend/api/responses/#app.responses.MessageResponse","title":"<code>MessageResponse</code>","text":"<p>               Bases: <code>GeneralResponse</code></p> <p>Represents a response message inheriting properties from <code>GeneralResponse</code>.</p> <p>This class is used to handle message responses with associated data and extends the general response functionality by including a specific 'data' attribute.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>str</code> <p>The content of the response message.</p> Source code in <code>backend/app/responses.py</code> <pre><code>class MessageResponse(GeneralResponse):\n    \"\"\"\n    Represents a response message inheriting properties from `GeneralResponse`.\n\n    This class is used to handle message responses with associated data and extends\n    the general response functionality by including a specific 'data' attribute.\n\n    :ivar data: The content of the response message.\n    :type data: str\n    \"\"\"\n    data: str = Field(...)\n</code></pre>"},{"location":"backend/api/responses/#app.responses.ResultResponse","title":"<code>ResultResponse</code>","text":"<p>               Bases: <code>GeneralResponse</code></p> <p>Represents a response containing result data, inheriting from GeneralResponse.</p> <p>This class is used to encapsulate response data specific to result information. It extends the functionality provided by GeneralResponse and includes additional data fields related to results. The purpose of this class is to standardize the structure of result-related responses and ensure consistent access to result data in the response object.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>ResultDataModel</code> <p>Contains the specific result data encapsulated in the ResultDataModel.</p> Source code in <code>backend/app/responses.py</code> <pre><code>class ResultResponse(GeneralResponse):\n    \"\"\"\n    Represents a response containing result data, inheriting from GeneralResponse.\n\n    This class is used to encapsulate response data specific to result information.\n    It extends the functionality provided by GeneralResponse and includes additional\n    data fields related to results. The purpose of this class is to standardize the\n    structure of result-related responses and ensure consistent access to result\n    data in the response object.\n\n    :ivar data: Contains the specific result data encapsulated in the ResultDataModel.\n    :type data: ResultDataModel\n    \"\"\"\n    data: ResultDataModel\n</code></pre>"},{"location":"backend/api/security/","title":"security","text":""},{"location":"backend/api/security/#app.security.decode_token","title":"<code>decode_token(token)</code>","text":"<p>Decode a JSON Web Token (JWT).</p> <p>This function takes a JSON Web Token (JWT) string and decodes it using the specified secret and algorithm. The decoded token data is returned, allowing further processing or validation.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The JWT string to decode.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Decoded token data.</p> Source code in <code>backend/app/security.py</code> <pre><code>def decode_token(token: str):\n    \"\"\"\n    Decode a JSON Web Token (JWT).\n\n    This function takes a JSON Web Token (JWT) string and decodes it using\n    the specified secret and algorithm. The decoded token data is returned,\n    allowing further processing or validation.\n\n    :param token: The JWT string to decode.\n    :type token: str\n    :return: Decoded token data.\n    :rtype: dict\n    \"\"\"\n    token_data = jwt.decode(token, token_secret, algorithms=[\"HS256\"])\n    return token_data\n</code></pre>"},{"location":"backend/api/types/","title":"types","text":""},{"location":"backend/api/types/#app.types.OepTypes","title":"<code>OepTypes</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Defines the OepTypes enumeration that categorizes various types of energy systems and technologies. Each enumeration value represents a specific energy-related component, along with its associated category, such as storage, source, or converter.</p> <p>This enumeration can be used for energy modeling, categorization, and analysis in energy systems. It provides an organized scheme for referencing and interacting with different energy-related components.</p> <p>Attributes:</p> Name Type Description <code>storage_electricity</code> <p>An energy storage system for electricity, categorized as generic storage.</p> <code>storage_electricity_pumped_hydro_storage_power_technology</code> <p>A pumped hydro energy storage system, categorized as generic storage.</p> <code>storage_gas</code> <p>A gas storage system, categorized as generic storage.</p> <code>storage_heat_district_heating</code> <p>A heat storage system for district heating, categorized as generic storage.</p> <code>storage_heat_seasonal</code> <p>A seasonal heat storage system, categorized as generic storage.</p> <code>storage_hydrogen</code> <p>A hydrogen storage system, categorized as generic storage.</p> <code>fuel_cells</code> <p>A fuel cell system for energy generation, categorized as a source.</p> <code>hydrogen_feed_in</code> <p>A hydrogen feed-in system, categorized as a source.</p> <code>onshore_wind_power_plant</code> <p>An onshore wind power generator, categorized as a source.</p> <code>rooftop_photovoltaic_power_plant</code> <p>A rooftop photovoltaic system, categorized as a source.</p> <code>run_river_power_plant</code> <p>A run-of-river power generation plant, categorized as a source.</p> <code>solar_thermal_power_plant</code> <p>A solar thermal power generation plant, categorized as a source.</p> <code>power_to_liquid_system</code> <p>A system converting power to liquid fuel, categorized as a converter.</p> <code>biogas_combined_heat_and_power_plant</code> <p>A biogas-fueled combined heat and power generation plant, categorized as a converter.</p> <code>biogas_upgrading_plant</code> <p>A plant for upgrading biogas, categorized as a converter.</p> <code>biomass_combined_heat_and_power_plant</code> <p>A biomass-fueled combined heat and power generation plant, categorized as a converter.</p> <code>biomass_heating_plant</code> <p>A biomass-based heating system, categorized as a converter.</p> <code>biomass_power_plant</code> <p>A biomass-fueled power generation plant, categorized as a converter.</p> <code>biomass_to_liquid_system</code> <p>A system converting biomass to liquid fuel, categorized as a converter.</p> <code>biomethane_injection_plant</code> <p>A system for injecting biomethane into the grid, categorized as a converter.</p> <code>combined_heat_and_power_generating_unit</code> <p>A combined heat and power-generating unit, categorized as a converter.</p> <code>electrical_heater</code> <p>An electrical heater, categorized as a converter.</p> <code>electrolysis</code> <p>A system for producing hydrogen through electrolysis, categorized as a converter.</p> <code>heat_pump_air_waste_heat</code> <p>A heat pump system using waste heat from air, categorized as a converter.</p> <code>heat_pump_air_ambient_heat</code> <p>A heat pump system utilizing ambient air heat, categorized as a converter.</p> <code>heat_pump_ground_river_heat</code> <p>A heat pump that uses ground or river heat, categorized as a converter.</p> <code>methanation</code> <p>A system for producing methane from hydrogen and CO2, categorized as a converter.</p> Source code in <code>backend/app/types.py</code> <pre><code>class OepTypes(Enum):\n    \"\"\"\n    Defines the OepTypes enumeration that categorizes various types of energy systems\n    and technologies. Each enumeration value represents a specific energy-related\n    component, along with its associated category, such as storage, source, or converter.\n\n    This enumeration can be used for energy modeling, categorization, and analysis in\n    energy systems. It provides an organized scheme for referencing and interacting\n    with different energy-related components.\n\n    :ivar storage_electricity: An energy storage system for electricity, categorized\n                               as generic storage.\n    :ivar storage_electricity_pumped_hydro_storage_power_technology: A pumped hydro\n                               energy storage system, categorized as generic storage.\n    :ivar storage_gas: A gas storage system, categorized as generic storage.\n    :ivar storage_heat_district_heating: A heat storage system for district heating,\n                               categorized as generic storage.\n    :ivar storage_heat_seasonal: A seasonal heat storage system, categorized as generic\n                               storage.\n    :ivar storage_hydrogen: A hydrogen storage system, categorized as generic storage.\n    :ivar fuel_cells: A fuel cell system for energy generation, categorized as a source.\n    :ivar hydrogen_feed_in: A hydrogen feed-in system, categorized as a source.\n    :ivar onshore_wind_power_plant: An onshore wind power generator, categorized as a source.\n    :ivar rooftop_photovoltaic_power_plant: A rooftop photovoltaic system, categorized as\n                               a source.\n    :ivar run_river_power_plant: A run-of-river power generation plant, categorized as a source.\n    :ivar solar_thermal_power_plant: A solar thermal power generation plant, categorized\n                               as a source.\n    :ivar power_to_liquid_system: A system converting power to liquid fuel, categorized as\n                               a converter.\n    :ivar biogas_combined_heat_and_power_plant: A biogas-fueled combined heat and power\n                               generation plant, categorized as a converter.\n    :ivar biogas_upgrading_plant: A plant for upgrading biogas, categorized as a converter.\n    :ivar biomass_combined_heat_and_power_plant: A biomass-fueled combined heat and power\n                               generation plant, categorized as a converter.\n    :ivar biomass_heating_plant: A biomass-based heating system, categorized as a converter.\n    :ivar biomass_power_plant: A biomass-fueled power generation plant, categorized as a\n                               converter.\n    :ivar biomass_to_liquid_system: A system converting biomass to liquid fuel, categorized\n                               as a converter.\n    :ivar biomethane_injection_plant: A system for injecting biomethane into the grid,\n                               categorized as a converter.\n    :ivar combined_heat_and_power_generating_unit: A combined heat and power-generating unit,\n                               categorized as a converter.\n    :ivar electrical_heater: An electrical heater, categorized as a converter.\n    :ivar electrolysis: A system for producing hydrogen through electrolysis, categorized\n                               as a converter.\n    :ivar heat_pump_air_waste_heat: A heat pump system using waste heat from air, categorized\n                               as a converter.\n    :ivar heat_pump_air_ambient_heat: A heat pump system utilizing ambient air heat,\n                               categorized as a converter.\n    :ivar heat_pump_ground_river_heat: A heat pump that uses ground or river heat, categorized\n                               as a converter.\n    :ivar methanation: A system for producing methane from hydrogen and CO2, categorized as\n                               a converter.\n    \"\"\"\n    # storages\n    storage_electricity = (\"storage_electricity\", \"generic_storage\")\n    storage_electricity_pumped_hydro_storage_power_technology = (\n        \"storage_electricity_pumped_hydro_storage_power_technology\", \"generic_storage\")\n    storage_gas = (\"storage_gas\", \"generic_storage\")\n    storage_heat_district_heating = (\"storage_heat_district_heating\", \"generic_storage\")\n    storage_heat_seasonal = (\"storage_heat_seasonal\", \"generic_storage\")\n    storage_hydrogen = (\"storage_hydrogen\", \"generic_storage\")\n\n    # sinks\n    electricity_export = (\"electricity_export\", \"sink\")\n\n    electricity_demand_efh = (\"electricity_demand_efh\", \"sink\")\n    electricity_demand_industry = (\"electricity_demand_industry\", \"sink\")\n    electricity_demand_mfh = (\"electricity_demand_mfh\", \"sink\")\n    heat_demand_efh = (\"heat_demand_efh\", \"sink\")\n    heat_demand_industry = (\"heat_demand_industry\", \"sink\")\n    heat_demand_mfh = (\"heat_demand_mfh\", \"sink\")\n\n    # sources\n    hydrogen_feed_in = (\"hydrogen_feed_in\", \"source\")\n    run_river_power_plant = (\"run_river_power_plant\", \"source\")\n    solar_thermal_power_plant = (\"solar_thermal_power_plant\", \"source\")\n    onshore_wind_power_plant_east_th = (\"onshore_wind_power_plant_east_th\", \"source\")\n    onshore_wind_power_plant_middle_th = (\"onshore_wind_power_plant_middle_th\", \"source\")\n    onshore_wind_power_plant_north_th = (\"onshore_wind_power_plant_north_th\", \"source\")\n    onshore_wind_power_plant_swest_th = (\"onshore_wind_power_plant_swest_th\", \"source\")\n    openfield_photovoltaic_power_plant_east_th = (\"openfield_photovoltaic_power_plant_east_th\", \"source\")\n    openfield_photovoltaic_power_plant_middle_th = (\"openfield_photovoltaic_power_plant_middle_th\", \"source\")\n    openfield_photovoltaic_power_plant_north_th = (\"openfield_photovoltaic_power_plant_north_th\", \"source\")\n    openfield_photovoltaic_power_plant_swest_th = (\"openfield_photovoltaic_power_plant_swest_th\", \"source\")\n    rooftop_photovoltaic_power_plant_east_th = (\"rooftop_photovoltaic_power_plant_east_th\", \"source\")\n    rooftop_photovoltaic_power_plant_middle_th = (\"rooftop_photovoltaic_power_plant_middle_th\", \"source\")\n    rooftop_photovoltaic_power_plant_north_th = (\"rooftop_photovoltaic_power_plant_north_th\", \"source\")\n    rooftop_photovoltaic_power_plant_swest_th = (\"rooftop_photovoltaic_power_plant_swest_th\", \"source\")\n\n    # converters\n    power_to_liquid_system = (\"power_to_liquid_system\", \"converter\")\n    fuel_cells = (\"fuel_cells\", \"converter\")\n    biogas_combined_heat_and_power_plant = (\"biogas_combined_heat_and_power_plant\", \"converter\")\n    biogas_upgrading_plant = (\"biogas_upgrading_plant\", \"converter\")\n    biomass_combined_heat_and_power_plant = (\"biomass_combined_heat_and_power_plant\", \"converter\")\n    biomass_heating_plant = (\"biomass_heating_plant\", \"converter\")\n    biomass_power_plant = (\"biomass_power_plant\", \"converter\")\n    biomass_to_liquid_system = (\"biomass_to_liquid_system\", \"converter\")\n    biomethane_injection_plant = (\"biomethane_injection_plant\", \"converter\")\n    combined_heat_and_power_generating_unit = (\"combined_heat_and_power_generating_unit\", \"converter\")\n    electrical_heater = (\"electical_heater\", \"converter\")\n    electrolysis = (\"electrolysis\", \"converter\")\n    heat_pump_air_waste_heat = (\"heat_pump_air_waste_heat\", \"converter\")\n    heat_pump_air_ambient_heat = (\"heat_pump_air_ambient_heat\", \"converter\")\n    heat_pump_ground_river_heat = (\"heat_pump_ground_river_heat\", \"converter\")\n    methanation = (\"methanation\", \"converter\")\n</code></pre>"},{"location":"backend/api/models/data/","title":"data","text":""},{"location":"backend/api/models/data/#app.data.model.GeneralDataModel","title":"<code>GeneralDataModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a general data model with a collection of items and the total count of items.</p> <p>This class is used to encapsulate a collection of items along with their total count in a data structure. It serves as a general-purpose representation of data collections and is flexible in handling any type of items within the list.</p> <p>Attributes:</p> Name Type Description <code>items</code> <code>list[Any]</code> <p>A list of items representing the data collection.</p> <code>totalCount</code> <code>int</code> <p>The total number of items in the collection.</p> Source code in <code>backend/app/data/model.py</code> <pre><code>class GeneralDataModel(BaseModel):\n    \"\"\"\n    Represents a general data model with a collection of items and the total count of items.\n\n    This class is used to encapsulate a collection of items along with their total count in a\n    data structure. It serves as a general-purpose representation of data collections and is\n    flexible in handling any type of items within the list.\n\n    :ivar items: A list of items representing the data collection.\n    :type items: list[Any]\n    :ivar totalCount: The total number of items in the collection.\n    :type totalCount: Int\n    \"\"\"\n    items: list[Any] = Field(..., description=\"A list of items representing the data collection.\")\n    totalCount: int = Field(..., description=\"The total number of items in the collection.\")\n</code></pre>"},{"location":"backend/api/models/errors/","title":"errors","text":""},{"location":"backend/api/models/errors/#app.errors.model.ErrorModel","title":"<code>ErrorModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an error model containing details of an error.</p> <p>This class is used to encapsulate metadata for error conditions, such as the error code and the error message. It provides a structured way to convey error information within applications or across systems.</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>int</code> <p>Error code for the error.</p> <code>message</code> <code>str</code> <p>Error message for the error.</p> Source code in <code>backend/app/errors/model.py</code> <pre><code>class ErrorModel(BaseModel):\n    \"\"\"\n    Represents an error model containing details of an error.\n\n    This class is used to encapsulate metadata for error conditions, such as\n    the error code and the error message. It provides a structured way to\n    convey error information within applications or across systems.\n\n    :ivar code: Error code for the error.\n    :type code: int\n    :ivar message: Error message for the error.\n    :type message: str\n    \"\"\"\n    code: int = Field(\n        description=\"Error code for the error.\",\n    )\n    message: str = Field(\n        description=\"Error message for the error.\",\n    )\n</code></pre>"},{"location":"backend/api/models/project/","title":"project","text":""},{"location":"backend/api/models/project/#app.project.model.EnProject","title":"<code>EnProject</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Represents a project entity with details regarding its name, description, location, energy unit, CO2 unit, currency, geographical coordinates, and favorite status.</p> <p>This class is intended to encapsulate core information about a project, such as its basic details and metadata, allowing for clear organization and representation in a database. The attributes include constraints for data validation.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the project must be between 1 and 100 characters.</p> <code>description</code> <code>str | None</code> <p>An optional description of the project, up to 255 characters.</p> <code>country</code> <code>str</code> <p>The country where the project is located, max length of 40 characters.</p> <code>unit_energy</code> <code>str</code> <p>The energy unit associated with the project, max length of 10 characters.</p> <code>unit_co2</code> <code>str</code> <p>The CO2 unit associated with the project, max length of 10 characters.</p> <code>currency</code> <code>str</code> <p>The currency used in the project, max length of 8 characters.</p> <code>longitude</code> <code>float</code> <p>The longitude coordinate of the project location. Can be null.</p> <code>latitude</code> <code>float</code> <p>The latitude coordinate of the project location. Can be null.</p> <code>is_favorite</code> <code>bool</code> <p>Indicates if the project is marked as a favorite. Defaults to False.</p> Source code in <code>backend/app/project/model.py</code> <pre><code>class EnProject(SQLModel):\n    \"\"\"\n    Represents a project entity with details regarding its name, description, location,\n    energy unit, CO2 unit, currency, geographical coordinates, and favorite status.\n\n    This class is intended to encapsulate core information about a project, such as\n    its basic details and metadata, allowing for clear organization and representation\n    in a database. The attributes include constraints for data validation.\n\n    :ivar name: The name of the project must be between 1 and 100 characters.\n    :type name: Str\n    :ivar description: An optional description of the project, up to 255 characters.\n    :type description: Str | None\n    :ivar country: The country where the project is located, max length of 40 characters.\n    :type country: Str\n    :ivar unit_energy: The energy unit associated with the project, max length of 10 characters.\n    :type unit_energy: Str\n    :ivar unit_co2: The CO2 unit associated with the project, max length of 10 characters.\n    :type unit_co2: Str\n    :ivar currency: The currency used in the project, max length of 8 characters.\n    :type currency: Str\n    :ivar longitude: The longitude coordinate of the project location. Can be null.\n    :type longitude: Float\n    :ivar latitude: The latitude coordinate of the project location. Can be null.\n    :type latitude: Float\n    :ivar is_favorite: Indicates if the project is marked as a favorite. Defaults to False.\n    :type is_favorite: Bool\n    \"\"\"\n    name: str = Field(min_length=1, max_length=100)\n    description: str | None = Field(default=None, min_length=1, max_length=255, nullable=True)\n    country: str = Field(min_length=1, max_length=40)\n    unit_energy: str = Field(min_length=1, max_length=10)\n    unit_co2: str = Field(min_length=1, max_length=10)\n    currency: str = Field(min_length=1, max_length=8)\n    longitude: float = Field(nullable=True)\n    latitude: float = Field(nullable=True)\n    is_favorite: bool = Field(default=False)\n</code></pre>"},{"location":"backend/api/models/project/#app.project.model.EnProjectDB","title":"<code>EnProjectDB</code>","text":"<p>               Bases: <code>EnProject</code></p> <p>Represents the EnProjectDB entity that defines the structure of the \"projects\" database table and inherits from the EnProject class.</p> <p>This class is used to model and manipulate project data within the database, providing details such as project ID, associated user ID, creation timestamp, and update timestamp.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Unique identifier for the project.</p> <code>user_id</code> <code>int</code> <p>ID of the user associated with the project.</p> <code>date_created</code> <code>datetime</code> <p>Timestamp indicating when the project was created.</p> <code>date_updated</code> <code>datetime | None</code> <p>Timestamp indicating when the project was last updated or None if not updated.</p> Source code in <code>backend/app/project/model.py</code> <pre><code>class EnProjectDB(EnProject, table=True):\n    \"\"\"\n    Represents the EnProjectDB entity that defines the structure of the \"projects\" database\n    table and inherits from the EnProject class.\n\n    This class is used to model and manipulate project data within the database, providing\n    details such as project ID, associated user ID, creation timestamp, and update timestamp.\n\n    :ivar id: Unique identifier for the project.\n    :type id: Int\n    :ivar user_id: ID of the user associated with the project.\n    :type user_id: Int\n    :ivar date_created: Timestamp indicating when the project was created.\n    :type date_created: Datetime\n    :ivar date_updated: Timestamp indicating when the project was last updated or None if not updated.\n    :type date_updated: Datetime | None\n    \"\"\"\n    __tablename__ = \"projects\"\n\n    id: int = Field(default=None, primary_key=True)\n    user_id: int = Field(foreign_key=\"users.id\")\n    date_created: datetime = Field(default=datetime.now)\n    date_updated: datetime | None = Field(default=None)\n\n    def get_return_data(self):\n        return self.dict(exclude={\"user_id\"})\n</code></pre>"},{"location":"backend/api/models/project/#app.project.model.EnProjectUpdate","title":"<code>EnProjectUpdate</code>","text":"<p>               Bases: <code>EnProject</code></p> <p>Represents an updated project with additional configurable fields.</p> <p>This class is a subclass of <code>EnProject</code> and is designed to provide additional fields and configuration options for a project's update. It allows for modification of the project's name, country, energy and CO2 units, currency, as well as geographical coordinates (longitude and latitude).</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str | None</code> <p>Name of the project. This is an optional field that must have a length between 1 and 100 characters if provided.</p> <code>country</code> <code>str | None</code> <p>Country associated with the project. This is an optional field that must have a length between 1 and 40 characters if provided.</p> <code>unit_energy</code> <code>str | None</code> <p>Unit of energy measurement for the project. This is an optional field that must have a length between 1 and 10 characters if provided.</p> <code>unit_co2</code> <code>str | None</code> <p>Unit of CO2 measurement for the project. This is an optional field that must have a length between 1 and 10 characters if provided.</p> <code>currency</code> <code>str | None</code> <p>Currency used for the project. This is a required field that must have a length between 1 and 8 characters.</p> <code>longitude</code> <code>float | None</code> <p>Longitude value of the project's geographical location. This is an optional field.</p> <code>latitude</code> <code>float | None</code> <p>Latitude value of the project's geographical location. This is an optional field.</p> Source code in <code>backend/app/project/model.py</code> <pre><code>class EnProjectUpdate(EnProject):\n    \"\"\"\n    Represents an updated project with additional configurable fields.\n\n    This class is a subclass of `EnProject` and is designed to provide\n    additional fields and configuration options for a project's update. It\n    allows for modification of the project's name, country, energy and CO2\n    units, currency, as well as geographical coordinates (longitude and\n    latitude).\n\n    :ivar name: Name of the project. This is an optional field that must have\n        a length between 1 and 100 characters if provided.\n    :ivar country: Country associated with the project. This is an optional\n        field that must have a length between 1 and 40 characters if provided.\n    :ivar unit_energy: Unit of energy measurement for the project. This is an\n        optional field that must have a length between 1 and 10 characters if\n        provided.\n    :ivar unit_co2: Unit of CO2 measurement for the project. This is an\n        optional field that must have a length between 1 and 10 characters if\n        provided.\n    :ivar currency: Currency used for the project. This is a required field\n        that must have a length between 1 and 8 characters.\n    :ivar longitude: Longitude value of the project's geographical location.\n        This is an optional field.\n    :ivar latitude: Latitude value of the project's geographical location.\n        This is an optional field.\n    \"\"\"\n    name: str | None = Field(default=None, min_length=1, max_length=100, nullable=True)\n    country: str | None = Field(default=None, min_length=1, max_length=40, nullable=True)\n    unit_energy: str | None = Field(default=None, min_length=1, max_length=10, nullable=True)\n    unit_co2: str | None = Field(default=None, min_length=1, max_length=10, nullable=True)\n    currency: str | None = Field(min_length=1, max_length=8)\n    longitude: float | None = Field(default=None, nullable=True)\n    latitude: float | None = Field(default=None, nullable=True)\n</code></pre>"},{"location":"backend/api/models/results/","title":"results","text":""},{"location":"backend/api/models/results/#app.results.model.EnDataFrame","title":"<code>EnDataFrame</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a data model for a DataFrame-like structure with enhanced time series data.</p> <p>This class is designed to manage and store time series data associated with a specific name and a corresponding index of datetime values.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the data frame.</p> <code>index</code> <code>list[datetime]</code> <p>List of datetime objects representing the index of the data frame.</p> <code>data</code> <code>list[EnTimeSeries]</code> <p>List of EnTimeSeries objects representing the time series data.</p> Source code in <code>backend/app/results/model.py</code> <pre><code>class EnDataFrame(BaseModel):\n    \"\"\"\n    Represents a data model for a DataFrame-like structure with enhanced time series data.\n\n    This class is designed to manage and store time series data associated with a specific\n    name and a corresponding index of datetime values.\n\n    :ivar name: Name of the data frame.\n    :type name: str\n    :ivar index: List of datetime objects representing the index of the data frame.\n    :type index: list[datetime]\n    :ivar data: List of EnTimeSeries objects representing the time series data.\n    :type data: list[EnTimeSeries]\n    \"\"\"\n    name: str\n    index: list[datetime]\n    data: list[EnTimeSeries]\n</code></pre>"},{"location":"backend/api/models/results/#app.results.model.EnTimeSeries","title":"<code>EnTimeSeries</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents a time series data model with a name and corresponding data points.</p> <p>This class provides a structure for storing time series data which includes a descriptive name and a list of numerical data points. It can be used for various time-based data analysis and storage requirements.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the time series.</p> <code>data</code> <code>list[float]</code> <p>A list of numerical data points representing the time series.</p> Source code in <code>backend/app/results/model.py</code> <pre><code>class EnTimeSeries(BaseModel):\n    \"\"\"\n    Represents a time series data model with a name and corresponding data points.\n\n    This class provides a structure for storing time series data which includes\n    a descriptive name and a list of numerical data points. It can be used for\n    various time-based data analysis and storage requirements.\n\n    :ivar name: The name of the time series.\n    :type name: str\n    :ivar data: A list of numerical data points representing the time series.\n    :type data: list[float]\n    \"\"\"\n    name: str\n    data: list[float]\n</code></pre>"},{"location":"backend/api/models/results/#app.results.model.ResultDataModel","title":"<code>ResultDataModel</code>","text":"<p>               Bases: <code>GeneralDataModel</code></p> <p>Represents a specialized data model for storing results.</p> <p>Inherits from the <code>GeneralDataModel</code> and is used specifically for storing a collection of <code>EnDataFrame</code> objects. This class helps organize and manage the result data in a structured manner.</p> <p>Attributes:</p> Name Type Description <code>items</code> <code>list[EnDataFrame]</code> <p>A collection of <code>EnDataFrame</code> objects representing the data stored in the model.</p> Source code in <code>backend/app/results/model.py</code> <pre><code>class ResultDataModel(GeneralDataModel):\n    \"\"\"\n    Represents a specialized data model for storing results.\n\n    Inherits from the `GeneralDataModel` and is used specifically\n    for storing a collection of `EnDataFrame` objects. This class\n    helps organize and manage the result data in a structured manner.\n\n    :ivar items: A collection of `EnDataFrame` objects representing\n        the data stored in the model.\n    :type items: list[EnDataFrame]\n    \"\"\"\n    items: list[EnDataFrame]\n</code></pre>"},{"location":"backend/api/models/scenario/","title":"scenario","text":""},{"location":"backend/api/models/scenario/#app.scenario.model.EnScenario","title":"<code>EnScenario</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents an energy scenario with detailed specifications and attributes.</p> <p>The EnScenario class models a scenario in an energy system setting, incorporating various attributes such as name, start date, time steps, interval, and associated energy system models. This facilitates structured handling of scenario data within an energy modeling system.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the energy scenario. Must be between 1 and 100 characters.</p> <code>start_date</code> <code>date</code> <p>The starting date for the scenario. Defaults to the current date.</p> <code>time_steps</code> <code>int | None</code> <p>The number of time steps in the scenario. Can be None for no specific limit or defaults to 8760.</p> <code>interval</code> <code>float</code> <p>The interval between each time step in hours. Defaults to 1.0.</p> <code>project_id</code> <code>int</code> <p>Identifier for the project to which the scenario belongs.</p> <code>modeling_data</code> <code>str</code> <p>The associated energy system model for the scenario.</p> Source code in <code>backend/app/scenario/model.py</code> <pre><code>class EnScenario(BaseModel):\n    \"\"\"\n    Represents an energy scenario with detailed specifications and attributes.\n\n    The EnScenario class models a scenario in an energy system setting, incorporating\n    various attributes such as name, start date, time steps, interval, and associated\n    energy system models. This facilitates structured handling of scenario data within\n    an energy modeling system.\n\n    :ivar name: Name of the energy scenario. Must be between 1 and 100 characters.\n    :type name: Str\n    :ivar start_date: The starting date for the scenario. Defaults to the current date.\n    :type start_date: Date\n    :ivar time_steps: The number of time steps in the scenario. Can be None for no specific\n                      limit or defaults to 8760.\n    :type time_steps: Int | None\n    :ivar interval: The interval between each time step in hours. Defaults to 1.0.\n    :type interval: Float\n    :ivar project_id: Identifier for the project to which the scenario belongs.\n    :type project_id: Int\n    :ivar modeling_data: The associated energy system model for the scenario.\n    :type modeling_data: JSONB\n    \"\"\"\n    name: str = Field(min_length=1, max_length=100)\n    start_date: date = Field(default=datetime.now().date())  # start\n    time_steps: int | None = Field(default=8760, nullable=True)  # number\n    interval: float = Field(default=1.0)  # interval\n    project_id: int\n    modeling_data: str = Field(default=\"\")\n</code></pre>"},{"location":"backend/api/models/scenario/#app.scenario.model.EnScenarioDB","title":"<code>EnScenarioDB</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Represents the database model for energy scenario information.</p> <p>This class defines a database model for storing information about energy scenarios. It uses SQLModel with table mapping enabled to represent the corresponding table in the database. The class includes various fields that describe properties of the energy scenario, such as its name, associated project and user IDs, start date, time steps, and other relevant details.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Primary key of the scenario record.</p> <code>name</code> <code>str</code> <p>Name of the energy scenario must be between 1 and 100 characters in length.</p> <code>start_date</code> <code>date</code> <p>Start date of the energy scenario. This is a required field.</p> <code>time_steps</code> <code>int | None</code> <p>Number of time steps in the energy scenario. Defaults to 8760 if not provided and is nullable.</p> <code>interval</code> <code>float</code> <p>Time interval associated with the energy scenario. Defaults to 1.</p> <code>project_id</code> <code>int</code> <p>Foreign key referencing the associated project for the scenario.</p> <code>user_id</code> <code>int</code> <p>Foreign key referencing the user associated with the scenario.</p> <code>modeling_data</code> <code>str</code> <p>JSONB column storing the energy system model associated with the scenario. Defaults to an empty dictionary.</p> Source code in <code>backend/app/scenario/model.py</code> <pre><code>class EnScenarioDB(SQLModel, table=True):\n    \"\"\"\n    Represents the database model for energy scenario information.\n\n    This class defines a database model for storing information about\n    energy scenarios. It uses SQLModel with table mapping enabled\n    to represent the corresponding table in the database. The class\n    includes various fields that describe properties of the energy\n    scenario, such as its name, associated project and user IDs, start\n    date, time steps, and other relevant details.\n\n    :ivar id: Primary key of the scenario record.\n    :type id: Int\n    :ivar name: Name of the energy scenario must be between 1 and 100\n        characters in length.\n    :type name: Str\n    :ivar start_date: Start date of the energy scenario. This is a required\n        field.\n    :type start_date: Date\n    :ivar time_steps: Number of time steps in the energy scenario.\n        Defaults to 8760 if not provided and is nullable.\n    :type time_steps: Int | None\n    :ivar interval: Time interval associated with the energy scenario.\n        Defaults to 1.\n    :type interval: Float\n    :ivar project_id: Foreign key referencing the associated project for\n        the scenario.\n    :type project_id: Int\n    :ivar user_id: Foreign key referencing the user associated with the\n        scenario.\n    :type user_id: Int\n    :ivar modeling_data: JSONB column storing the energy system\n        model associated with the scenario. Defaults to an empty\n        dictionary.\n    :type modeling_data: Str\n    \"\"\"\n\n    class Config:\n        arbitrary_types_allowed = True\n\n    __tablename__ = \"scenarios\"\n\n    id: int = Field(default=None, primary_key=True)\n    name: str = Field(min_length=1, max_length=100)\n    start_date: date = Field(nullable=False)\n    time_steps: int | None = Field(default=8760, nullable=True)\n    interval: float = Field(default=1)\n    project_id: int = Field(foreign_key=\"projects.id\")\n    user_id: int = Field(foreign_key=\"users.id\")\n    modeling_data: str = Field(sa_column=Column(JSONB), default={})\n    energysystem: EnEnergysystem = Field(sa_column=Column(JSONB), default={})\n</code></pre>"},{"location":"backend/api/models/scenario/#app.scenario.model.EnScenarioUpdate","title":"<code>EnScenarioUpdate</code>","text":"<p>               Bases: <code>EnScenario</code></p> <p>Represents an updated energy scenario with validated parameters.</p> <p>This class extends the functionality of the <code>EnScenario</code> class to allow for scenario updates with specific attributes constrained by validation requirements. It is primarily used for defining and updating the parameters of an energy simulation scenario, ensuring proper formats and validations such as field lengths and data type constraints.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str | None</code> <p>Optional name of the scenario, which must be a string with a minimum length of 1 character and a maximum length of 100 characters.</p> <code>interval</code> <code>float | None</code> <p>Optional interval defining the time step size, where the value is a float.</p> <code>start_date</code> <code>date | None</code> <p>Optional start date for the scenario, represented as a date object.</p> <code>time_steps</code> <code>int | None</code> <p>Optional total number of time steps in the simulation.</p> <code>modeling_data</code> <code>str | None</code> <p>All modeling data from the graphical user interface generated by drawflow.</p> <code>project_id</code> <code>None</code> <p>Reserved attribute for the project ID, currently none.</p> <code>user_id</code> <code>None</code> <p>Reserved attribute for the user ID, currently none.</p> Source code in <code>backend/app/scenario/model.py</code> <pre><code>class EnScenarioUpdate(EnScenario):\n    \"\"\"\n    Represents an updated energy scenario with validated parameters.\n\n    This class extends the functionality of the `EnScenario` class to allow for\n    scenario updates with specific attributes constrained by validation requirements.\n    It is primarily used for defining and updating the parameters of an energy simulation\n    scenario, ensuring proper formats and validations such as field lengths and data type\n    constraints.\n\n    :ivar name: Optional name of the scenario, which must be a string with a\n        minimum length of 1 character and a maximum length of 100 characters.\n    :type name: Str | None\n    :ivar interval: Optional interval defining the time step size, where the value\n        is a float.\n    :type interval: Float | None\n    :ivar start_date: Optional start date for the scenario, represented as a date object.\n    :type start_date: Date | None\n    :ivar time_steps: Optional total number of time steps in the simulation.\n    :type time_steps: Int | None\n    :ivar modeling_data: All modeling data from the graphical user interface generated by drawflow.\n    :type modeling_data: JSONB | None\n    :ivar project_id: Reserved attribute for the project ID, currently none.\n    :type project_id: None\n    :ivar user_id: Reserved attribute for the user ID, currently none.\n    :type user_id: None\n    \"\"\"\n    name: str | None = Field(default=None, min_length=1, max_length=100, nullable=True)\n    interval: float | None = Field(default=1, nullable=True)\n    start_date: date | None = Field(default=None, nullable=True)\n    time_steps: int | None = Field(default=None, nullable=True)\n    modeling_data: str | None = Field(default=None, nullable=True)\n    project_id: None = None\n    user_id: None = None\n</code></pre>"},{"location":"backend/api/models/simulation/","title":"simulation","text":""},{"location":"backend/api/models/simulation/#app.simulation.model.EnSimulation","title":"<code>EnSimulation</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Represents the simulation entity in the application.</p> <p>The <code>EnSimulation</code> class models a simulation instance with its various properties, including token, status, start and end dates, and association to a specific scenario. It provides a structured representation of simulation for storing and retrieving purposes.</p> <p>Attributes:</p> Name Type Description <code>sim_token</code> <code>str</code> <p>Unique token identifying the simulation.</p> <code>status</code> <code>str</code> <p>Current status of the simulation, e.g., started, completed.</p> <code>start_date</code> <code>datetime</code> <p>Date and time when the simulation was started.</p> <code>end_date</code> <code>datetime | None</code> <p>Date and time when the simulation was ended (optional).</p> <code>scenario_id</code> <code>int</code> <p>Identifier of the related scenario in the database.</p> Source code in <code>backend/app/simulation/model.py</code> <pre><code>class EnSimulation(BaseModel):\n    \"\"\"\n    Represents the simulation entity in the application.\n\n    The `EnSimulation` class models a simulation instance with its various\n    properties, including token, status, start and end dates, and\n    association to a specific scenario. It provides a structured\n    representation of simulation for storing and retrieving purposes.\n\n    :ivar sim_token: Unique token identifying the simulation.\n    :type sim_token: str\n    :ivar status: Current status of the simulation, e.g., started, completed.\n    :type status: str\n    :ivar start_date: Date and time when the simulation was started.\n    :type start_date: datetime\n    :ivar end_date: Date and time when the simulation was ended (optional).\n    :type end_date: datetime | None\n    :ivar scenario_id: Identifier of the related scenario in the database.\n    :type scenario_id: int\n    \"\"\"\n    sim_token: str = Field(nullable=False)\n    status: str = Field(default=Status.STARTED.value, nullable=False)\n    start_date: datetime = Field(nullable=False)\n    end_date: datetime | None = Field(default=None, nullable=True)\n    scenario_id: int = Field(default=None, nullable=False, foreign_key=\"scenarios.id\")\n</code></pre>"},{"location":"backend/api/models/simulation/#app.simulation.model.EnSimulationDB","title":"<code>EnSimulationDB</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Representation of a simulation entry in the database.</p> <p>This class defines the data structure and table mapping for simulation entries in the database. It includes fields for basic simulation attributes such as its unique identifier, status, dates, and related scenario. This model is used to manage and interact with the simulation data persisted in the database.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>Unique identifier for the simulation.</p> <code>sim_token</code> <code>str</code> <p>Token associated with the simulation, used for identification or access.</p> <code>status</code> <code>str</code> <p>Current status of the simulation. Default is <code>Status.STARTED.value</code>.</p> <code>start_date</code> <code>datetime</code> <p>Date and time when the simulation started.</p> <code>end_date</code> <code>datetime | None</code> <p>Date and time when the simulation ended, if available.</p> <code>scenario_id</code> <code>int</code> <p>Identifier of the related scenario. Links the simulation record to a scenario in the database.</p> Source code in <code>backend/app/simulation/model.py</code> <pre><code>class EnSimulationDB(SQLModel, table=True):\n    \"\"\"\n    Representation of a simulation entry in the database.\n\n    This class defines the data structure and table mapping for\n    simulation entries in the database. It includes fields\n    for basic simulation attributes such as its unique identifier,\n    status, dates, and related scenario. This model is used to\n    manage and interact with the simulation data persisted in the\n    database.\n\n    :ivar id: Unique identifier for the simulation.\n    :type id: int\n    :ivar sim_token: Token associated with the simulation, used for\n        identification or access.\n    :type sim_token: str\n    :ivar status: Current status of the simulation. Default is\n        `Status.STARTED.value`.\n    :type status: str\n    :ivar start_date: Date and time when the simulation started.\n    :type start_date: datetime\n    :ivar end_date: Date and time when the simulation ended, if available.\n    :type end_date: datetime | None\n    :ivar scenario_id: Identifier of the related scenario. Links the\n        simulation record to a scenario in the database.\n    :type scenario_id: int\n    \"\"\"\n    __tablename__ = \"simulations\"\n\n    id: int = Field(default=None, primary_key=True)\n    sim_token: str = Field(nullable=False)\n    status: str = Field(default=Status.STARTED.value, nullable=False)\n    start_date: datetime = Field(nullable=False)\n    end_date: datetime | None = Field(default=None, nullable=True)\n    scenario_id: int = Field(default=None, nullable=False, foreign_key=\"scenarios.id\")\n</code></pre>"},{"location":"backend/api/models/simulation/#app.simulation.model.EnSimulationUpdate","title":"<code>EnSimulationUpdate</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Represents an energy simulation update model used to track the status and completion date of a simulation.</p> <p>This class models the data structure for storing information about an energy simulation's current status and its potential end date. It inherits from SQLModel to enable database interactions and data serialization.</p> <p>Attributes:</p> Name Type Description <code>status</code> <code>str</code> <p>Indicates the current status of the energy simulation.</p> <code>end_date</code> <code>datetime | None</code> <p>Represents the simulation's end date if available.</p> Source code in <code>backend/app/simulation/model.py</code> <pre><code>class EnSimulationUpdate(SQLModel):\n    \"\"\"\n    Represents an energy simulation update model used to track the status\n    and completion date of a simulation.\n\n    This class models the data structure for storing information about an\n    energy simulation's current status and its potential end date. It\n    inherits from SQLModel to enable database interactions and data\n    serialization.\n\n    :ivar status: Indicates the current status of the energy simulation.\n    :type status: str\n    :ivar end_date: Represents the simulation's end date if available.\n    :type end_date: datetime | None\n    \"\"\"\n    status: str = Field(nullable=False)\n    end_date: datetime | None = Field(default=None, nullable=True)\n</code></pre>"},{"location":"backend/api/models/user/","title":"user","text":""},{"location":"backend/api/models/user/#app.user.model.EnUser","title":"<code>EnUser</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Represents a user entity with various attributes and validation mechanisms for the user-related data fields.</p> <p>This class is primarily used to model user information and enforce constraints on attributes such as username, password, email, and names. It includes mechanisms to handle secure storage and validation of sensitive data like passwords and email addresses. Additionally, methods are provided for verifying passwords and extracting specific token-relevant user data.</p> <p>Attributes:</p> Name Type Description <code>username</code> <code>str</code> <p>The unique username for the user.</p> <code>firstname</code> <code>str | None</code> <p>The optional first name of the user.</p> <code>lastname</code> <code>str | None</code> <p>The optional last name of the user.</p> <code>password</code> <code>str</code> <p>The hashed password for the user.</p> <code>mail</code> <code>str</code> <p>The valid email address associated with the user.</p> Source code in <code>backend/app/user/model.py</code> <pre><code>class EnUser(SQLModel):\n    \"\"\"\n    Represents a user entity with various attributes and validation mechanisms for\n    the user-related data fields.\n\n    This class is primarily used to model user information and enforce constraints\n    on attributes such as username, password, email, and names. It includes mechanisms\n    to handle secure storage and validation of sensitive data like passwords and email\n    addresses. Additionally, methods are provided for verifying passwords and extracting\n    specific token-relevant user data.\n\n    :ivar username: The unique username for the user.\n    :type username: str\n    :ivar firstname: The optional first name of the user.\n    :type firstname: str, optional\n    :ivar lastname: The optional last name of the user.\n    :type lastname: str, optional\n    :ivar password: The hashed password for the user.\n    :type password: str\n    :ivar mail: The valid email address associated with the user.\n    :type mail: str\n    \"\"\"\n    username: str = Field(min_length=3, max_length=128)\n    firstname: str | None = Field(default=None, min_length=0, max_length=64)\n    lastname: str | None = Field(default=None, min_length=0, max_length=64)\n    password: str = Field(min_length=8, max_length=PASSWORD_MAX_LENGTH)\n    mail: str = Field(min_length=8, max_length=128)\n\n    def verify_password(self, plain_password: str) -&gt; bool:\n        return pbkdf2_sha256.verify(plain_password, self.password)\n\n    def get_token_information(self) -&gt; dict:\n        return self.model_dump(include={\"username\"})\n\n    @field_validator('mail', mode='after')\n    @classmethod\n    def is_mail_address(cls, value: str) -&gt; str:\n        \"\"\"\n        Validates and ensures the provided email address is in a valid format.\n        This function checks whether the given string contains the '@' symbol,\n        indicating it is properly structured as an email address. If the validation\n        fails, an HTTPException is raised with an appropriate status code and\n        detail message.\n\n        :param value: The email address to be validated.\n        :type value: str\n        :return: The validated email address if it is valid.\n        :rtype: str\n        :raises HTTPException: If the email address does not contain the '@' symbol.\n        \"\"\"\n        if value.find(\"@\") == -1:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Invalid mail address.\"\n            )\n        return value\n\n    @field_validator('password', mode='after')\n    @classmethod\n    def is_good_password(cls, value: str) -&gt; str:\n        \"\"\"\n        Validates the strength of a password after it has been assigned or modified. The\n        method ensures that the password meets specific security requirements, such as\n        minimum and maximum length, uppercase and lowercase characters, numeric\n        characters, and the inclusion of special symbols.\n\n        :param value: The password string to be validated.\n        :type value: str\n        :return: The original password string if it meets all validation criteria.\n        :rtype: str\n        :raises HTTPException: If the password fails any validation check, such as length,\n            lack of uppercase letters, lowercase letters, digits, or special characters.\n        \"\"\"\n        punctionation = [\"/\", \"$\", \"\u00a7\", \"'\", \",\", \".\", \"@\", \"(\", \")\", \"!\", \"#\", \"*\", \"?\", \"=\", \"&amp;\", \"%\", \"'\", \":\", \";\",\n                         \"&lt;\", \"&gt;\", \"+\", \"-\", \"_\"]\n\n        if len(value) &lt; 3:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Password must be at least 3 characters long.\"\n            )\n\n        if len(value) &gt; PASSWORD_MAX_LENGTH:\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"Password should not exceed 128 characters.\"\n            )\n\n        if not any(c.isupper() for c in value):\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"There should be at least one uppercase character in password.\"\n            )\n\n        if not any(c.islower() for c in value):\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"There should be at least one lowercase character in password.\"\n            )\n\n        if not any(c.isdigit() for c in value):\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"There should be at least one digit in password.\"\n            )\n\n        if not any(c in punctionation for c in value):\n            raise HTTPException(\n                status_code=status.HTTP_400_BAD_REQUEST,\n                detail=\"There should be at least one special character in password.\"\n            )\n\n        return value\n</code></pre>"},{"location":"backend/api/models/user/#app.user.model.EnUser.is_good_password","title":"<code>is_good_password(value)</code>  <code>classmethod</code>","text":"<p>Validates the strength of a password after it has been assigned or modified. The method ensures that the password meets specific security requirements, such as minimum and maximum length, uppercase and lowercase characters, numeric characters, and the inclusion of special symbols.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The password string to be validated.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The original password string if it meets all validation criteria.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the password fails any validation check, such as length, lack of uppercase letters, lowercase letters, digits, or special characters.</p> Source code in <code>backend/app/user/model.py</code> <pre><code>@field_validator('password', mode='after')\n@classmethod\ndef is_good_password(cls, value: str) -&gt; str:\n    \"\"\"\n    Validates the strength of a password after it has been assigned or modified. The\n    method ensures that the password meets specific security requirements, such as\n    minimum and maximum length, uppercase and lowercase characters, numeric\n    characters, and the inclusion of special symbols.\n\n    :param value: The password string to be validated.\n    :type value: str\n    :return: The original password string if it meets all validation criteria.\n    :rtype: str\n    :raises HTTPException: If the password fails any validation check, such as length,\n        lack of uppercase letters, lowercase letters, digits, or special characters.\n    \"\"\"\n    punctionation = [\"/\", \"$\", \"\u00a7\", \"'\", \",\", \".\", \"@\", \"(\", \")\", \"!\", \"#\", \"*\", \"?\", \"=\", \"&amp;\", \"%\", \"'\", \":\", \";\",\n                     \"&lt;\", \"&gt;\", \"+\", \"-\", \"_\"]\n\n    if len(value) &lt; 3:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Password must be at least 3 characters long.\"\n        )\n\n    if len(value) &gt; PASSWORD_MAX_LENGTH:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Password should not exceed 128 characters.\"\n        )\n\n    if not any(c.isupper() for c in value):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"There should be at least one uppercase character in password.\"\n        )\n\n    if not any(c.islower() for c in value):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"There should be at least one lowercase character in password.\"\n        )\n\n    if not any(c.isdigit() for c in value):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"There should be at least one digit in password.\"\n        )\n\n    if not any(c in punctionation for c in value):\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"There should be at least one special character in password.\"\n        )\n\n    return value\n</code></pre>"},{"location":"backend/api/models/user/#app.user.model.EnUser.is_mail_address","title":"<code>is_mail_address(value)</code>  <code>classmethod</code>","text":"<p>Validates and ensures the provided email address is in a valid format. This function checks whether the given string contains the '@' symbol, indicating it is properly structured as an email address. If the validation fails, an HTTPException is raised with an appropriate status code and detail message.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>The email address to be validated.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The validated email address if it is valid.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the email address does not contain the '@' symbol.</p> Source code in <code>backend/app/user/model.py</code> <pre><code>@field_validator('mail', mode='after')\n@classmethod\ndef is_mail_address(cls, value: str) -&gt; str:\n    \"\"\"\n    Validates and ensures the provided email address is in a valid format.\n    This function checks whether the given string contains the '@' symbol,\n    indicating it is properly structured as an email address. If the validation\n    fails, an HTTPException is raised with an appropriate status code and\n    detail message.\n\n    :param value: The email address to be validated.\n    :type value: str\n    :return: The validated email address if it is valid.\n    :rtype: str\n    :raises HTTPException: If the email address does not contain the '@' symbol.\n    \"\"\"\n    if value.find(\"@\") == -1:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST,\n            detail=\"Invalid mail address.\"\n        )\n    return value\n</code></pre>"},{"location":"backend/api/models/user/#app.user.model.EnUserDB","title":"<code>EnUserDB</code>","text":"<p>               Bases: <code>EnUser</code></p> <p>Represents a database model for storing user information.</p> <p>This class inherits from <code>EnUser</code> and serves as a database table for user-related data. It defines the structure of the <code>users</code> table, including various user attributes like ID, date of joining, last login, and flags for active status, superuser, and staff roles.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>int</code> <p>The unique identifier for each user.</p> <code>date_joined</code> <code>datetime | None</code> <p>The datetime when the user registered. Defaults to None.</p> <code>last_login</code> <code>datetime | None</code> <p>The last login datetime for the user. Defaults to None.</p> <code>is_active</code> <code>bool</code> <p>Whether the user account is active. Defaults to False.</p> <code>is_superuser</code> <code>bool</code> <p>Whether the user has superuser privileges. Defaults to False.</p> <code>is_staff</code> <code>bool</code> <p>Whether the user is part of the staff. Defaults to False.</p> Source code in <code>backend/app/user/model.py</code> <pre><code>class EnUserDB(EnUser, table=True):\n    \"\"\"\n    Represents a database model for storing user information.\n\n    This class inherits from `EnUser` and serves as a database table\n    for user-related data. It defines the structure of the `users`\n    table, including various user attributes like ID, date of joining,\n    last login, and flags for active status, superuser, and staff roles.\n\n    :ivar id: The unique identifier for each user.\n    :type id: int\n    :ivar date_joined: The datetime when the user registered. Defaults to None.\n    :type date_joined: datetime | None\n    :ivar last_login: The last login datetime for the user. Defaults to None.\n    :type last_login: datetime | None\n    :ivar is_active: Whether the user account is active. Defaults to False.\n    :type is_active: bool\n    :ivar is_superuser: Whether the user has superuser privileges. Defaults to False.\n    :type is_superuser: bool\n    :ivar is_staff: Whether the user is part of the staff. Defaults to False.\n    :type is_staff: bool\n    \"\"\"\n    __tablename__ = \"users\"\n\n    id: int = Field(default=None, primary_key=True, index=True)\n    date_joined: datetime | None = Field(default=None)\n    last_login: datetime | None = Field(default=None)\n    is_active: bool = Field(default=False)\n    is_superuser: bool = Field(default=False)\n    is_staff: bool = Field(default=False)\n</code></pre>"},{"location":"backend/api/models/user/#app.user.model.EnUserUpdate","title":"<code>EnUserUpdate</code>","text":"<p>               Bases: <code>EnUser</code></p> <p>Represents an update to an EnUser.</p> <p>This class serves as a model for updating an existing user's details in the system. It extends the <code>EnUser</code> class, inheriting its attributes and adding optional fields specific to updating a user's information. Each attribute can be set to None if the corresponding field is not being updated.</p> <p>Attributes:</p> Name Type Description <code>username</code> <code>str | None</code> <p>Optional updated username for the user.</p> <code>firstname</code> <code>str | None</code> <p>Optional updated first name for the user.</p> <code>lastname</code> <code>str | None</code> <p>Optional updated last name for the user.</p> <code>password</code> <code>str | None</code> <p>Optional updated password for the user.</p> <code>mail</code> <code>str | None</code> <p>Optional updated email address for the user.</p> Source code in <code>backend/app/user/model.py</code> <pre><code>class EnUserUpdate(EnUser):\n    \"\"\"\n    Represents an update to an EnUser.\n\n    This class serves as a model for updating an existing user's details in the\n    system. It extends the `EnUser` class, inheriting its attributes and adding\n    optional fields specific to updating a user's information. Each attribute can\n    be set to None if the corresponding field is not being updated.\n\n    :ivar username: Optional updated username for the user.\n    :type username: str | None\n    :ivar firstname: Optional updated first name for the user.\n    :type firstname: str | None\n    :ivar lastname: Optional updated last name for the user.\n    :type lastname: str | None\n    :ivar password: Optional updated password for the user.\n    :type password: str | None\n    :ivar mail: Optional updated email address for the user.\n    :type mail: str | None\n    \"\"\"\n    username: str | None = None\n    firstname: str | None = None\n    lastname: str | None = None\n    password: str | None = None\n    mail: str | None = None\n</code></pre>"},{"location":"backend/api/router/admin/","title":"admin","text":""},{"location":"backend/api/router/admin/#app.admin.router.root","title":"<code>root()</code>  <code>async</code>","text":"<p>Handles the root route of the admin router.</p> <p>This endpoint raises an HTTPException with a 418 status code and a detail message indicating \"I'm a teapot.\" This method does not return any content as it is designed to only trigger the exception. The implementation is aligned with the HTTP 418 status code, which is used as an Easter egg for humorous purposes.</p> <p>Returns:</p> Type Description <code>NoneType</code> <p>None</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Always raised with status code 418 and detail \"I'm a teapot\".</p> Source code in <code>backend/app/admin/router.py</code> <pre><code>@admin_router.get(\"/\")\nasync def root():\n    \"\"\"\n    Handles the root route of the admin router.\n\n    This endpoint raises an HTTPException with a 418 status code and a detail message\n    indicating \"I'm a teapot.\" This method does not return any content as it is designed\n    to only trigger the exception. The implementation is aligned with the HTTP 418 status\n    code, which is used as an Easter egg for humorous purposes.\n\n    :return: None\n    :rtype: NoneType\n    :raises HTTPException: Always raised with status code 418 and detail \"I'm a teapot\".\n    \"\"\"\n    raise HTTPException(status_code=418, detail=\"I'm a teapot.\")\n</code></pre>"},{"location":"backend/api/router/oep/","title":"oep","text":""},{"location":"backend/api/router/oep/#app.oep.router.get_local_oep_data","title":"<code>get_local_oep_data(token, block_schema, simulation_year)</code>  <code>async</code>","text":"<p>Fetches local OEP (Open Energy Platform) data based on the provided schema type and simulation year.</p> <p>This function authenticates the user, validates the block schema, and reads simulation data for the requested year from local storage.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>Authentication token required to access the endpoint</p> required <code>block_schema</code> <code>str</code> <p>Schema type of the data to retrieve</p> required <code>simulation_year</code> <code>int</code> <p>Year of the simulation data to fetch</p> required <p>Returns:</p> Type Description <code>DataResponse</code> <p>A DataResponse object containing the data items, total count, and a success flag</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If token is invalid, if the block schema is not found, or if there are issues with the requested data</p> Source code in <code>backend/app/oep/router.py</code> <pre><code>@oep_router.get(\"/local_data/{block_schema}/{simulation_year}\")\nasync def get_local_oep_data(token: Annotated[str, Depends(oauth2_scheme)], block_schema: str,\n                             simulation_year: int) -&gt; DataResponse:\n    \"\"\"\n    Fetches local OEP (Open Energy Platform) data based on the provided schema type and simulation year.\n\n    This function authenticates the user, validates the block schema,\n    and reads simulation data for the requested year from local storage.\n\n    :param token: Authentication token required to access the endpoint\n    :param block_schema: Schema type of the data to retrieve\n    :param simulation_year: Year of the simulation data to fetch\n    :return: A DataResponse object containing the data items, total count, and a success flag\n    :raises HTTPException: If token is invalid, if the block schema is not found, or\n                           if there are issues with the requested data\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    if simulation_year not in [2025, 2030, 2035, 2040, 2045, 2050]:\n        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=\"Invalid simulation year.\")\n\n    oep_type = OepTypes[block_schema]\n\n    root_path = os.path.abspath(\n        os.path.join(os.getcwd(), \"data\", \"oep\", oep_type.value[1].lower())\n    )\n\n    port_data_path = os.path.join(root_path, \"ports\", f\"{block_schema}.csv\")\n    parameter_data_path = os.path.join(root_path, \"parameter\", f\"{block_schema}.csv\")\n    timeseries_data_path = os.path.join(root_path, \"timeseries\", f\"{block_schema}.csv\")\n\n    # Einlesen der Portdaten\n    if not os.path.isfile(port_data_path):\n        raise HTTPException(status_code=404, detail=\"File with port specification not found.\")\n    else:\n        with open(port_data_path, \"r\") as f:\n            ports_data = pd.read_csv(f, index_col=0, decimal=\",\", delimiter=\";\").to_dict(orient=\"records\")\n\n    # Einlesen der Parameter\n    if not os.path.isfile(parameter_data_path):\n        raise HTTPException(status_code=404, detail=\"File with parameter data not found.\")\n    else:\n        with open(parameter_data_path, \"r\") as f:\n            parameter_data = pd.read_csv(f, index_col=0, decimal=\",\", delimiter=\";\").to_dict(orient=\"index\")\n\n    # Einlesen der Zeitreihe#\n    if (oep_type.value[1].lower() == \"sink\" or oep_type.value[1].lower() == \"source\") and not oep_type.value[0].lower() == \"electricity_export\":\n        # print(f\"timeseries_data_path: {timeseries_data_path}\")\n        if not os.path.isfile(timeseries_data_path):\n            raise HTTPException(status_code=404, detail=\"File with timeseries not found.\")\n        else:\n            with open(timeseries_data_path, \"r\") as f:\n                timeseries_data = list(pd.read_csv(f, index_col=0, decimal=\",\", delimiter=\";\").loc[:, \"data\"])\n    else:\n        timeseries_data = None\n\n    parameter_year_select: dict = parameter_data[simulation_year]\n\n    # Hier hat man die Parameter f\u00fcr das ausgew\u00e4hlte Jahr eingelesen\n    param_keys = parameter_year_select.keys()\n\n    # ep_costs berechnen f\u00fcr den Flow\n    if \"investment_costs\" in param_keys and \\\n            \"interest_rate\" in param_keys and \\\n            \"operating_costs\" in param_keys and \\\n            \"lifetime\" in param_keys:\n        # Calculate EPC costs for flow\n        capex = parameter_year_select[\"investment_costs\"]\n        opex = parameter_year_select[\"investment_costs\"] * (parameter_year_select[\"operating_costs\"] / 100)\n        interest_rate = parameter_year_select[\"interest_rate\"] / 100\n\n        annuity = economics.annuity(\n            capex=capex,\n            wacc=interest_rate,\n            n=parameter_year_select[\"lifetime\"]\n        )\n        flow_ep_costs = annuity + opex\n    else:\n        flow_ep_costs = None\n\n    # Anlegen der Flow-Daten mit Zeitreihe oder ohne\n    if timeseries_data is not None:\n        flow_data = {\n            \"fix\": timeseries_data\n        }\n    else:\n        flow_data = {}\n\n    if flow_ep_costs is not None:\n        flow_data[\"investment\"] = {\n            \"ep_costs\": flow_ep_costs\n        }\n\n    # flow-daten die wichtig sind, zum Filtern bei der storage-daten\n    flow_data_keys = [\"nominal_value\",\n                      \"variable_costs\",\n                      \"min\",\n                      \"max\",\n                      \"fix\"\n                      \"positive_gradient_limit\",\n                      \"negative_gradient_limit\",\n                      \"full_load_time_max\",\n                      \"full_load_time_min\",\n                      \"integer\",\n                      \"nonconvex\",\n                      \"fixed_costs\",\n                      \"age\",\n                      \"lifetime\"]\n\n    # L\u00f6schen der nicht relevanten Eintr\u00e4ge\n    parameter_ys_cleaned = parameter_year_select\n    for key in [\"investment_costs\", \"operating_costs\", \"lifetime\", \"interest_rate\", \"efficiency_el\",\n                \"efficiency_th\"]:\n        if key in parameter_ys_cleaned.keys():\n            del parameter_ys_cleaned[key]\n\n    for key in flow_data_keys:\n        if key in parameter_ys_cleaned.keys() and not key in flow_data.keys():\n            flow_data[key] = parameter_ys_cleaned[key]\n            del parameter_ys_cleaned[key]\n        elif key in parameter_ys_cleaned.keys() and key in flow_data.keys():\n            del parameter_ys_cleaned[key]\n\n    # TODO: how do i write the flow data in the right port? Sink/Source/Rest\n    for port in ports_data:\n        del port[\"investment\"]\n\n        if ((oep_type.value[1].lower() == \"sink\" and port[\"type\"] == \"input\") or (\n                oep_type.value[1].lower() == \"source\" and port[\"type\"] == \"output\")) and flow_data:\n            # Sink / Source\n            port[\"flow_data\"] = flow_data\n        elif port[\"type\"] == \"output\" and port[\"name\"] == \"electricity\":\n            port[\"flow_data\"] = flow_data\n        else:\n            print(f\"Port: {port}\")\n\n    if \"efficiencey_el\" in param_keys and port[\"name\"] == \"electricity\" and port[\"type\"] == \"output\":\n        port[\"efficiency\"] = parameter_year_select[\"efficiency_el\"]\n\n    if \"efficiencey_th\" in param_keys and port[\"name\"] == \"heat\" and port[\"type\"] == \"output\":\n        port[\"efficiency\"] = parameter_year_select[\"efficiency_th\"]\n\n    # Ab hier starten die Sonderw\u00fcnsche\n    sorted_port_data = {\n        \"inputs\": [],\n        \"outputs\": []\n    }\n\n    for item in ports_data:\n        tmp_type = item[\"type\"]\n        del item[\"type\"]\n\n        if tmp_type == \"input\":\n            sorted_port_data[\"inputs\"].append(item)\n        elif tmp_type == \"output\":\n            sorted_port_data[\"outputs\"].append(item)\n\n    return_data = [{\n        \"node_data\": parameter_ys_cleaned,\n        \"ports_data\": sorted_port_data\n    }]\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=return_data,\n            totalCount=len(return_data)\n        ),\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/oep/#app.oep.router.get_local_oep_schemas","title":"<code>get_local_oep_schemas(token, block_type)</code>  <code>async</code>","text":"<p>This endpoint retrieves a list of local schemas that match the provided block type. It accepts a user authentication token to ensure the request is authenticated. The schemas are filtered from a predefined list based on the specified block type.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>An authentication token is required to request authorization.</p> required <code>block_type</code> <code>str</code> <p>The type of block to filter the schemas by.</p> required <p>Returns:</p> Type Description <code>DataResponse</code> <p>A DataResponse object containing the list of matching schemas and a success indicator.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Raises a 401 HTTP status code exception if the user is unauthorized or the token is invalid.</p> Source code in <code>backend/app/oep/router.py</code> <pre><code>@oep_router.get(\"/local_schemas/{block_type}\")\nasync def get_local_oep_schemas(token: Annotated[str, Depends(oauth2_scheme)], block_type: str) -&gt; DataResponse:\n    \"\"\"\n    This endpoint retrieves a list of local schemas that match the provided\n    block type. It accepts a user authentication token to ensure the request\n    is authenticated. The schemas are filtered from a predefined list based\n    on the specified block type.\n\n    :param token: An authentication token is required to request authorization.\n    :param block_type: The type of block to filter the schemas by.\n    :return: A DataResponse object containing the list of matching schemas and\n        a success indicator.\n    :raises HTTPException: Raises a 401 HTTP status code exception if the user\n        is unauthorized or the token is invalid.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    schema_list = []\n    for entry in OepTypes:\n        # print(f\"{entry.name} ==&gt; {entry.value[1]}\")\n        if entry.value[1] == block_type.lower():\n            schema_list.append(entry.name)\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=schema_list,\n            totalCount=len(schema_list)\n        ),\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/oep/#app.oep.router.get_oep_client","title":"<code>get_oep_client()</code>","text":"<p>Provides a generator function to yield an instance of the OepClient class.</p> <p>This function accesses environment variables to retrieve the necessary credentials and configurations required for creating an OepClient instance. It uses <code>os.getenv</code> to get the <code>OEP_TOKEN</code> and <code>OEP_TOPIC</code> values for authentication and topic management, respectively. The OepClient instance is yielded, allowing the caller to manage resources appropriately.</p> <p>Returns:</p> Type Description <code>OepClient</code> <p>OepClient: A generator that yields an instance of the OepClient class configured with a token and a default schema retrieved from the environment variables.</p> Source code in <code>backend/app/oep/router.py</code> <pre><code>def get_oep_client():\n    \"\"\"\n    Provides a generator function to yield an instance of the OepClient class.\n\n    This function accesses environment variables to retrieve the necessary\n    credentials and configurations required for creating an OepClient instance.\n    It uses `os.getenv` to get the `OEP_TOKEN` and `OEP_TOPIC` values for\n    authentication and topic management, respectively. The OepClient instance is\n    yielded, allowing the caller to manage resources appropriately.\n\n    :return:\n        OepClient: A generator that yields an instance of the OepClient class\n        configured with a token and a default schema retrieved from the\n        environment variables.\n    :rtype: OepClient\n    \"\"\"\n    yield OepClient(\n        token=os.getenv(\"OEP_TOKEN\"),\n        default_schema=os.getenv(\"OEP_TOPIC\")\n    )\n</code></pre>"},{"location":"backend/api/router/oep/#app.oep.router.get_oep_data","title":"<code>get_oep_data(token, table_name, oep_cli=Depends(get_oep_client))</code>  <code>async</code>","text":"<p>Get OEP Data from a specified table.</p> <p>This endpoint retrieves data from a specified table using the provided <code>table_name</code>. The OEP client instance is used to interact with the database, and token-based authentication is required for accessing the endpoint. The data response includes the retrieved items, their total count, and a success status indicator.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>A bearer token for authentication.</p> required <code>table_name</code> <code>str</code> <p>The name of the table to retrieve data from.</p> required <code>oep_cli</code> <code>OepClient</code> <p>An instance of the OEP client to interact with the backend database. Dependency injection.</p> <code>Depends(get_oep_client)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>A <code>DataResponse</code> object containing the data, total count, and success status.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the token is invalid or not provided.</p> Source code in <code>backend/app/oep/router.py</code> <pre><code>@oep_router.get(\"/{table_name}\")\nasync def get_oep_data(token: Annotated[str, Depends(oauth2_scheme)], table_name: str,\n                       oep_cli: OepClient = Depends(get_oep_client)) -&gt; DataResponse:\n    \"\"\"\n    Get OEP Data from a specified table.\n\n    This endpoint retrieves data from a specified table using the provided `table_name`.\n    The OEP client instance is used to interact with the database, and token-based\n    authentication is required for accessing the endpoint. The data response includes\n    the retrieved items, their total count, and a success status indicator.\n\n    :param token: A bearer token for authentication.\n    :type token: str\n    :param table_name: The name of the table to retrieve data from.\n    :type table_name: str\n    :param oep_cli: An instance of the OEP client to interact with the backend database. Dependency injection.\n    :type oep_cli: OepClient\n    :return: A `DataResponse` object containing the data, total count, and success status.\n    :rtype: DataResponse\n\n    :raises HTTPException: If the token is invalid or not provided.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    data = oep_cli.select_from_table(table=table_name)\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=data,\n            totalCount=len(data)\n        ),\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/oep/#app.oep.router.get_oep_metadata","title":"<code>get_oep_metadata(token, table_name, oep_cli=Depends(get_oep_client))</code>  <code>async</code>","text":"<p>Retrieve metadata for a specific table.</p> <p>This endpoint fetches metadata for the provided table name using the OEP client. It requires authentication via the provided token. If the token is invalid or not provided, an authentication error will be raised.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The authentication token obtained via the OAuth2 scheme.</p> required <code>table_name</code> <code>str</code> <p>The name of the table for which metadata is to be retrieved.</p> required <code>oep_cli</code> <code>OepClient</code> <p>Instance of the OepClient dependency for interacting with the OEP API. Dependency injection.</p> <code>Depends(get_oep_client)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>A DataResponse containing the retrieved metadata and its total count.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the token is invalid or not provided.</p> Source code in <code>backend/app/oep/router.py</code> <pre><code>@oep_router.get(\"/meta/{table_name}\")\nasync def get_oep_metadata(token: Annotated[str, Depends(oauth2_scheme)], table_name: str,\n                           oep_cli: OepClient = Depends(get_oep_client)) -&gt; DataResponse:\n    \"\"\"\n    Retrieve metadata for a specific table.\n\n    This endpoint fetches metadata for the provided table name using the OEP client.\n    It requires authentication via the provided token. If the token is invalid or\n    not provided, an authentication error will be raised.\n\n    :param token: The authentication token obtained via the OAuth2 scheme.\n    :param table_name: The name of the table for which metadata is to be retrieved.\n    :param oep_cli: Instance of the OepClient dependency for interacting with the OEP API. Dependency injection.\n    :return: A DataResponse containing the retrieved metadata and its total count.\n    :rtype: DataResponse\n\n    :raises HTTPException: If the token is invalid or not provided.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    data = oep_cli.get_metadata(table=table_name)\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=data,\n            totalCount=len(data)\n        ),\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/project/","title":"project","text":""},{"location":"backend/api/router/project/#app.project.router.create_project","title":"<code>create_project(token, project_data, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Creates a new project and stores it in the database. The function checks the authentication token, decodes it, retrieves the authenticated user's details, and associates the project data with the user. The new project is saved to the database, and a success response is returned.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>Authentication token obtained from the user. Used to validate user identity and permission.</p> required <code>project_data</code> <code>EnProject</code> <p>Project data containing information required to create a new project in the database.</p> required <code>db</code> <code>Session</code> <p>Database session dependency. Used for interacting with the database. Dependency injection.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>An object containing a success message indicating the project has been created.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Raised with a 401 status code if the user is not authenticated due to a missing or invalid token.</p> Source code in <code>backend/app/project/router.py</code> <pre><code>@projects_router.post(\"/\", response_model=MessageResponse)\nasync def create_project(token: Annotated[str, Depends(oauth2_scheme)], project_data: EnProject,\n                         db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Creates a new project and stores it in the database. The function checks\n    the authentication token, decodes it, retrieves the authenticated user's\n    details, and associates the project data with the user. The new project is\n    saved to the database, and a success response is returned.\n\n    :param token: Authentication token obtained from the user. Used to validate\n                  user identity and permission.\n    :type token: Str\n    :param project_data: Project data containing information required to create a\n                         new project in the database.\n    :type project_data: EnProject\n    :param db: Database session dependency. Used for interacting with the database. Dependency injection.\n    :type db: Session\n    :raises HTTPException: Raised with a 401 status code if the user is not\n                           authenticated due to a missing or invalid token.\n    :return: An object containing a success message indicating the project has\n             been created.\n    :rtype: MessageResponse\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    token_data = decode_token(token)\n    statement = select(EnUserDB).where(EnUserDB.username == token_data[\"username\"])\n    token_user = db.exec(statement).first()\n    project = EnProjectDB(**project_data.model_dump())\n\n    # set auxiliary data\n    project.user_id = token_user.id\n    project.date_created = datetime.now()\n\n    db.add(project)\n    db.commit()\n\n    return MessageResponse(\n        data=\"Project created.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/project/#app.project.router.delete_project","title":"<code>delete_project(token, project_id, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Deletes a project and all associated scenarios from the database.</p> <p>This endpoint allows the authenticated user to delete a specified project and its associated scenarios, provided they have the necessary authorization and ownership. The function validates the user's token and ownership of the specified project before deleting it and committing the changes to the database.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>A string representing the user's authentication token.</p> required <code>project_id</code> <code>int</code> <p>Integer representing the ID of the project to be deleted.</p> required <code>db</code> <code>Session</code> <p>The session instance for interacting with the database. Dependency injection.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A MessageResponse object containing a confirmation message and the success status of the operation.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the user is not authenticated or if they are not authorized to delete the project.</p> <code>HTTPException</code> <p>If the project is not found in the database.</p> <code>HTTPException</code> <p>If the project is not owned by the user.</p> <code>HTTPException</code> <p>If there are associated scenarios in the project.</p> Source code in <code>backend/app/project/router.py</code> <pre><code>@projects_router.delete(\"/{project_id}\", response_model=MessageResponse)\nasync def delete_project(token: Annotated[str, Depends(oauth2_scheme)], project_id: int,\n                         db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Deletes a project and all associated scenarios from the database.\n\n    This endpoint allows the authenticated user to delete a specified project\n    and its associated scenarios, provided they have the necessary authorization\n    and ownership. The function validates the user's token and ownership of the\n    specified project before deleting it and committing the changes to the database.\n\n    :param token: A string representing the user's authentication token.\n    :type token: Str\n    :param project_id: Integer representing the ID of the project to be deleted.\n    :type project_id: Int\n    :param db: The session instance for interacting with the database. Dependency injection.\n    :type db: Session\n    :return: A MessageResponse object containing a confirmation message and the\n             success status of the operation.\n    :rtype: MessageResponse\n    :raises HTTPException: If the user is not authenticated or if they are not authorized to delete the project.\n    :raises HTTPException: If the project is not found in the database.\n    :raises HTTPException: If the project is not owned by the user.\n    :raises HTTPException: If there are associated scenarios in the project.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    if not validate_project_owner(project_id, token, db):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    project = db.get(EnProjectDB, project_id)\n\n    scenarios = db.exec(select(EnScenarioDB).where(EnScenarioDB.project_id == project.id))\n    for scenario in scenarios:\n        db.delete(scenario)\n\n    db.delete(project)\n    db.commit()\n\n    return MessageResponse(\n        data=\"Project deleted and all scenarios deleted.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/project/#app.project.router.read_project","title":"<code>read_project(project_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Retrieves project details by the given project ID. This endpoint fetches details about a project from the database after validating the provided authentication token and confirming ownership of the project by the authenticated user.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The unique identifier of the project to retrieve.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>Authentication token provided by the user for accessing the endpoint.</p> required <code>db</code> <code>Session</code> <p>Database session used for accessing stored data. Dependency injection.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>The response containing project data wrapped in a structured response model.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If authentication fails or if the user is not authorized to access the specified project.</p> Source code in <code>backend/app/project/router.py</code> <pre><code>@projects_router.get(\"/{project_id}\", response_model=DataResponse)\nasync def read_project(project_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                       db: Session = Depends(get_db_session)) -&gt; DataResponse:\n    \"\"\"\n    Retrieves project details by the given project ID. This endpoint fetches details about a\n    project from the database after validating the provided authentication token and confirming\n    ownership of the project by the authenticated user.\n\n    :param project_id: The unique identifier of the project to retrieve.\n    :type project_id: Int\n    :param token: Authentication token provided by the user for accessing the endpoint.\n    :type token: Str\n    :param db: Database session used for accessing stored data. Dependency injection.\n    :type db: Session\n    :return: The response containing project data wrapped in a structured response model.\n    :rtype: DataResponse\n    :raises HTTPException: If authentication fails or if the user is not authorized to access\n        the specified project.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    if not validate_project_owner(project_id, token, db):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=[db.get(EnProjectDB, project_id).get_return_data()],\n            totalCount=1,\n        ),\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/project/#app.project.router.read_projects","title":"<code>read_projects(token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Fetches and returns a list of projects associated with the authenticated user. The function validates the provided token, retrieves the associated user details, and fetches all projects corresponding to the user. The result includes details of all retrieved projects wrapped in a standardized response.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The authentication token is extracted from the request.</p> required <code>db</code> <code>Session</code> <p>The database session dependency used to execute queries. Dependency injection.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>A standardized response containing a list of projects for the authenticated user, along with the total count of projects.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the provided token is missing or invalid.</p> Source code in <code>backend/app/project/router.py</code> <pre><code>@projects_router.get(\"s/\", response_model=DataResponse)\nasync def read_projects(token: Annotated[str, Depends(oauth2_scheme)],\n                        db: Session = Depends(get_db_session)) -&gt; DataResponse:\n    \"\"\"\n    Fetches and returns a list of projects associated with the authenticated user.\n    The function validates the provided token, retrieves the associated user\n    details, and fetches all projects corresponding to the user. The result\n    includes details of all retrieved projects wrapped in a standardized response.\n\n    :param token: The authentication token is extracted from the request.\n    :type token: Str\n    :param db: The database session dependency used to execute queries. Dependency injection.\n    :type db: Session\n    :return: A standardized response containing a list of projects for\n        the authenticated user, along with the total count of projects.\n    :rtype: DataResponse\n    :raises HTTPException: If the provided token is missing or invalid.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    token_data = decode_token(token)\n    statement = select(EnUserDB).where(EnUserDB.username == token_data[\"username\"])\n    token_user = db.exec(statement).first()\n\n    statement = select(EnProjectDB).where(EnProjectDB.user_id == token_user.id)\n    projects = db.exec(statement)\n\n    response_data = []\n    for project in projects:\n        response_data.append(project.get_return_data())\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=response_data,\n            totalCount=len(response_data)\n        ),\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/project/#app.project.router.update_project","title":"<code>update_project(token, project_id, project_data, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Updates the details of an existing project. This endpoint allows authenticated and authorized users to modify the properties of a given project. The function fetches the project by its ID, validates the user's ownership of the project, and updates the provided information in the database.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The authentication token of the user making the request.</p> required <code>project_id</code> <code>int</code> <p>The unique identifier of the project to be updated.</p> required <code>project_data</code> <code>EnProjectUpdate</code> <p>The new data to update the project with.</p> required <code>db</code> <code>Session</code> <p>The database session used for querying and updating project details. Dependency injection.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A <code>MessageResponse</code> object indicating the success of the operation.</p> Source code in <code>backend/app/project/router.py</code> <pre><code>@projects_router.patch(\"/{project_id}\", response_model=MessageResponse)\nasync def update_project(token: Annotated[str, Depends(oauth2_scheme)], project_id: int, project_data: EnProjectUpdate,\n                         db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Updates the details of an existing project. This endpoint allows authenticated\n    and authorized users to modify the properties of a given project. The function\n    fetches the project by its ID, validates the user's ownership of the project,\n    and updates the provided information in the database.\n\n    :param token: The authentication token of the user making the request.\n    :type token: Str\n    :param project_id: The unique identifier of the project to be updated.\n    :type project_id: Int\n    :param project_data: The new data to update the project with.\n    :type project_data: EnProjectUpdate\n    :param db: The database session used for querying and updating project details. Dependency injection.\n    :type db: Session\n    :return: A `MessageResponse` object indicating the success of the operation.\n    :rtype: MessageResponse\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    if not validate_project_owner(project_id, token, db):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    db_project = db.get(EnProjectDB, project_id)\n    if not db_project:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Project not found.\")\n\n    new_project_data = project_data.model_dump(exclude_none=True)\n\n    db_project.sqlmodel_update(new_project_data)\n    db_project.date_updated = datetime.now()\n\n    db.add(db_project)\n    db.commit()\n    db.refresh(db_project)\n\n    return MessageResponse(\n        data=\"Project Updated.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/project/#app.project.router.validate_project_owner","title":"<code>validate_project_owner(project_id, token, db)</code>","text":"<p>Validates whether the user associated with a given token is the owner of a project identified by the provided project_id. Verifies the token's authenticity, fetches the project from the database, and compares its ownership details to ensure the user has the necessary permissions to access or modify the project.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>ID of the project whose ownership is being validated</p> required <code>token</code> <code>str</code> <p>JWT token provided for authentication and identifying the user</p> required <code>db</code> <code>Session</code> <p>Database session object used to query project and user information. Dependency injection.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Returns True if the token user is the owner of the project, otherwise raises an exception</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the project is not found in the database (404)</p> <code>HTTPException</code> <p>If the user associated with the token does not own the project (403)</p> Source code in <code>backend/app/project/router.py</code> <pre><code>def validate_project_owner(project_id: int, token: str, db):\n    \"\"\"\n    Validates whether the user associated with a given token is the owner of a project\n    identified by the provided project_id. Verifies the token's authenticity, fetches\n    the project from the database, and compares its ownership details to ensure the user\n    has the necessary permissions to access or modify the project.\n\n    :param project_id: ID of the project whose ownership is being validated\n    :type project_id: int\n    :param token: JWT token provided for authentication and identifying the user\n    :type token: str\n    :param db: Database session object used to query project and user information. Dependency injection.\n    :type db: Session\n    :return: Returns True if the token user is the owner of the project, otherwise raises an exception\n    :rtype: bool\n\n    :raises HTTPException: If the project is not found in the database (404)\n    :raises HTTPException: If the user associated with the token does not own the project (403)\n    \"\"\"\n    # Get Database-Session and token-data\n    token_data = decode_token(token)\n\n    # Get User-data from the Database\n    statement = select(EnUserDB).where(EnUserDB.username == token_data[\"username\"])\n    token_user = db.exec(statement).first()\n\n    # get the mentioned project-data\n    project = db.get(EnProjectDB, project_id)\n    if not project:\n        raise HTTPException(status_code=404, detail=\"Project not found\")\n\n    # check if the project_id and the token_id are the same and return the value\n    if project.user_id == token_user.id:\n        return True\n    else:\n        raise HTTPException(status_code=403, detail=\"Permission denied\")\n</code></pre>"},{"location":"backend/api/router/results/","title":"results","text":""},{"location":"backend/api/router/results/#app.results.router.get_results","title":"<code>get_results(simulation_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Retrieve the results of a simulation based on the given simulation id. This endpoint checks the current status of the simulation and provides appropriate responses based on that status. If the simulation is finished, the results are returned. If the status indicates in-progress, failed, or canceled, it responds with corresponding error messages. Errors are also returned if the simulation does not exist or if the request is unauthenticated.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_id</code> <code>int</code> <p>The unique identifier of the simulation.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The OAuth2 token for authentication.</p> required <code>db</code> <code>Session</code> <p>Database session dependency, used to query the database.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>ResultResponse | ErrorResponse</code> <p>A ResultResponse object containing simulation results if successful, or an ErrorResponse object containing error details if an error occurs.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the request is unauthenticated.</p> <code>HTTPException</code> <p>If the simulation does not exist.</p> <code>HTTPException</code> <p>If the simulation status is unknown.</p> Source code in <code>backend/app/results/router.py</code> <pre><code>@results_router.get(\"/{simulation_id}\", response_model=ResultResponse | ErrorResponse)\nasync def get_results(simulation_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                      db: Session = Depends(get_db_session)) -&gt; ResultResponse | ErrorResponse:\n    \"\"\"\n    Retrieve the results of a simulation based on the given simulation id. This endpoint checks\n    the current status of the simulation and provides appropriate responses based on that status.\n    If the simulation is finished, the results are returned. If the status indicates in-progress,\n    failed, or canceled, it responds with corresponding error messages. Errors are also returned\n    if the simulation does not exist or if the request is unauthenticated.\n\n    :param simulation_id: The unique identifier of the simulation.\n    :type simulation_id: int\n    :param token: The OAuth2 token for authentication.\n    :type token: str\n    :param db: Database session dependency, used to query the database.\n    :type db: Session\n    :return: A ResultResponse object containing simulation results if successful, or an\n             ErrorResponse object containing error details if an error occurs.\n    :rtype: ResultResponse | ErrorResponse\n\n    :raises HTTPException: If the request is unauthenticated.\n    :raises HTTPException: If the simulation does not exist.\n    :raises HTTPException: If the simulation status is unknown.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    simulation = db.get(EnSimulationDB, simulation_id)\n    if not simulation:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Simulation not found\")\n\n    if simulation.status == Status.STARTED.value:\n        return ErrorResponse(\n            errors=[ErrorModel(\n                code=status.HTTP_425_TOO_EARLY,\n                message=f\"Simulation {simulation_id} has not finished yet.\"\n            )]\n        )\n    elif simulation.status == Status.FAILED.value:\n        # TODO: Bessere R\u00fcckgabe von Fehlern bei \"failed\"\n        return ErrorResponse(\n            errors=[ErrorModel(\n                code=status.HTTP_409_CONFLICT,\n                message=f\"Simulation {simulation_id} has failed.\"\n            )]\n        )\n    elif simulation.status == Status.CANCELED.value:\n        return ErrorResponse(\n            errors=[ErrorModel(\n                code=status.HTTP_409_CONFLICT,\n                message=f\"Simulation {simulation_id} has cancelled.\"\n            )]\n        )\n    elif simulation.status == Status.FINISHED.value:\n        return ResultResponse(\n            data=get_results_from_dump(simulation.id, db),\n            success=True\n        )\n    else:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Simulation unknown status.\")\n</code></pre>"},{"location":"backend/api/router/results/#app.results.router.get_results_from_dump","title":"<code>get_results_from_dump(simulation_id, db)</code>","text":"<p>Fetches results from a simulation dump file based on the simulation ID. This function retrieves the energy system data from a serialized dump file stored in the local directory based on a simulation token. It processes the dump files, restores the energy system, and aggregates result sequences for each identified energy bus into structured data. The results are returned in the form of a ResultDataModel.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_id</code> <code>int</code> <p>ID of the simulation for which results are being fetched</p> required <code>db</code> <code>Session</code> <p>Database session used to query the simulation information</p> required <p>Returns:</p> Type Description <code>ResultDataModel</code> <p>A ResultDataModel containing the result data extracted from the dump and the total count of data entries</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Raised with status code 404 if the simulation ID does not exist or if the required dump file is not found</p> Source code in <code>backend/app/results/router.py</code> <pre><code>def get_results_from_dump(simulation_id: int, db: Session) -&gt; ResultDataModel:\n    \"\"\"\n    Fetches results from a simulation dump file based on the simulation ID. This function\n    retrieves the energy system data from a serialized dump file stored in the local directory\n    based on a simulation token. It processes the dump files, restores the energy system,\n    and aggregates result sequences for each identified energy bus into structured data.\n    The results are returned in the form of a ResultDataModel.\n\n    :param simulation_id: ID of the simulation for which results are being fetched\n    :type simulation_id: int\n    :param db: Database session used to query the simulation information\n    :type db: Session\n    :return: A ResultDataModel containing the result data extracted from the dump and the\n        total count of data entries\n    :rtype: ResultDataModel\n\n    :raises HTTPException: Raised with status code 404 if the simulation ID does not exist\n        or if the required dump file is not found\n    \"\"\"\n    simulation = db.get(EnSimulationDB, simulation_id)\n\n    if not simulation:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Simulation not found\")\n\n    simulation_token = simulation.sim_token\n    simulations_path = os.path.abspath(os.path.join(os.getenv(\"LOCAL_DATADIR\"), simulation_token, \"dump\"))\n    # print(f\"simulations_path: {simulations_path}\")\n\n    if not os.path.isfile(os.path.join(simulations_path, \"oemof_es.dump\")):\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Dumpfile not found\")\n\n    es = solph.EnergySystem()\n    es.restore(\n        dpath=simulations_path,\n        filename='oemof_es.dump'\n    )\n\n    busses = []\n    result_data = []\n\n    for node in es.nodes:\n        if isinstance(node, solph.Bus):\n            print(f\"Bus: {node}\")\n            busses.append(node)\n\n    # TODO: Dat muss nochmal \u00fcberdacht werden. Schon gut, aber irgendwie weird.\n    for bus in busses:\n        graph_data = []\n\n        for t, g in solph.views.node(es.results[\"main\"], node=bus)[\"sequences\"].items():\n            print(f\"G:{len(g)}\")\n            idx_asset = abs(t[0].index(bus) - 1)\n            if idx_asset &gt; 0:\n                time_series = EnTimeSeries(\n                    name=str(t[0][1]),\n                    data=nan_to_num(g.values) * pow(-1, idx_asset)\n                )\n            else:\n                time_series = EnTimeSeries(\n                    name=str(t[0][0]),\n                    data=nan_to_num(g.values) * pow(-1, idx_asset)\n                )\n\n            graph_data.append(time_series)\n\n        bus_data: EnDataFrame = EnDataFrame(\n            name=f\"{bus}\",\n            index=es.timeindex.to_pydatetime(),\n            data=graph_data\n        )\n\n        result_data.append(bus_data)\n\n    return_data: ResultDataModel = ResultDataModel(\n        items=result_data,\n        totalCount=len(result_data),\n    )\n\n    return return_data\n</code></pre>"},{"location":"backend/api/router/scenario/","title":"scenario","text":""},{"location":"backend/api/router/scenario/#app.scenario.router.create_scenario","title":"<code>create_scenario(token, scenario_data, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Creates a new scenario and stores it in the database. The endpoint is protected and requires a valid token. It validates the ownership of the project before proceeding. This function adds a new scenario to the database and commits the changes.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>A valid authentication token to verify the user's identity.</p> required <code>scenario_data</code> <code>EnScenario</code> <p>The data object containing the scenario details.</p> required <code>db</code> <code>Session</code> <p>The database session dependency for executing queries. Dependency injection.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A response indicating the success of the scenario creation.</p> Source code in <code>backend/app/scenario/router.py</code> <pre><code>@scenario_router.post(\"/\", response_model=MessageResponse, status_code=status.HTTP_201_CREATED)\nasync def create_scenario(token: Annotated[str, Depends(oauth2_scheme)], scenario_data: EnScenario,\n                          db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Creates a new scenario and stores it in the database. The endpoint is\n    protected and requires a valid token. It validates the ownership of the\n    project before proceeding. This function adds a new scenario to the\n    database and commits the changes.\n\n    :param token: A valid authentication token to verify the user's identity.\n    :type token: Str\n    :param scenario_data: The data object containing the scenario details.\n    :type scenario_data: EnScenario\n    :param db: The database session dependency for executing queries. Dependency injection.\n    :type db: Session\n    :return: A response indicating the success of the scenario creation.\n    :rtype: MessageResponse\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    project_id = scenario_data.project_id\n\n    token_data = decode_token(token)\n    statement = select(EnUserDB).where(EnUserDB.username == token_data[\"username\"])\n    token_user = db.exec(statement).first()\n\n    if not validate_project_owner(project_id, token, db):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    scenario = EnScenarioDB(**scenario_data.model_dump())\n    scenario.user_id = token_user.id\n\n    modeling_data = json.loads(scenario_data.modeling_data)\n\n    scenario.modeling_data = modeling_data\n    scenario.energysystem = convert_gui_json_to_ensys(modeling_data)\n\n    with open(os.path.join(os.getenv(\"LOCAL_DATADIR\"), \"debug.json\"), \"wt\") as f:\n        f.write(scenario.model_dump_json())\n\n    db.add(scenario)\n    db.commit()\n\n    return MessageResponse(\n        data=\"Scenario created.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/scenario/#app.scenario.router.delete_scenario","title":"<code>delete_scenario(token, scenario_id, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Deletes a scenario by its ID for authorized users only. This endpoint ensures that the caller owns the specified scenario before performing the deletion. If the scenario exists and the authorization is confirmed, it is removed from the database, and a success message is returned.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>Access token for authentication and authorization.</p> required <code>scenario_id</code> <code>int</code> <p>Unique identifier of the scenario to be deleted.</p> required <code>db</code> <code>Session</code> <p>Database session used for querying and deleting the scenario. Dependency injection.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>MessageResponse confirming successful deletion.</p> Source code in <code>backend/app/scenario/router.py</code> <pre><code>@scenario_router.delete(\"/{scenario_id}\", response_model=MessageResponse)\nasync def delete_scenario(token: Annotated[str, Depends(oauth2_scheme)], scenario_id: int,\n                          db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Deletes a scenario by its ID for authorized users only. This endpoint ensures that the caller\n    owns the specified scenario before performing the deletion. If the scenario exists and the\n    authorization is confirmed, it is removed from the database, and a success message is returned.\n\n    :param token: Access token for authentication and authorization.\n    :type token: str\n    :param scenario_id: Unique identifier of the scenario to be deleted.\n    :type scenario_id: int\n    :param db: Database session used for querying and deleting the scenario. Dependency injection.\n    :type db: Session\n    :return: MessageResponse confirming successful deletion.\n    :rtype: MessageResponse\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    validate_scenario_result, validate_scenario_code, validate_scenario_msg = validate_scenario_owner(scenario_id, db,\n                                                                                                      token)\n    if not validate_scenario_result:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    scenario = db.get(EnScenarioDB, scenario_id)\n    db.delete(scenario)\n    db.commit()\n\n    return MessageResponse(\n        data=\"Scenario deleted.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/scenario/#app.scenario.router.read_scenario","title":"<code>read_scenario(scenario_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Retrieve scenario details by scenario ID.</p> <p>This endpoint allows an authenticated user to fetch information about a specific scenario based on its ID. It first validates the user's authentication and ownership of the scenario and associated project before retrieving the data. If the authentication or ownership checks fail, appropriate HTTP exceptions are raised.</p> <p>Parameters:</p> Name Type Description Default <code>scenario_id</code> <code>int</code> <p>ID of the scenario to fetch</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>Authentication token for the user</p> required <code>db</code> <code>Session</code> <p>Database session dependency. Dependency injection.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>Response containing the scenario data</p> Source code in <code>backend/app/scenario/router.py</code> <pre><code>@scenario_router.get(\"/{scenario_id}\", response_model=DataResponse)\nasync def read_scenario(scenario_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                        db: Session = Depends(get_db_session)) -&gt; DataResponse:\n    \"\"\"\n    Retrieve scenario details by scenario ID.\n\n    This endpoint allows an authenticated user to fetch information about a specific scenario\n    based on its ID. It first validates the user's authentication and ownership of the scenario\n    and associated project before retrieving the data. If the authentication or ownership checks\n    fail, appropriate HTTP exceptions are raised.\n\n    :param scenario_id: ID of the scenario to fetch\n    :type scenario_id: int\n    :param token: Authentication token for the user\n    :type token: str\n    :param db: Database session dependency. Dependency injection.\n    :type db: Session\n    :return: Response containing the scenario data\n    :rtype: DataResponse\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    validate_scenario_result, validate_scenario_code, validate_scenario_msg = validate_scenario_owner(scenario_id, db,\n                                                                                                      token)\n    if not validate_scenario_result:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    scenario = db.get(EnScenarioDB, scenario_id)\n    if not scenario:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Scenario not found.\")\n\n    if not validate_project_owner(scenario.project_id, token, db):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    response_data = scenario.model_dump(exclude=[\"energysystem\"])\n    return DataResponse(\n        data=GeneralDataModel(\n            items=[response_data],\n            totalCount=1\n        ),\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/scenario/#app.scenario.router.read_scenarios","title":"<code>read_scenarios(project_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Reads scenarios associated with a specific project based on the provided project ID. This route ensures that the user is both authenticated and authorized before retrieving the scenarios, which are fetched from the database using the project ID.</p> <p>Parameters:</p> Name Type Description Default <code>project_id</code> <code>int</code> <p>The ID of the project whose scenarios need to be retrieved.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>OAuth2-compliant access token used for user authentication.</p> required <code>db</code> <code>Session</code> <p>The database session dependency is used to access database functions. Dependency injection.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>A structured response containing the scenario data and a success flag.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the user is not authenticated (HTTP 401).</p> <code>HTTPException</code> <p>If the user is not authorized to access the project (HTTP 401).</p> Source code in <code>backend/app/scenario/router.py</code> <pre><code>@scenario_router.get(\"s/{project_id}\", response_model=DataResponse)\nasync def read_scenarios(project_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                         db: Session = Depends(get_db_session)) -&gt; DataResponse:\n    \"\"\"\n    Reads scenarios associated with a specific project based on the provided project ID.\n    This route ensures that the user is both authenticated and authorized before retrieving\n    the scenarios, which are fetched from the database using the project ID.\n\n    :param project_id: The ID of the project whose scenarios need to be retrieved.\n    :type project_id: Int\n    :param token: OAuth2-compliant access token used for user authentication.\n    :type token: Str\n    :param db: The database session dependency is used to access database functions. Dependency injection.\n    :type db: Session\n    :return: A structured response containing the scenario data and a success flag.\n    :rtype: DataResponse\n\n    :raises HTTPException: If the user is not authenticated (HTTP 401).\n    :raises HTTPException: If the user is not authorized to access the project (HTTP 401).\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    if not validate_project_owner(project_id, token, db):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    statement = select(EnScenarioDB).where(EnScenarioDB.project_id == project_id)\n    scenarios = db.exec(statement)\n\n    response_data = [scenario.model_dump(exclude=['energysystem']) for scenario in scenarios]\n    return DataResponse(\n        data=GeneralDataModel(\n            items=response_data,\n            totalCount=len(response_data)\n        ),\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/scenario/#app.scenario.router.update_scenario","title":"<code>update_scenario(token, scenario_id, scenario_data, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Updates an existing scenario identified by its ID. This endpoint allows updating specific fields of a scenario with new data provided in the <code>scenario_data</code> object. The function requires authentication and ownership validation to proceed. If the provided token is invalid or the user is not authorized, the operation will not be performed. Additionally, it checks whether the specified scenario exists in the database before attempting any updates.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>A bearer token for authorization that validates the user's access and ownership of the scenario.</p> required <code>scenario_id</code> <code>int</code> <p>The unique identifier of the scenario to be updated.</p> required <code>scenario_data</code> <code>EnScenarioUpdate</code> <p>Data for updating the specified scenario. Only fields that are included in this object and are allowed to be updated will be modified.</p> required <code>db</code> <code>Session</code> <p>A database session to interact with the scenario database. Dependency injection.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A <code>MessageResponse</code> indicating the success status of the operation and a message confirming the update.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Raised when the token is invalid, the user is unauthorized, the scenario does not exist in the database, or any other issue preventing the update operation occurs.</p> Source code in <code>backend/app/scenario/router.py</code> <pre><code>@scenario_router.patch(\"/{scenario_id}\", response_model=MessageResponse)\nasync def update_scenario(token: Annotated[str, Depends(oauth2_scheme)], scenario_id: int,\n                          scenario_data: EnScenarioUpdate, db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Updates an existing scenario identified by its ID. This endpoint allows updating\n    specific fields of a scenario with new data provided in the `scenario_data` object.\n    The function requires authentication and ownership validation to proceed. If the\n    provided token is invalid or the user is not authorized, the operation will not\n    be performed. Additionally, it checks whether the specified scenario exists in\n    the database before attempting any updates.\n\n    :param token: A bearer token for authorization that validates the user's access\n                  and ownership of the scenario.\n    :type token: str\n    :param scenario_id: The unique identifier of the scenario to be updated.\n    :type scenario_id: int\n    :param scenario_data: Data for updating the specified scenario. Only fields that\n                          are included in this object and are allowed to be updated\n                          will be modified.\n    :type scenario_data: EnScenarioUpdate\n    :param db: A database session to interact with the scenario database. Dependency injection.\n    :type db: Session\n    :return: A `MessageResponse` indicating the success status of the operation\n             and a message confirming the update.\n    :rtype: MessageResponse\n    :raises HTTPException: Raised when the token is invalid, the user is unauthorized,\n                           the scenario does not exist in the database, or any other\n                           issue preventing the update operation occurs.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    validate_scenario_result, validate_scenario_code, validate_scenario_msg = validate_scenario_owner(scenario_id, db,\n                                                                                                      token)\n    if not validate_scenario_result:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    db_scenario = db.get(EnScenarioDB, scenario_id)\n    if not db_scenario:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Scenario not found.\")\n\n    new_scenario_data = scenario_data.model_dump(exclude_unset=True)\n    # Note: Now it's a dict, not a EnScenarioUpdate\n\n    new_scenario_data[\"energysystem\"] = convert_gui_json_to_ensys(new_scenario_data[\"modeling_data\"])\n\n    db_scenario.sqlmodel_update(new_scenario_data)\n\n    db.add(db_scenario)\n    db.commit()\n    db.refresh(db_scenario)\n\n    return MessageResponse(\n        data=\"Scenario updated.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/simulation/","title":"simulation","text":""},{"location":"backend/api/router/simulation/#app.simulation.router.check_container_status","title":"<code>check_container_status(docker_container, simulation_id, db)</code>","text":"<p>Check the status of a Docker container and update the status of an associated simulation in the database accordingly.</p> <p>This function waits for the completion of a Docker container and retrieves its exit code. If the exit code indicates an error, an HTTPException is raised with the container logs. Otherwise, it updates the simulation's status to finished, sets the end date, and commits the changes to the database.</p> <p>Parameters:</p> Name Type Description Default <code>docker_container</code> <code>DockerContainer</code> <p>Docker container object representing the container to be monitored</p> required <code>simulation_id</code> <code>int</code> <p>The unique identifier of the simulation associated with the Docker container</p> required <code>db</code> <code>Session</code> <p>Database session object used for querying and persisting updates. Dependency injection.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>backend/app/simulation/router.py</code> <pre><code>def check_container_status(docker_container, simulation_id, db):\n    \"\"\"\n    Check the status of a Docker container and update the status of an associated simulation\n    in the database accordingly.\n\n    This function waits for the completion of a Docker container and retrieves its exit code.\n    If the exit code indicates an error, an HTTPException is raised with the container logs.\n    Otherwise, it updates the simulation's status to finished, sets the end date, and commits\n    the changes to the database.\n\n    :param docker_container: Docker container object representing the container to be monitored\n    :type docker_container: DockerContainer\n    :param simulation_id: The unique identifier of the simulation associated with the Docker container\n    :type simulation_id: int\n    :param db: Database session object used for querying and persisting updates. Dependency injection.\n    :type db: Session\n    :return: None\n    :rtype: None\n    \"\"\"\n    result_dict = docker_container.wait()\n\n    simulation = db.get(EnSimulationDB, simulation_id)\n\n    if result_dict[\"StatusCode\"] &gt; 0:\n        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail=docker_container.logs())\n    else:\n        simulation.status = Status.FINISHED.value\n        simulation.end_date = datetime.now()\n        db.commit()\n        db.refresh(simulation)\n</code></pre>"},{"location":"backend/api/router/simulation/#app.simulation.router.delete_simulation","title":"<code>delete_simulation(token, simulation_id, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Deletes a simulation from the database based on the given simulation ID. The user must be authenticated via a token for the operation to proceed.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The authenticated token required to access the endpoint.</p> required <code>simulation_id</code> <code>int</code> <p>The ID of the simulation to be deleted.</p> required <code>db</code> <code>Session</code> <p>The database session is used to retrieve and delete the simulation record. Dependency injection.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A response indicating whether the simulation was successfully deleted.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the user is not authenticated</p> Source code in <code>backend/app/simulation/router.py</code> <pre><code>@simulation_router.delete(\"/{simulation_id}\")\nasync def delete_simulation(token: Annotated[str, Depends(oauth2_scheme)], simulation_id: int,\n                            db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Deletes a simulation from the database based on the given simulation ID. The user must be authenticated\n    via a token for the operation to proceed.\n\n    :param token: The authenticated token required to access the endpoint.\n    :type token: Str\n    :param simulation_id: The ID of the simulation to be deleted.\n    :type simulation_id: Int\n    :param db: The database session is used to retrieve and delete the simulation record. Dependency injection.\n    :type db: Session\n\n    :return: A response indicating whether the simulation was successfully deleted.\n    :rtype: MessageResponse\n\n    :raises HTTPException: If the user is not authenticated\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n        # return DataResponse(\n        #     data=None,\n        #     success=False,\n        #     errors=[ErrorModel(\n        #         code=status.HTTP_401_UNAUTHORIZED,\n        #         message=\"Not authenticated.\"\n        #     )],\n        # )\n\n    simulation = db.get(EnSimulationDB, simulation_id)\n    db.delete(simulation)\n    db.commit()\n\n    return MessageResponse(\n        data=\"Simulation deleted.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/simulation/#app.simulation.router.get_simulation","title":"<code>get_simulation(simulation_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Fetches and returns simulation data based on the specified simulation ID. The request must include a valid authentication token. The function verifies user rights before retrieving the simulation. If the simulation does not exist or the user lacks the necessary permissions, appropriate HTTP exceptions are raised.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_id</code> <code>int</code> <p>The ID of the simulation to be fetched.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The authentication token for validating the request.</p> required <code>db</code> <code>Session</code> <p>Database session to access the database. Dependency injection.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>A <code>DataResponse</code> object containing the simulation data and metadata.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the user is not authorized.</p> <code>HTTPException</code> <p>If the specified simulation does not exist.</p> <code>HTTPException</code> <p>If the user does not have access to the simulation.</p> Source code in <code>backend/app/simulation/router.py</code> <pre><code>@simulation_router.get(\"/{simulation_id}\", response_model=DataResponse)\nasync def get_simulation(simulation_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                         db: Session = Depends(get_db_session)) -&gt; DataResponse:\n    \"\"\"\n    Fetches and returns simulation data based on the specified simulation ID. The request\n    must include a valid authentication token. The function verifies user rights before\n    retrieving the simulation. If the simulation does not exist or the user lacks the\n    necessary permissions, appropriate HTTP exceptions are raised.\n\n    :param simulation_id: The ID of the simulation to be fetched.\n    :type simulation_id: Int\n    :param token: The authentication token for validating the request.\n    :type token: Str\n    :param db: Database session to access the database. Dependency injection.\n    :type db: Session\n    :return: A `DataResponse` object containing the simulation data and metadata.\n    :raises HTTPException: If the user is not authorized.\n    :raises HTTPException: If the specified simulation does not exist.\n    :raises HTTPException: If the user does not have access to the simulation.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    simulation = db.exec(select(EnSimulationDB).where(EnSimulationDB.id == simulation_id)).first()\n    if not simulation:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"No Simulation found.\")\n\n    if not validate_user_rights(token=token, scenario_id=simulation.scenario_id, db=db):\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=[simulation],\n            totalCount=1,\n        ),\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/simulation/#app.simulation.router.get_simulation_status","title":"<code>get_simulation_status(simulation_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>This function retrieves the status of a specific simulation based on the provided simulation ID. It performs authentication and authorization checks to ensure proper access control. If the simulation exists and the user has the required access permissions, it fetches and returns the simulation's status wrapped in a success response.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_id</code> <code>int</code> <p>ID of the simulation to retrieve status for.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>Access token provided by the client for authorization.</p> required <code>db</code> <code>Session</code> <p>Database session is required to access simulation data. Dependency injection.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A <code>MessageResponse</code> instance containing the simulation's status if found and accessible.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <ul> <li>401 Unauthorized if the provided token is invalid or the user lacks appropriate rights. - 404 Not Found if the simulation with the specified ID does not exist.</li> </ul> Source code in <code>backend/app/simulation/router.py</code> <pre><code>@simulation_router.get(\"/status/{simulation_id}\", response_model=MessageResponse)\nasync def get_simulation_status(simulation_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                                db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    This function retrieves the status of a specific simulation based on the provided simulation ID.\n    It performs authentication and authorization checks to ensure proper access control. If the\n    simulation exists and the user has the required access permissions, it fetches and returns\n    the simulation's status wrapped in a success response.\n\n    :param simulation_id: ID of the simulation to retrieve status for.\n    :type simulation_id: Int\n    :param token: Access token provided by the client for authorization.\n    :type token: Str\n    :param db: Database session is required to access simulation data. Dependency injection.\n    :type db: Session\n    :return: A `MessageResponse` instance containing the simulation's status if found and accessible.\n    :rtype: MessageResponse\n\n    :raises HTTPException:\n        - 401 Unauthorized if the provided token is invalid or the user lacks appropriate rights.\n        - 404 Not Found if the simulation with the specified ID does not exist.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    simulation = db.exec(select(EnSimulationDB).where(EnSimulationDB.id == simulation_id)).first()\n    if not simulation:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"No Simulation found.\")\n\n    if not validate_user_rights(token=token, scenario_id=simulation.scenario_id, db=db):\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    selected_simulation = db.get(EnSimulationDB, simulation_id)\n\n    return MessageResponse(\n        data=selected_simulation.status,\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/simulation/#app.simulation.router.get_simulations","title":"<code>get_simulations(scenario_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Retrieve a list of simulations associated with a specific scenario.</p> <p>This function fetches simulations from the database that are linked to the given <code>scenario_id</code>. It authenticates the request using a token and validates the user's rights for the specified scenario. If no simulations are found, an appropriate HTTP error is raised.</p> <p>Parameters:</p> Name Type Description Default <code>scenario_id</code> <code>int</code> <p>Identifier of the scenario for which simulations are requested.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>A string token used for authentication and authorization.</p> required <code>db</code> <code>Session</code> <p>A database session used for querying the simulations. Dependency injection.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>A DataResponse object containing the list of simulations matched to the specified scenario, the total count of simulations, and a success flag.</p> Source code in <code>backend/app/simulation/router.py</code> <pre><code>@simulation_router.get(\"s/{scenario_id}\", response_model=DataResponse)\nasync def get_simulations(scenario_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                          db: Session = Depends(get_db_session)) -&gt; DataResponse:\n    \"\"\"\n    Retrieve a list of simulations associated with a specific scenario.\n\n    This function fetches simulations from the database that are linked to the\n    given `scenario_id`. It authenticates the request using a token and validates\n    the user's rights for the specified scenario. If no simulations are found,\n    an appropriate HTTP error is raised.\n\n    :param scenario_id: Identifier of the scenario for which simulations are requested.\n    :type scenario_id: int\n    :param token: A string token used for authentication and authorization.\n    :type token: str\n    :param db: A database session used for querying the simulations. Dependency injection.\n    :type db: Session\n    :return: A DataResponse object containing the list of simulations matched\n        to the specified scenario, the total count of simulations, and a success flag.\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    if not validate_user_rights(token=token, scenario_id=scenario_id, db=db):\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    simulations = db.exec(select(EnSimulationDB).where(EnSimulationDB.scenario_id == scenario_id)).all()\n    if not simulations:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"No Simulations found.\")\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=simulations,\n            totalCount=len(simulations),\n        ),\n        success=True,\n    )\n</code></pre>"},{"location":"backend/api/router/simulation/#app.simulation.router.start_simulation","title":"<code>start_simulation(scenario_id, background_tasks, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Starts a new simulation for a given scenario and ensures any currently running simulations for the same scenario are stopped. It creates a new simulation entry in the database, generates a unique task ID, and initiates the simulation task.</p> <p>Parameters:</p> Name Type Description Default <code>scenario_id</code> <code>int</code> <p>The ID of the scenario for which the simulation is being started.</p> required <code>background_tasks</code> <code>BackgroundTasks</code> <p>The background tasks object provided by FastAPI's dependency injection.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The authentication token used to authenticate and authorize the user.</p> required <code>db</code> <code>Session</code> <p>The session used for database interaction, provided by dependency injection.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A response containing success information and details of the initiated task.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If authentication or authorization fails.</p> Source code in <code>backend/app/simulation/router.py</code> <pre><code>@simulation_router.post(\"/start/{scenario_id}\", response_model=MessageResponse)\nasync def start_simulation(scenario_id: int, background_tasks: BackgroundTasks,\n                           token: Annotated[str, Depends(oauth2_scheme)],\n                           db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Starts a new simulation for a given scenario and ensures any currently running simulations\n    for the same scenario are stopped. It creates a new simulation entry in the database, generates\n    a unique task ID, and initiates the simulation task.\n\n    :param scenario_id: The ID of the scenario for which the simulation is being started.\n    :type scenario_id: int\n    :param background_tasks: The background tasks object provided by FastAPI's dependency injection.\n    :type background_tasks: BackgroundTasks\n    :param token: The authentication token used to authenticate and authorize the user.\n    :type token: str\n    :param db: The session used for database interaction, provided by dependency injection.\n    :type db: Session\n    :return: A response containing success information and details of the initiated task.\n    :rtype: MessageResponse\n    :raises HTTPException: If authentication or authorization fails.\n    \"\"\"\n    if not token:\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    if not validate_user_rights(token=token, scenario_id=scenario_id, db=db):\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    # Get old Simulation and stop it\n    running_simulations = db.exec(select(EnSimulationDB).where(EnSimulationDB.scenario_id == scenario_id).where(\n        EnSimulationDB.status == Status.STARTED.value)).all()\n\n    if running_simulations:\n        for running_simulation in running_simulations:\n            running_simulation.status = Status.CANCELED.value\n            running_simulation.end_date = datetime.now()\n            db.commit()\n\n    simulation_token = uuid()\n\n    # Create a new Simulation\n    simulation = EnSimulationDB(\n        sim_token=simulation_token,\n        start_date=datetime.now(),\n        end_date=None,\n        scenario_id=scenario_id,\n    )\n\n    db.add(simulation)\n    db.commit()\n    db.refresh(simulation)\n\n    # Start eines Celery Tasks f\u00fcr die Durchf\u00fchrung der Simulation\n    task = simulation_task.apply_async((scenario_id, simulation.id), task_id=simulation_token)\n    logger.info(\"Task UUID:\", task.id)\n\n    return MessageResponse(\n        data=f\"Simulation with id:{simulation.id} and task id:{task.id} started.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/simulation/#app.simulation.router.stop_simulation","title":"<code>stop_simulation(simulation_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Stops a simulation with the specified simulation ID. This operation first validates the user's authentication and authorization using the provided token, then retrieves the simulation from the database. If the simulation is found and the user has the appropriate rights, the simulation task is manually stopped through the 'revoke' method. A success message is returned upon successful completion.</p> <p>Parameters:</p> Name Type Description Default <code>simulation_id</code> <code>int</code> <p>The identifier of the simulation to be stopped.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>A token to validate user authentication and authorization.</p> required <code>db</code> <code>Session</code> <p>The database session is used to access and query the database. Dependency injection.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A message response indicating a success message and the ID of the stopped simulation.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Raises a 401 Unauthorized error if the token is missing or invalid, or if the user is not authorized. Raises a 404 Not Found error if the specified simulation ID does not exist.</p> Source code in <code>backend/app/simulation/router.py</code> <pre><code>@simulation_router.post(\"/stop/{simulation_id}\", response_model=MessageResponse)\nasync def stop_simulation(simulation_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                          db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Stops a simulation with the specified simulation ID. This operation first\n    validates the user's authentication and authorization using the provided\n    token, then retrieves the simulation from the database. If the simulation is\n    found and the user has the appropriate rights, the simulation task is\n    manually stopped through the 'revoke' method. A success message is returned\n    upon successful completion.\n\n    :param simulation_id: The identifier of the simulation to be stopped.\n    :type simulation_id: Int\n    :param token: A token to validate user authentication and authorization.\n    :type token: Str\n    :param db: The database session is used to access and query the\n        database. Dependency injection.\n    :type db: Session\n    :return: A message response indicating a success message and the ID of the\n        stopped simulation.\n    :rtype: MessageResponse\n    :raises HTTPException: Raises a 401 Unauthorized error if the token is missing\n        or invalid, or if the user is not authorized. Raises a 404 Not Found error\n        if the specified simulation ID does not exist.\n    \"\"\"\n    if not token:\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    simulation = db.get(EnSimulationDB, simulation_id)\n    if not simulation:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"No Simulation found.\")\n\n    if not validate_user_rights(token=token, scenario_id=simulation.scenario_id, db=db):\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    # Task manuell stoppen\n    revoke(simulation.sim_token, terminate=True)\n\n    return MessageResponse(\n        data=f\"Simulation with id:{simulation.sim_token} stopped.\",\n        success=True,\n    )\n</code></pre>"},{"location":"backend/api/router/simulation/#app.simulation.router.stop_simulations","title":"<code>stop_simulations(scenario_id, token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Stop active simulations for a specified scenario.</p> <p>This endpoint allows stopping all running simulations associated with a specific scenario. Authorization and user permission checks are performed before proceeding. If more than one simulation is found, a conflict error is reported. Additionally, background tasks associated with the simulations are terminated.</p> <p>Parameters:</p> Name Type Description Default <code>scenario_id</code> <code>int</code> <p>ID of the scenario whose simulations are to be stopped.</p> required <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>Authentication token for user validation.</p> required <code>db</code> <code>Session</code> <p>Database session for querying and updating simulation data.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>Response object indicating the success or failure of the operation along with details of any encountered errors.</p> Source code in <code>backend/app/simulation/router.py</code> <pre><code>@simulation_router.post(\"s/stop/{scenario_id}\", response_model=MessageResponse)\nasync def stop_simulations(scenario_id: int, token: Annotated[str, Depends(oauth2_scheme)],\n                           db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Stop active simulations for a specified scenario.\n\n    This endpoint allows stopping all running simulations associated with a specific\n    scenario. Authorization and user permission checks are performed before proceeding.\n    If more than one simulation is found, a conflict error is reported. Additionally,\n    background tasks associated with the simulations are terminated.\n\n    :param scenario_id: ID of the scenario whose simulations are to be stopped.\n    :type scenario_id: Int\n    :param token: Authentication token for user validation.\n    :type token: Str\n    :param db: Database session for querying and updating simulation data.\n    :type db: Session\n    :return: Response object indicating the success or failure of the operation along\n             with details of any encountered errors.\n    :rtype: MessageResponse\n    \"\"\"\n    errors = []\n    if not token:\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n\n    if not validate_user_rights(token=token, scenario_id=scenario_id, db=db):\n        raise HTTPException(status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    simulations = db.exec(select(EnSimulationDB).where(EnSimulationDB.status == Status.STARTED.value).where(\n        EnSimulationDB.scenario_id == scenario_id)).all()\n    if not simulations:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"No Simulation found.\")\n\n    if len(simulations) &gt; 1:\n        errors.append(ErrorModel(\n            code=status.HTTP_409_CONFLICT,\n            message=\"Mehr als 2 Simulationen laufen, du Bob hast vergessen beim Starten die alte zu beenden!\"\n        ))\n\n    # TODO: Wie stoppe ich Background-Tasks?\n    # Task manuell stoppen\n    for simulation in simulations:\n        revoke(simulation.sim_token, terminate=True)\n\n    return MessageResponse(\n        data=f\"Simulation stopped.\",\n        success=True,\n        errors=errors\n    )\n</code></pre>"},{"location":"backend/api/router/simulation/#app.simulation.router.validate_user_rights","title":"<code>validate_user_rights(token, scenario_id, db)</code>","text":"<p>Validates a user's rights to access a specific scenario within a project. The function first validates whether the user is the owner of the given scenario and subsequently verifies ownership of the associated project. Raises appropriate HTTP exceptions if the user is unauthorized or if the specified scenario or project does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Str</code> <p>Authentication token of the user.</p> required <code>scenario_id</code> <code>Int</code> <p>ID of the scenario to validate access for.</p> required <code>db</code> <code>Session</code> <p>Database session/connection object used for querying related data. Dependency injection.</p> required <p>Returns:</p> Type Description <code>Bool</code> <p>A boolean indicating whether the user is authorized to access the scenario.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the user is unauthorized or the specified scenario or project is not found.</p> Source code in <code>backend/app/simulation/router.py</code> <pre><code>def validate_user_rights(token, scenario_id, db) -&gt; bool:\n    \"\"\"\n    Validates a user's rights to access a specific scenario within a project. The function first\n    validates whether the user is the owner of the given scenario and subsequently verifies ownership of the\n    associated project. Raises appropriate HTTP exceptions if the user is unauthorized or if the specified\n    scenario or project does not exist.\n\n    :param token: Authentication token of the user.\n    :type token: Str\n    :param scenario_id: ID of the scenario to validate access for.\n    :type scenario_id: Int\n    :param db: Database session/connection object used for querying related data. Dependency injection.\n    :type db: Session\n\n    :return: A boolean indicating whether the user is authorized to access the scenario.\n    :rtype: Bool\n\n    :raises HTTPException: If the user is unauthorized or the specified scenario or project is not found.\n    \"\"\"\n\n    validation_scenario = validate_scenario_owner(\n        token=token,\n        scenario_id=scenario_id,\n        db=db\n    )\n    if not validation_scenario:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    scenario = db.exec(select(EnScenarioDB).where(EnScenarioDB.id == scenario_id)).first()\n    if not scenario:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Scenario not found.\")\n\n    project = db.exec(select(EnProjectDB).where(EnProjectDB.id == scenario.project_id)).first()\n    if not project:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"Project not found.\")\n\n    validation_project = validate_project_owner(\n        token=token,\n        project_id=project.id,\n        db=db,\n    )\n    if not validation_project:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authorized.\")\n\n    return True\n</code></pre>"},{"location":"backend/api/router/user/","title":"user","text":""},{"location":"backend/api/router/user/#app.user.router.delete_user","title":"<code>delete_user(token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Deletes a user based on the credentials and token provided. The function retrieves the user's data from the database using the information decoded from the token. If the user does not exist, an HTTP exception is raised. If the user exists, the function proceeds to delete the user from the database and commits the transaction.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>An access token for the user requesting deletion.</p> required <code>db</code> <code>Session</code> <p>A SQLAlchemy session dependency for interacting with the database.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A <code>MessageResponse</code> indicating the outcome of the operation.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the user is not found, with status code 404.</p> Source code in <code>backend/app/user/router.py</code> <pre><code>@users_router.delete(\"/\", response_model=MessageResponse)\nasync def delete_user(token: Annotated[str, Depends(oauth2_scheme)],\n                      db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Deletes a user based on the credentials and token provided. The function\n    retrieves the user's data from the database using the information decoded\n    from the token. If the user does not exist, an HTTP exception is raised.\n    If the user exists, the function proceeds to delete the user from the\n    database and commits the transaction.\n\n    :param token: An access token for the user requesting deletion.\n    :param db: A SQLAlchemy session dependency for interacting with the database.\n    :return: A `MessageResponse` indicating the outcome of the operation.\n    :rtype: MessageResponse\n    :raises HTTPException: If the user is not found, with status code 404.\n    \"\"\"\n    token_data = decode_token(token)\n\n    if not \"id\" in token_data:\n        statement = select(EnUserDB).where(EnUserDB.username == token_data[\"username\"])\n        user = db.exec(statement).first()\n    else:\n        user = db.get(EnUser, token_data[\"id\"])\n\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"User not found.\")\n\n    db.delete(user)\n    db.commit()\n\n    return MessageResponse(\n        data=f\"User was successfully deleted.\",\n        success=True\n    )\n</code></pre>"},{"location":"backend/api/router/user/#app.user.router.update_user","title":"<code>update_user(token, user, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Updates the user information in the database based on the provided token and user data. The token is used to authenticate and retrieve the corresponding user. The user details in the database are updated with the provided data, and the updated information is returned.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>The authentication token identifying the user to be updated.</p> required <code>user</code> <code>EnUserUpdate</code> <p>The updated details of the user.</p> required <code>db</code> <code>Session</code> <p>The database session used for executing queries.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>Response containing the updated user details in a data response format.</p> Source code in <code>backend/app/user/router.py</code> <pre><code>@users_router.patch(\"/\", response_model=DataResponse)\nasync def update_user(token: Annotated[str, Depends(oauth2_scheme)], user: EnUserUpdate,\n                      db: Session = Depends(get_db_session)) -&gt; DataResponse:\n    \"\"\"\n    Updates the user information in the database based on the provided token and\n    user data. The token is used to authenticate and retrieve the corresponding\n    user. The user details in the database are updated with the provided data,\n    and the updated information is returned.\n\n    :param token: The authentication token identifying the user to be updated.\n    :type token: str\n    :param user: The updated details of the user.\n    :type user: EnUserUpdate\n    :param db: The database session used for executing queries.\n    :type db: Session\n    :return: Response containing the updated user details in a data response format.\n    :rtype: DataResponse\n    \"\"\"\n    token_data = decode_token(token)\n\n    statement = select(EnUserDB).where(EnUserDB.username == token_data[\"username\"])\n    user_db = db.exec(statement).first()\n\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"User not found.\")\n\n    for field, value in user.model_dump(exclude_none=True, exclude_unset=True).items():\n        print(field, \":\", value)\n        setattr(user_db, field, value)\n\n    db.commit()\n    db.refresh(user_db)\n\n    return DataResponse(\n        data=GeneralDataModel(\n            items=[user.model_dump()],\n            totalCount=1,\n        ),\n        success=True,\n    )\n</code></pre>"},{"location":"backend/api/router/user/#app.user.router.user_login","title":"<code>user_login(username=Form(...), password=Form(...), db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Authenticates a user and generates an access token upon successful login.</p> <p>This function allows the user to log into the system by providing the correct credentials. Upon successful authentication, an access token is generated and returned with additional details. If the credentials are invalid or the user does not exist, appropriate exceptions are raised.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username of the user attempting to log in.</p> <code>Form(...)</code> <code>password</code> <code>str</code> <p>The password associated with the username.</p> <code>Form(...)</code> <code>db</code> <code>Session</code> <p>The database session dependency that allows for database queries.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>JSONResponse</code> <p>A JSON response containing a success message, an access token, and the token type if authentication is successful.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>Raised with status code 404 if the user does not exist, or with status code 401 if the password is incorrect.</p> Source code in <code>backend/app/user/router.py</code> <pre><code>@users_router.post(\"/auth/login\")\nasync def user_login(username: str = Form(...), password: str = Form(...), db: Session = Depends(get_db_session)):\n    \"\"\"\n    Authenticates a user and generates an access token upon successful login.\n\n    This function allows the user to log into the system by providing the correct\n    credentials. Upon successful authentication, an access token is generated\n    and returned with additional details. If the credentials are invalid or the\n    user does not exist, appropriate exceptions are raised.\n\n    :param username: The username of the user attempting to log in.\n    :type username: str\n    :param password: The password associated with the username.\n    :type password: str\n    :param db: The database session dependency that allows for database queries.\n    :type db: Session\n    :return: A JSON response containing a success message, an access token,\n        and the token type if authentication is successful.\n    :rtype: JSONResponse\n    :raises HTTPException: Raised with status code 404 if the user does not exist,\n        or with status code 401 if the password is incorrect.\n    \"\"\"\n    statement = select(EnUserDB).where(EnUserDB.username == username.lower())\n    user_db = db.exec(statement).first()\n    print(f\"user_db: {user_db}\")\n\n    if not user_db:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"User not found.\")\n\n    if user_db.verify_password(password):\n        user_db.last_login = datetime.now()\n        db.add(user_db)\n        db.commit()\n        db.refresh(user_db)\n\n        token = jwt.encode(user_db.get_token_information(), token_secret, algorithm=\"HS256\")\n\n        return JSONResponse(\n            content={\n                \"message\": \"User login successful.\",\n                \"access_token\": token,\n                \"token_type\": \"bearer\"},\n            status_code=status.HTTP_200_OK\n        )\n    else:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Password incorrect.\")\n</code></pre>"},{"location":"backend/api/router/user/#app.user.router.user_read","title":"<code>user_read(token, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Handles a GET API endpoint to read user information from the database.</p> <p>This function authenticates the request using the provided token and retrieves the corresponding user data from the database. If the token is invalid or the user is not found, appropriate HTTP exceptions are raised. On successful retrieval, it returns the user data wrapped in a response model.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>Annotated[str, Depends(oauth2_scheme)]</code> <p>A token string obtained through user authentication.</p> required <code>db</code> <code>Session</code> <p>The database session used for querying user data.</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>DataResponse</code> <p>A DataResponse instance containing user information if authentication and retrieval are successful.</p> Source code in <code>backend/app/user/router.py</code> <pre><code>@users_router.get(\"/\", response_model=DataResponse)\nasync def user_read(token: Annotated[str, Depends(oauth2_scheme)],\n                    db: Session = Depends(get_db_session)) -&gt; DataResponse:\n    \"\"\"\n    Handles a GET API endpoint to read user information from the database.\n\n    This function authenticates the request using the provided token and retrieves\n    the corresponding user data from the database. If the token is invalid or the\n    user is not found, appropriate HTTP exceptions are raised. On successful retrieval,\n    it returns the user data wrapped in a response model.\n\n    :param token: A token string obtained through user authentication.\n    :type token: str\n\n    :param db: The database session used for querying user data.\n    :type db: Session\n\n    :return: A DataResponse instance containing user information if authentication\n             and retrieval are successful.\n    :rtype: DataResponse\n    \"\"\"\n    if not token:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail=\"Not authenticated.\")\n    else:\n        token_data = decode_token(token)\n\n    statement = select(EnUserDB).where(EnUserDB.username == token_data[\"username\"])\n    user = db.exec(statement).first()\n\n    if not user:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"User not found.\")\n    else:\n        return DataResponse(\n            data=GeneralDataModel(\n                items=[user.model_dump()],\n                totalCount=1,\n            ),\n            success=True,\n        )\n</code></pre>"},{"location":"backend/api/router/user/#app.user.router.user_register","title":"<code>user_register(user, db=Depends(get_db_session))</code>  <code>async</code>","text":"<p>Registers a new user in the system. The function verifies whether the username and email provided by the user are unique before proceeding with the creation of a new user record. If the username or email is already in use, an exception is raised with the appropriate error details. A successful registration results in the creation of a persisted user entity in the database. Passwords are securely hashed before storage to ensure data protection.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>EnUser</code> <p>An instance of EnUser containing the user's registration details, including username, email, and password. Type: EnUser</p> required <code>db</code> <code>Session</code> <p>Dependency-injected database session to interact with the database. Type: Session</p> <code>Depends(get_db_session)</code> <p>Returns:</p> Type Description <code>MessageResponse</code> <p>A response model indicating the success of the operation. Returns a MessageResponse object on success.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <ul> <li>If the username is already in use (HTTP status 409). - If the email is already in use (HTTP status 409). - If user registration fails due to an unknown issue (HTTP status 404).</li> </ul> Source code in <code>backend/app/user/router.py</code> <pre><code>@users_router.post(\"/auth/register\", status_code=status.HTTP_201_CREATED, response_model=MessageResponse)\nasync def user_register(user: EnUser, db: Session = Depends(get_db_session)) -&gt; MessageResponse:\n    \"\"\"\n    Registers a new user in the system. The function verifies whether the username\n    and email provided by the user are unique before proceeding with the creation\n    of a new user record. If the username or email is already in use, an exception\n    is raised with the appropriate error details. A successful registration results\n    in the creation of a persisted user entity in the database. Passwords are\n    securely hashed before storage to ensure data protection.\n\n    :param user: An instance of EnUser containing the user's registration details,\n                 including username, email, and password.\n                 Type: EnUser\n    :param db: Dependency-injected database session to interact with the database.\n               Type: Session\n    :return: A response model indicating the success of the operation.\n             Returns a MessageResponse object on success.\n    :rtype: MessageResponse\n\n    :raises HTTPException:\n        - If the username is already in use (HTTP status 409).\n        - If the email is already in use (HTTP status 409).\n        - If user registration fails due to an unknown issue (HTTP status 404).\n    \"\"\"\n    # Test against same username\n    statement = select(EnUserDB).where(EnUserDB.username == user.username.lower())\n    results = db.exec(statement).first()\n\n    if results is not None:\n        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=\"User already exists.\")\n\n    # Test against same mail\n    statement = select(EnUserDB).where(EnUserDB.mail == user.mail)\n    results = db.exec(statement).first()\n\n    if results is not None:\n        raise HTTPException(status_code=status.HTTP_409_CONFLICT, detail=\"Mail already in use.\")\n\n    db_user = EnUserDB(**user.model_dump())\n    db_user.username = user.username.lower()\n    db_user.password = pbkdf2_sha256.hash(user.password)\n    db_user.date_joined = datetime.now()\n\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n\n    if db_user.id is not None:\n        return MessageResponse(\n            data=\"\",\n            success=True\n        )\n    else:\n        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail=\"User registration failed.\")\n</code></pre>"},{"location":"ensys/","title":"EnSys","text":"<p>Package to Map oemof.solph-Classes to abstract classes for further use.</p>"},{"location":"ensys/#usage","title":"Usage","text":"<p>This package comes with an CLI-Interface to start and simulate energymodels. </p>"},{"location":"ensys/#configuration","title":"Configuration","text":"<p>To configurate an energymodel uses therefore the following classes. Beginning with the components and adding them afterward to an energysystem and energymodel.</p> <p>Model configuration:</p> <ul> <li>EnModel</li> <li>EnEnergysystem</li> </ul> <p>System components:</p> <ul> <li>EnBus</li> <li>EnSink</li> <li>EnSource</li> <li>EnGenericStorage</li> <li>EnConverter</li> </ul> <p>Special Components:</p> <ul> <li>EnInvestment</li> <li>EnNonConvex</li> <li>EnFlow</li> </ul>"},{"location":"ensys/#external-start","title":"External Start","text":"<p>To start the application it is necessary to define the following classes and dump them into a file:</p> <ul> <li>EnModel</li> <li>EnEnergysystem</li> </ul> <pre><code>python main.py [-olp] [-wdir WORKINGDIRECTORY] configfile\n</code></pre>"},{"location":"ensys/#parameters","title":"Parameters:","text":"<p>olp - It's a flag to select the single output of the lp-File wdir - Path to the Workingdirectory; if not given it's the current directory</p> <p>configfile - Necessary - the path to the configuration which is built before (binary or JSON)</p>"},{"location":"ensys/common/basemodel/","title":"BaseModels","text":""},{"location":"ensys/common/basemodel/#common.basemodel.EnBaseModel","title":"<code>EnBaseModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Pydantic subclass for special configurations and utility methods.</p> <p>This class extends the functionality of the BaseModel provided by Pydantic. It incorporates additional configurations and utility methods, such as cleaning up empty attributes and building keyword arguments for an oemof energy system component.</p> <p>Attributes:</p> Name Type Description <code>model_config</code> <p>Configuration dictionary that allows arbitrary types and specifies how additional attributes are handled.</p> Source code in <code>ensys/common/basemodel.py</code> <pre><code>class EnBaseModel(BaseModel):\n    \"\"\"\n    Pydantic subclass for special configurations and utility methods.\n\n    This class extends the functionality of the BaseModel provided by Pydantic. It incorporates\n    additional configurations and utility methods, such as cleaning up empty attributes and\n    building keyword arguments for an oemof energy system component.\n\n    :ivar model_config: Configuration dictionary that allows arbitrary types and specifies\n        how additional attributes are handled.\n    :type model_config: ConfigDict\n    \"\"\"\n\n    ## pydantic subclass to add special configurations.\n    model_config = ConfigDict(\n        extra='ignore',  # 'allow'\n        arbitrary_types_allowed=True\n    )\n\n    @model_validator(mode='before')\n    def remove_empty(self):\n        \"\"\"\n        Removes attributes with `None` values from the object.\n\n        This method iterates through all attributes of the object and identifies\n        those with a value of `None`. It collects these attributes into a list\n        and then removes them from the object. This helps in cleaning up empty\n        or irrelevant data within the object's state.\n\n        :raises AttributeError: If an attribute cannot be deleted for any reason.\n        :return: The modified object with `None` value attributes removed.\n        :rtype: object\n        \"\"\"\n        items_to_remove = []\n\n        if type(self) == dict:\n            for attribute in self:\n                if self[attribute] is None:\n                    items_to_remove.append(attribute)\n\n            for item in items_to_remove:\n                del self[item]\n\n        return self\n\n    def build_kwargs(self, energysystem: solph.EnergySystem) -&gt; dict[str, dict]:\n        \"\"\"\n        Builds a dictionary of keyword arguments for an oemof energy system component\n        based on the attributes of the current object. The function processes the\n        object's attributes, transforming and mapping them into a format compatible\n        with oemof components. Special handling is performed for attributes such as\n        inputs, outputs, and conversion factors to properly map these to the provided\n        energy system. Attributes of certain types are converted with their respective\n        methods if necessary.\n\n        :param energysystem: The energy system instance to which the object belongs,\n            used to resolve references and convert attributes to oemof-compatible formats.\n        :type energysystem: solph.EnergySystem\n        :return: A dictionary of formatted keyword arguments suitable for creating the\n            corresponding oemof component.\n        :rtype: dict[str, dict]\n        \"\"\"\n\n        attributes = vars(self)\n        kwargs = {}\n        special_keys = [\"inputs\", \"outputs\", \"conversion_factors\"]\n\n        for attr_key in attributes:\n            # iterates for every attribute\n            attr_value = attributes[attr_key]\n            if attr_value is not None:\n                if attr_key in special_keys:\n                    oemof_io = {}\n                    io_keys = list(attr_value.keys())\n\n                    for io_key in io_keys:\n                        bus = energysystem.groups[io_key]\n                        if isinstance(attr_value[io_key], float) or isinstance(attr_value[io_key], list):\n                            oemof_io[bus] = attr_value[io_key]\n                        else:\n                            oemof_io[bus] = attr_value[io_key].to_oemof(energysystem)\n\n                    kwargs[attr_key] = oemof_io\n                elif attr_key in [\"nonconvex\"] and not isinstance(attr_value, bool):\n                    kwargs[attr_key] = attr_value.to_oemof(energysystem)\n                elif attr_key in [\"nominal_value\", \"nominal_storage_capacity\"] and not isinstance(attr_value, float):\n                    kwargs[attr_key] = attr_value.to_oemof(energysystem)\n                else:\n                    kwargs[attr_key] = attr_value\n\n        return kwargs\n</code></pre>"},{"location":"ensys/common/basemodel/#common.basemodel.EnBaseModel.build_kwargs","title":"<code>build_kwargs(energysystem)</code>","text":"<p>Builds a dictionary of keyword arguments for an oemof energy system component based on the attributes of the current object. The function processes the object's attributes, transforming and mapping them into a format compatible with oemof components. Special handling is performed for attributes such as inputs, outputs, and conversion factors to properly map these to the provided energy system. Attributes of certain types are converted with their respective methods if necessary.</p> <p>Parameters:</p> Name Type Description Default <code>energysystem</code> <code>EnergySystem</code> <p>The energy system instance to which the object belongs, used to resolve references and convert attributes to oemof-compatible formats.</p> required <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>A dictionary of formatted keyword arguments suitable for creating the corresponding oemof component.</p> Source code in <code>ensys/common/basemodel.py</code> <pre><code>def build_kwargs(self, energysystem: solph.EnergySystem) -&gt; dict[str, dict]:\n    \"\"\"\n    Builds a dictionary of keyword arguments for an oemof energy system component\n    based on the attributes of the current object. The function processes the\n    object's attributes, transforming and mapping them into a format compatible\n    with oemof components. Special handling is performed for attributes such as\n    inputs, outputs, and conversion factors to properly map these to the provided\n    energy system. Attributes of certain types are converted with their respective\n    methods if necessary.\n\n    :param energysystem: The energy system instance to which the object belongs,\n        used to resolve references and convert attributes to oemof-compatible formats.\n    :type energysystem: solph.EnergySystem\n    :return: A dictionary of formatted keyword arguments suitable for creating the\n        corresponding oemof component.\n    :rtype: dict[str, dict]\n    \"\"\"\n\n    attributes = vars(self)\n    kwargs = {}\n    special_keys = [\"inputs\", \"outputs\", \"conversion_factors\"]\n\n    for attr_key in attributes:\n        # iterates for every attribute\n        attr_value = attributes[attr_key]\n        if attr_value is not None:\n            if attr_key in special_keys:\n                oemof_io = {}\n                io_keys = list(attr_value.keys())\n\n                for io_key in io_keys:\n                    bus = energysystem.groups[io_key]\n                    if isinstance(attr_value[io_key], float) or isinstance(attr_value[io_key], list):\n                        oemof_io[bus] = attr_value[io_key]\n                    else:\n                        oemof_io[bus] = attr_value[io_key].to_oemof(energysystem)\n\n                kwargs[attr_key] = oemof_io\n            elif attr_key in [\"nonconvex\"] and not isinstance(attr_value, bool):\n                kwargs[attr_key] = attr_value.to_oemof(energysystem)\n            elif attr_key in [\"nominal_value\", \"nominal_storage_capacity\"] and not isinstance(attr_value, float):\n                kwargs[attr_key] = attr_value.to_oemof(energysystem)\n            else:\n                kwargs[attr_key] = attr_value\n\n    return kwargs\n</code></pre>"},{"location":"ensys/common/basemodel/#common.basemodel.EnBaseModel.remove_empty","title":"<code>remove_empty()</code>","text":"<p>Removes attributes with <code>None</code> values from the object.</p> <p>This method iterates through all attributes of the object and identifies those with a value of <code>None</code>. It collects these attributes into a list and then removes them from the object. This helps in cleaning up empty or irrelevant data within the object's state.</p> <p>Returns:</p> Type Description <code>object</code> <p>The modified object with <code>None</code> value attributes removed.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If an attribute cannot be deleted for any reason.</p> Source code in <code>ensys/common/basemodel.py</code> <pre><code>@model_validator(mode='before')\ndef remove_empty(self):\n    \"\"\"\n    Removes attributes with `None` values from the object.\n\n    This method iterates through all attributes of the object and identifies\n    those with a value of `None`. It collects these attributes into a list\n    and then removes them from the object. This helps in cleaning up empty\n    or irrelevant data within the object's state.\n\n    :raises AttributeError: If an attribute cannot be deleted for any reason.\n    :return: The modified object with `None` value attributes removed.\n    :rtype: object\n    \"\"\"\n    items_to_remove = []\n\n    if type(self) == dict:\n        for attribute in self:\n            if self[attribute] is None:\n                items_to_remove.append(attribute)\n\n        for item in items_to_remove:\n            del self[item]\n\n    return self\n</code></pre>"},{"location":"ensys/common/modelbuilder/","title":"Modelbuilder","text":""},{"location":"ensys/common/modelbuilder/#common.modelbuilder.ModelBuilder","title":"<code>ModelBuilder</code>","text":"<p>ModelBuilder is a class responsible for constructing and solving an energy system model based on a configuration file. It provides functionality to parse the input configuration, log the necessary details, handle file operations and integrate with oemof-solph for energy system modeling and optimization.</p> <p>The intended use case is to manage energy systems, build components from the provided configuration, apply constraints, and run optimizations using a defined solver.</p> <p>Attributes:</p> Name Type Description <code>WORKING_DIRECTORY</code> <p>Path to the working directory where configurations and intermediate files will be stored.</p> <code>LOGGING_DIRECTORY</code> <p>Path to the directory for storing log files.</p> <code>DUMPING_DIRECTORY</code> <p>Path to the directory for storing dump files.</p> <code>logger</code> <p>Logger instance for logging messages and events during energy system construction and solving.</p> Source code in <code>ensys/common/modelbuilder.py</code> <pre><code>class ModelBuilder:\n    \"\"\"\n    ModelBuilder is a class responsible for constructing and solving an energy system\n    model based on a configuration file. It provides functionality to parse the input\n    configuration, log the necessary details, handle file operations and integrate with\n    oemof-solph for energy system modeling and optimization.\n\n    The intended use case is to manage energy systems, build components from the\n    provided configuration, apply constraints, and run optimizations using a defined\n    solver.\n\n    :ivar WORKING_DIRECTORY: Path to the working directory where configurations and\n        intermediate files will be stored.\n    :type WORKING_DIRECTORY: str\n    :ivar LOGGING_DIRECTORY: Path to the directory for storing log files.\n    :type LOGGING_DIRECTORY: str\n    :ivar DUMPING_DIRECTORY: Path to the directory for storing dump files.\n    :type DUMPING_DIRECTORY: str\n    :ivar logger: Logger instance for logging messages and events during energy\n        system construction and solving.\n    :type logger: logging.Logger\n    \"\"\"\n    WORKING_DIRECTORY = os.getcwd()\n    LOGGING_DIRECTORY = os.path.join(WORKING_DIRECTORY, \"logs\")\n    DUMPING_DIRECTORY = os.path.join(WORKING_DIRECTORY, \"dumps\")\n    logger = logging.getLogger(__name__)\n\n    def __init__(self,\n                 ConfigFile: str,\n                 DumpFile: str,\n                 wdir: str,\n                 logdir: str,\n                 dumpdir: str,\n                 only_lp: bool = False\n                 ) -&gt; None:\n        \"\"\"\n        Initializes an instance with specified configuration and directory settings. This constructor also handles the loading\n        of the model configuration from a JSON file, sets up logging and initiates the energy system building process based on\n        the parameters provided. An exception is raised if the configuration file does not follow the expected JSON format.\n\n        :param ConfigFile: Path to the JSON configuration file that defines the energy system model.\n        :type ConfigFile: str\n        :param DumpFile: File path where the results or intermediary data will be saved during the process.\n        :type DumpFile: str\n        :param wdir: Working directory path within the current directory to be used for intermediate processing.\n        :type wdir: str\n        :param logdir: Directory path for saving log files generated during execution.\n        :type logdir: str\n        :param dumpdir: Directory path for saving system dump files.\n        :type dumpdir: str\n        :param only_lp: Indicator for whether only linear programming should be used in the energy system solver.\n        :type only_lp: bool, optional\n        \"\"\"\n\n        self.WORKING_DIRECTORY = os.path.join(os.getcwd(), wdir)\n        if not os.path.exists(self.WORKING_DIRECTORY):\n            os.makedirs(self.WORKING_DIRECTORY)\n\n        self.LOGGING_DIRECTORY = logdir\n        if not os.path.exists(self.LOGGING_DIRECTORY):\n            os.makedirs(self.LOGGING_DIRECTORY)\n\n        self.DUMPING_DIRECTORY = dumpdir\n        if not os.path.exists(self.DUMPING_DIRECTORY):\n            os.makedirs(self.DUMPING_DIRECTORY)\n\n        # handle various filetypes\n        logfile = os.path.basename(ConfigFile)\n\n        if ConfigFile.find(\".json\") &gt; 0:\n            logfile = logfile.replace(\".json\", \".log\")\n\n            xf = open(ConfigFile, 'rt')\n            model_dict = json.load(xf)\n            model = EnModel(**model_dict)\n            xf.close()\n        else:\n            raise Exception(\"Fileformat is not valid!\")\n\n        tools.logger.define_logging(logpath=self.LOGGING_DIRECTORY, logfile=logfile, file_level=logging.INFO,\n                                    screen_level=logging.INFO)\n        self.logger.info(\"Start Building and solving\")\n\n        if hasattr(model, \"solver_kwargs\") and model.solver_kwargs is not None:\n            cmdline_opts = model.solver_kwargs\n        else:\n            cmdline_opts = {}\n\n        self.BuildEnergySystem(model.energysystem, DumpFile, model.solver, model.solver_verbose,\n                               cmdline_opts=cmdline_opts, only_lp=only_lp)\n\n    def BuildEnergySystem(self, es: EnEnergysystem, file: str, solver: Solver, solver_verbose: bool, cmdline_opts: dict,\n                          only_lp: bool):\n        \"\"\"\n        Builds an energy system from a configuration file and prepares it for optimization.\n        The method constructs an oemof energy system based on the provided configuration,\n        populates it with components, adds constraints if specified, prepares log and LP\n        files and optionally solves the optimization problem.\n\n        :param es: The energy system configuration object containing attributes such as\n            start_date, time_steps, frequenz, components, and constraints.\n        :type es: EnEnergysystem\n        :param file: The configuration file for building the energy system.\n        :type file: str\n        :param solver: The solver to be used for optimization.\n        :type solver: Solver\n        :param solver_verbose: Boolean flag indicating whether detailed output by the solver\n            should be logged.\n        :type solver_verbose: bool\n        :param cmdline_opts: A dictionary of command-line options for the solver.\n        :type cmdline_opts: dict\n        :param only_lp: Boolean flag indicating if only the LP file should be stored without\n            solving.\n        :type only_lp: bool\n        :return: None\n        \"\"\"\n        logging.basicConfig(filename='ensys.log', level=logging.INFO)\n        self.logger.info(\"Build an Energysystem from config file.\")\n        filename = os.path.basename(file)\n\n        ##########################################################################\n        # Build the oemof-energysystem\n        ##########################################################################\n        if es.frequenz is Interval.quarter_hourly:\n            freq = \"15min\"\n        elif es.frequenz is Interval.half_hourly:\n            freq = \"30min\"\n        elif es.frequenz is Interval.hourly:\n            freq = \"1h\"\n        else:\n            freq = \"H\"\n\n        timeindex = pd.date_range(start=es.start_date,\n                                  periods=es.time_steps,\n                                  freq=freq)\n\n        oemof_es = solph.EnergySystem(\n            timeindex=timeindex\n        )\n\n        except_vars = [\"label\", \"start_date\", \"time_steps\", \"frequenz\", \"constraints\"]\n\n        for attr in vars(es):\n            if attr not in except_vars:\n                self.logger.info(\"Build \" + attr)\n\n                arg_value = getattr(es, attr)\n\n                for value in arg_value:\n                    oemof_obj = value.to_oemof(oemof_es)\n\n                    if oemof_obj is not None:\n                        oemof_es.add(oemof_obj)\n\n        self.logger.info(\"Build completed.\")\n\n        # pre_dump_file = open(os.path.join(self.DUMPING_DIRECTORY, filename.replace(\".dump\", \"_pre-dump.dump\")), \"wt\")\n        # json_str = json.dumps(oemof_es.__dict__)\n        # pickle.dump(json_str, pre_dump_file)\n\n        ##########################################################################\n        # Initiate the energy system model\n        ##########################################################################\n        self.logger.info(\"Initiate the energy system model.\")\n        model = solph.Model(oemof_es, debug=False)\n\n        ##########################################################################\n        # Add Constraints to the model\n        ##########################################################################\n        self.logger.info(\"Adding constraints to the energy system model.\")\n        if hasattr(es, \"constraints\"):\n            for constr in es.constraints:\n                kwargs = constr.to_oemof()\n\n                if constr.typ == Constraints.shared_limit:\n                    solph.constraints.shared_limit(model=model, **kwargs)\n\n                elif constr.typ == Constraints.investment_limit:\n                    model = solph.constraints.investment_limit(model=model, **kwargs)\n\n                elif constr.typ == Constraints.additional_investment_flow_limit:\n                    model = solph.constraints.additional_investment_flow_limit(model=model, **kwargs)\n\n                elif constr.typ == Constraints.generic_integral_limit:\n                    model = solph.constraints.generic_integral_limit(om=model, **kwargs)\n\n                elif constr.typ == Constraints.emission_limit:\n                    solph.constraints.emission_limit(om=model, **kwargs)\n\n                elif constr.typ == Constraints.limit_active_flow_count:\n                    model = solph.constraints.limit_active_flow_count(model=model, **kwargs)\n\n                elif constr.typ == Constraints.limit_active_flow_count_by_keyword:\n                    model = solph.constraints.limit_active_flow_count_by_keyword(model=model, **kwargs)\n\n                elif constr.typ == Constraints.equate_variables:\n                    solph.constraints.equate_variables(model=model, **kwargs)\n\n        ### Create Logfile for Solver\n        logfile = os.path.join(self.LOGGING_DIRECTORY, filename.replace(\".dump\", \"_solver.log\"))\n        self.logger.info(\"Logfile: \" + self.LOGGING_DIRECTORY)\n\n        ### Store LP files\n        lp_filename = os.path.join(self.DUMPING_DIRECTORY, filename.replace(\".dump\", \".lp\"))\n\n        self.logger.info(\"Store lp-file in {0}.\".format(lp_filename))\n        model.write(lp_filename, io_options={\"symbolic_solver_labels\": True})\n        ### Set Environmental Variables for the solver\n        # map kwargs for pyomo.enviroment and later usage\n        solve_kwargs = {\"tee\": solver_verbose}\n        cmdline_opts[\"logfile\"] = logfile\n\n        if not only_lp:\n            ##########################################################################\n            # solving...\n            ##########################################################################\n            self.logger.info(\"Solve the optimization problem.\")\n\n            t_start = time.time()\n            model.solve(solver=solver.value,\n                        solve_kwargs=solve_kwargs,\n                        cmdline_options=cmdline_opts)\n\n            t_end = time.time()\n\n            self.logger.info(\"Completed after \" + str(round(t_end - t_start, 2)) + \" seconds.\")\n            self.logger.info(\"Store the energy system with the results.\")\n\n            ##########################################################################\n            # The processing module of the outputlib can be used to extract the results\n            # from the model transfer them into a homogeneous structured dictionary.\n            ##########################################################################\n            oemof_es.results[\"main\"] = solph.processing.results(model)\n            oemof_es.results[\"meta\"] = solph.processing.meta_results(model)\n            oemof_es.results[\"df\"] = solph.processing.create_dataframe(model)\n\n            self.logger.info(\"Dump file with results to: \" + os.path.join(self.DUMPING_DIRECTORY, filename))\n\n            oemof_es.dump(dpath=self.DUMPING_DIRECTORY, filename=filename)\n            self.logger.info(\"Fin.\")\n</code></pre>"},{"location":"ensys/common/modelbuilder/#common.modelbuilder.ModelBuilder.BuildEnergySystem","title":"<code>BuildEnergySystem(es, file, solver, solver_verbose, cmdline_opts, only_lp)</code>","text":"<p>Builds an energy system from a configuration file and prepares it for optimization. The method constructs an oemof energy system based on the provided configuration, populates it with components, adds constraints if specified, prepares log and LP files and optionally solves the optimization problem.</p> <p>Parameters:</p> Name Type Description Default <code>es</code> <code>EnEnergysystem</code> <p>The energy system configuration object containing attributes such as start_date, time_steps, frequenz, components, and constraints.</p> required <code>file</code> <code>str</code> <p>The configuration file for building the energy system.</p> required <code>solver</code> <code>Solver</code> <p>The solver to be used for optimization.</p> required <code>solver_verbose</code> <code>bool</code> <p>Boolean flag indicating whether detailed output by the solver should be logged.</p> required <code>cmdline_opts</code> <code>dict</code> <p>A dictionary of command-line options for the solver.</p> required <code>only_lp</code> <code>bool</code> <p>Boolean flag indicating if only the LP file should be stored without solving.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>ensys/common/modelbuilder.py</code> <pre><code>def BuildEnergySystem(self, es: EnEnergysystem, file: str, solver: Solver, solver_verbose: bool, cmdline_opts: dict,\n                      only_lp: bool):\n    \"\"\"\n    Builds an energy system from a configuration file and prepares it for optimization.\n    The method constructs an oemof energy system based on the provided configuration,\n    populates it with components, adds constraints if specified, prepares log and LP\n    files and optionally solves the optimization problem.\n\n    :param es: The energy system configuration object containing attributes such as\n        start_date, time_steps, frequenz, components, and constraints.\n    :type es: EnEnergysystem\n    :param file: The configuration file for building the energy system.\n    :type file: str\n    :param solver: The solver to be used for optimization.\n    :type solver: Solver\n    :param solver_verbose: Boolean flag indicating whether detailed output by the solver\n        should be logged.\n    :type solver_verbose: bool\n    :param cmdline_opts: A dictionary of command-line options for the solver.\n    :type cmdline_opts: dict\n    :param only_lp: Boolean flag indicating if only the LP file should be stored without\n        solving.\n    :type only_lp: bool\n    :return: None\n    \"\"\"\n    logging.basicConfig(filename='ensys.log', level=logging.INFO)\n    self.logger.info(\"Build an Energysystem from config file.\")\n    filename = os.path.basename(file)\n\n    ##########################################################################\n    # Build the oemof-energysystem\n    ##########################################################################\n    if es.frequenz is Interval.quarter_hourly:\n        freq = \"15min\"\n    elif es.frequenz is Interval.half_hourly:\n        freq = \"30min\"\n    elif es.frequenz is Interval.hourly:\n        freq = \"1h\"\n    else:\n        freq = \"H\"\n\n    timeindex = pd.date_range(start=es.start_date,\n                              periods=es.time_steps,\n                              freq=freq)\n\n    oemof_es = solph.EnergySystem(\n        timeindex=timeindex\n    )\n\n    except_vars = [\"label\", \"start_date\", \"time_steps\", \"frequenz\", \"constraints\"]\n\n    for attr in vars(es):\n        if attr not in except_vars:\n            self.logger.info(\"Build \" + attr)\n\n            arg_value = getattr(es, attr)\n\n            for value in arg_value:\n                oemof_obj = value.to_oemof(oemof_es)\n\n                if oemof_obj is not None:\n                    oemof_es.add(oemof_obj)\n\n    self.logger.info(\"Build completed.\")\n\n    # pre_dump_file = open(os.path.join(self.DUMPING_DIRECTORY, filename.replace(\".dump\", \"_pre-dump.dump\")), \"wt\")\n    # json_str = json.dumps(oemof_es.__dict__)\n    # pickle.dump(json_str, pre_dump_file)\n\n    ##########################################################################\n    # Initiate the energy system model\n    ##########################################################################\n    self.logger.info(\"Initiate the energy system model.\")\n    model = solph.Model(oemof_es, debug=False)\n\n    ##########################################################################\n    # Add Constraints to the model\n    ##########################################################################\n    self.logger.info(\"Adding constraints to the energy system model.\")\n    if hasattr(es, \"constraints\"):\n        for constr in es.constraints:\n            kwargs = constr.to_oemof()\n\n            if constr.typ == Constraints.shared_limit:\n                solph.constraints.shared_limit(model=model, **kwargs)\n\n            elif constr.typ == Constraints.investment_limit:\n                model = solph.constraints.investment_limit(model=model, **kwargs)\n\n            elif constr.typ == Constraints.additional_investment_flow_limit:\n                model = solph.constraints.additional_investment_flow_limit(model=model, **kwargs)\n\n            elif constr.typ == Constraints.generic_integral_limit:\n                model = solph.constraints.generic_integral_limit(om=model, **kwargs)\n\n            elif constr.typ == Constraints.emission_limit:\n                solph.constraints.emission_limit(om=model, **kwargs)\n\n            elif constr.typ == Constraints.limit_active_flow_count:\n                model = solph.constraints.limit_active_flow_count(model=model, **kwargs)\n\n            elif constr.typ == Constraints.limit_active_flow_count_by_keyword:\n                model = solph.constraints.limit_active_flow_count_by_keyword(model=model, **kwargs)\n\n            elif constr.typ == Constraints.equate_variables:\n                solph.constraints.equate_variables(model=model, **kwargs)\n\n    ### Create Logfile for Solver\n    logfile = os.path.join(self.LOGGING_DIRECTORY, filename.replace(\".dump\", \"_solver.log\"))\n    self.logger.info(\"Logfile: \" + self.LOGGING_DIRECTORY)\n\n    ### Store LP files\n    lp_filename = os.path.join(self.DUMPING_DIRECTORY, filename.replace(\".dump\", \".lp\"))\n\n    self.logger.info(\"Store lp-file in {0}.\".format(lp_filename))\n    model.write(lp_filename, io_options={\"symbolic_solver_labels\": True})\n    ### Set Environmental Variables for the solver\n    # map kwargs for pyomo.enviroment and later usage\n    solve_kwargs = {\"tee\": solver_verbose}\n    cmdline_opts[\"logfile\"] = logfile\n\n    if not only_lp:\n        ##########################################################################\n        # solving...\n        ##########################################################################\n        self.logger.info(\"Solve the optimization problem.\")\n\n        t_start = time.time()\n        model.solve(solver=solver.value,\n                    solve_kwargs=solve_kwargs,\n                    cmdline_options=cmdline_opts)\n\n        t_end = time.time()\n\n        self.logger.info(\"Completed after \" + str(round(t_end - t_start, 2)) + \" seconds.\")\n        self.logger.info(\"Store the energy system with the results.\")\n\n        ##########################################################################\n        # The processing module of the outputlib can be used to extract the results\n        # from the model transfer them into a homogeneous structured dictionary.\n        ##########################################################################\n        oemof_es.results[\"main\"] = solph.processing.results(model)\n        oemof_es.results[\"meta\"] = solph.processing.meta_results(model)\n        oemof_es.results[\"df\"] = solph.processing.create_dataframe(model)\n\n        self.logger.info(\"Dump file with results to: \" + os.path.join(self.DUMPING_DIRECTORY, filename))\n\n        oemof_es.dump(dpath=self.DUMPING_DIRECTORY, filename=filename)\n        self.logger.info(\"Fin.\")\n</code></pre>"},{"location":"ensys/common/modelbuilder/#common.modelbuilder.ModelBuilder.__init__","title":"<code>__init__(ConfigFile, DumpFile, wdir, logdir, dumpdir, only_lp=False)</code>","text":"<p>Initializes an instance with specified configuration and directory settings. This constructor also handles the loading of the model configuration from a JSON file, sets up logging and initiates the energy system building process based on the parameters provided. An exception is raised if the configuration file does not follow the expected JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>ConfigFile</code> <code>str</code> <p>Path to the JSON configuration file that defines the energy system model.</p> required <code>DumpFile</code> <code>str</code> <p>File path where the results or intermediary data will be saved during the process.</p> required <code>wdir</code> <code>str</code> <p>Working directory path within the current directory to be used for intermediate processing.</p> required <code>logdir</code> <code>str</code> <p>Directory path for saving log files generated during execution.</p> required <code>dumpdir</code> <code>str</code> <p>Directory path for saving system dump files.</p> required <code>only_lp</code> <code>bool</code> <p>Indicator for whether only linear programming should be used in the energy system solver.</p> <code>False</code> Source code in <code>ensys/common/modelbuilder.py</code> <pre><code>def __init__(self,\n             ConfigFile: str,\n             DumpFile: str,\n             wdir: str,\n             logdir: str,\n             dumpdir: str,\n             only_lp: bool = False\n             ) -&gt; None:\n    \"\"\"\n    Initializes an instance with specified configuration and directory settings. This constructor also handles the loading\n    of the model configuration from a JSON file, sets up logging and initiates the energy system building process based on\n    the parameters provided. An exception is raised if the configuration file does not follow the expected JSON format.\n\n    :param ConfigFile: Path to the JSON configuration file that defines the energy system model.\n    :type ConfigFile: str\n    :param DumpFile: File path where the results or intermediary data will be saved during the process.\n    :type DumpFile: str\n    :param wdir: Working directory path within the current directory to be used for intermediate processing.\n    :type wdir: str\n    :param logdir: Directory path for saving log files generated during execution.\n    :type logdir: str\n    :param dumpdir: Directory path for saving system dump files.\n    :type dumpdir: str\n    :param only_lp: Indicator for whether only linear programming should be used in the energy system solver.\n    :type only_lp: bool, optional\n    \"\"\"\n\n    self.WORKING_DIRECTORY = os.path.join(os.getcwd(), wdir)\n    if not os.path.exists(self.WORKING_DIRECTORY):\n        os.makedirs(self.WORKING_DIRECTORY)\n\n    self.LOGGING_DIRECTORY = logdir\n    if not os.path.exists(self.LOGGING_DIRECTORY):\n        os.makedirs(self.LOGGING_DIRECTORY)\n\n    self.DUMPING_DIRECTORY = dumpdir\n    if not os.path.exists(self.DUMPING_DIRECTORY):\n        os.makedirs(self.DUMPING_DIRECTORY)\n\n    # handle various filetypes\n    logfile = os.path.basename(ConfigFile)\n\n    if ConfigFile.find(\".json\") &gt; 0:\n        logfile = logfile.replace(\".json\", \".log\")\n\n        xf = open(ConfigFile, 'rt')\n        model_dict = json.load(xf)\n        model = EnModel(**model_dict)\n        xf.close()\n    else:\n        raise Exception(\"Fileformat is not valid!\")\n\n    tools.logger.define_logging(logpath=self.LOGGING_DIRECTORY, logfile=logfile, file_level=logging.INFO,\n                                screen_level=logging.INFO)\n    self.logger.info(\"Start Building and solving\")\n\n    if hasattr(model, \"solver_kwargs\") and model.solver_kwargs is not None:\n        cmdline_opts = model.solver_kwargs\n    else:\n        cmdline_opts = {}\n\n    self.BuildEnergySystem(model.energysystem, DumpFile, model.solver, model.solver_verbose,\n                           cmdline_opts=cmdline_opts, only_lp=only_lp)\n</code></pre>"},{"location":"ensys/common/types/","title":"Types","text":"<p>Info</p> <p>Constraints need a rework, to be done.</p>"},{"location":"ensys/common/types/#common.types.Constraints","title":"<code>Constraints</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Represents a collection of constraints that can be applied to a model in the context of optimization problems. These constraints encompass various types of bounds and limits, allowing the user to define investments, flow restrictions, and active flow management to match specific use cases or requirements effectively.</p> <p>Attributes:</p> Name Type Description <code>shared_limit</code> <p>Adds a constraint to the given model that restricts the weighted sum of variables to a corridor.</p> <code>investment_limit</code> <p>Sets an absolute limit for the total investment costs of an investment optimization problem.</p> <code>additional_investment_flow_limit</code> <p>Global limit for investment flows weighted by an attribute keyword. This constraint is only valid for Flows, not for components such as an investment storage. The attribute named by the keyword must be added to every Investment attribute of the flow to be considered. The total value of keyword attributes after optimization can be retrieved by calling <code>oemof.solph.Model.invest_limit_${keyword}</code>. (Mathematically represented as: \u03a3 (P_i * w_i) \u2264 limit, where IF is the set of InvestmentFlows considered for the integral limit.)</p> <code>generic_integral_limit</code> <p>Sets a global limit for flows weighted by an attribute called a keyword. The attribute named by the keyword must be added to every flow considered.</p> <code>emission_limit</code> <p>Short handle for <code>generic_integral_limit()</code> with <code>keyword=\"emission_factor\"</code>.</p> <code>limit_active_flow_count</code> <p>Sets limits (lower and/or upper) for the number of concurrently active NonConvex flows. The flows are provided as a list.</p> <code>limit_active_flow_count_by_keyword</code> <p>Wrapper for <code>limit_active_flow_count</code> that allows setting limits to the count of concurrently active flows by using a keyword instead of a list. The constraint will be named as <code>${keyword}_count</code>.</p> <code>equate_variables</code> <p>Ensures that specified variables within the optimization problem are treated as equivalent.</p> Source code in <code>ensys/common/types.py</code> <pre><code>class Constraints(Enum):\n    \"\"\"\n    Represents a collection of constraints that can be applied to a model in the context of\n    optimization problems. These constraints encompass various types of bounds and limits, allowing\n    the user to define investments, flow restrictions, and active flow management to match specific\n    use cases or requirements effectively.\n\n    :ivar shared_limit: Adds a constraint to the given model that restricts the weighted sum of\n        variables to a corridor.\n    :type shared_limit: str\n    :ivar investment_limit: Sets an absolute limit for the total investment costs of an investment\n        optimization problem.\n    :type investment_limit: str\n    :ivar additional_investment_flow_limit: Global limit for investment flows weighted by an\n        attribute keyword. This constraint is only valid for Flows, not for components such as an\n        investment storage. The attribute named by the keyword must be added to every Investment\n        attribute of the flow to be considered. The total value of keyword attributes after\n        optimization can be retrieved by calling `oemof.solph.Model.invest_limit_${keyword}`.\n        (Mathematically represented as: \u03a3 (P_i * w_i) \u2264 limit, where IF is the set of\n        InvestmentFlows considered for the integral limit.)\n    :type additional_investment_flow_limit: str\n    :ivar generic_integral_limit: Sets a global limit for flows weighted by an attribute called a\n        keyword. The attribute named by the keyword must be added to every flow considered.\n    :type generic_integral_limit: str\n    :ivar emission_limit: Short handle for `generic_integral_limit()` with `keyword=\"emission_factor\"`.\n    :type emission_limit: str\n    :ivar limit_active_flow_count: Sets limits (lower and/or upper) for the number of concurrently\n        active NonConvex flows. The flows are provided as a list.\n    :type limit_active_flow_count: str\n    :ivar limit_active_flow_count_by_keyword: Wrapper for `limit_active_flow_count` that allows setting\n        limits to the count of concurrently active flows by using a keyword instead of a list. The\n        constraint will be named as `${keyword}_count`.\n    :type limit_active_flow_count_by_keyword: str\n    :ivar equate_variables: Ensures that specified variables within the optimization problem are\n        treated as equivalent.\n    :type equate_variables: str\n    \"\"\"\n    shared_limit = 'shared_limit'\n    investment_limit = 'investment_limit'\n    additional_investment_flow_limit = 'additional_investment_flow_limit'\n    generic_integral_limit = 'generic_integral_limit'\n    emission_limit = 'emission_limit'\n    limit_active_flow_count = 'limit_active_flow_count'\n    limit_active_flow_count_by_keyword = 'limit_active_flow_count_by_keyword'\n    equate_variables = 'equate_variables'\n</code></pre>"},{"location":"ensys/common/types/#common.types.Interval","title":"<code>Interval</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Represents various fixed time intervals available for use.</p> <p>This class is an enumeration that defines specific time intervals as constants, describing their corresponding durations in hours. The intervals are represented as descriptive names and associated with their numerical values (in fractional hours). These values can be leveraged to standardize time-related calculations.</p> <p>Attributes:</p> Name Type Description <code>quarter_hourly</code> <p>Represents a timestep of 15 minutes.</p> <code>half_hourly</code> <p>Represents a timestep of 30 minutes.</p> <code>hourly</code> <p>Represents a timestep of 60 minutes.</p> Source code in <code>ensys/common/types.py</code> <pre><code>class Interval(Enum):\n    \"\"\"\n    Represents various fixed time intervals available for use.\n\n    This class is an enumeration that defines specific time intervals as constants,\n    describing their corresponding durations in hours. The intervals are represented\n    as descriptive names and associated with their numerical values (in fractional\n    hours). These values can be leveraged to standardize time-related calculations.\n\n    :ivar quarter_hourly: Represents a timestep of 15 minutes.\n    :type quarter_hourly: float\n    :ivar half_hourly: Represents a timestep of 30 minutes.\n    :type half_hourly: float\n    :ivar hourly: Represents a timestep of 60 minutes.\n    :type hourly: int\n    \"\"\"\n    quarter_hourly = 0.25\n    half_hourly = 0.5\n    hourly = 1\n</code></pre>"},{"location":"ensys/common/types/#common.types.Solver","title":"<code>Solver</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Represents enumeration of different solvers available for mathematical programming.</p> <p>The class provides a list of solvers used in optimization problems. These include different solvers for linear programming and mixed-integer linear programming. It allows explicit references to specific solvers and can be helpful for choosing the most compatible solver for a given optimization task.</p> <p>Attributes:</p> Name Type Description <code>cbc</code> <p>COIN-OR Branch-and-Cut Solver.</p> <code>gurobi</code> <p>Gurobi MILP Solver.</p> <code>gurobi_direct</code> <p>Gurobi MILP Solver (Direct interface).</p> <code>gurobi_persistent</code> <p>Gurobi MILP Solver (Persistent interface).</p> <code>glpk</code> <p>GNU Linear Programming Kit Solver.</p> <code>cplex</code> <p>IBM ILOG CPLEX Optimization Solver.</p> <code>kiwi</code> <p>Kiwisolver from PyPI.</p> Source code in <code>ensys/common/types.py</code> <pre><code>class Solver(Enum):\n    \"\"\"\n    Represents enumeration of different solvers available for mathematical programming.\n\n    The class provides a list of solvers used in optimization problems. These include\n    different solvers for linear programming and mixed-integer linear programming. It\n    allows explicit references to specific solvers and can be helpful for choosing the\n    most compatible solver for a given optimization task.\n\n    :ivar cbc: COIN-OR Branch-and-Cut Solver.\n    :type cbc: str\n    :ivar gurobi: Gurobi MILP Solver.\n    :type gurobi: str\n    :ivar gurobi_direct: Gurobi MILP Solver (Direct interface).\n    :type gurobi_direct: str\n    :ivar gurobi_persistent: Gurobi MILP Solver (Persistent interface).\n    :type gurobi_persistent: str\n    :ivar glpk: GNU Linear Programming Kit Solver.\n    :type glpk: str\n    :ivar cplex: IBM ILOG CPLEX Optimization Solver.\n    :type cplex: str\n    :ivar kiwi: Kiwisolver from PyPI.\n    :type kiwi: str\n    \"\"\"\n    cbc = 'cbc'\n    gurobi = 'gurobi'\n    gurobi_direct = 'gurobi_direct'\n    gurobi_persistent = 'gurobi_persistent'\n    glpk = 'glpk'\n    cplex = 'cplex'\n    kiwi = 'kiwi'\n</code></pre>"},{"location":"ensys/components/bus/","title":"Bus","text":""},{"location":"ensys/components/bus/#components.bus.EnBus","title":"<code>EnBus</code>","text":"<p>               Bases: <code>EnBaseModel</code></p> <p>Represents a bus in an energy system model.</p> <p>This class is used to define a bus element, which is a central node in an energy system. The bus connects different components such as sources, demands, and transformers and facilitates the movement of energy between them. It also checks for balance in energy inflows and outflows at every timestep.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>String holding the label of the Bus object. The label of each object must be unique.</p> <code>balanced</code> <code>bool</code> <p>Indicates if the bus is balanced, i.e., if the sum of inflows equals the sum of outflows for each timestep; defaults to True.</p> Source code in <code>ensys/components/bus.py</code> <pre><code>class EnBus(EnBaseModel):\n    \"\"\"\n    Represents a bus in an energy system model.\n\n    This class is used to define a bus element, which is a central node in an energy\n    system. The bus connects different components such as sources, demands, and\n    transformers and facilitates the movement of energy between them. It also checks for\n    balance in energy inflows and outflows at every timestep.\n\n    :ivar label: String holding the label of the Bus object. The label of each object must\n        be unique.\n    :type label: str\n    :ivar balanced: Indicates if the bus is balanced, i.e., if the sum of inflows equals\n        the sum of outflows for each timestep; defaults to True.\n    :type balanced: bool\n    \"\"\"\n    label: str = Field(\n        ...,\n        title='Label',\n        description='String holding the label of the Bus object. The label of each object must be unique.'\n    )\n\n    balanced: bool = Field(\n        default=True,\n        title='Balanced',\n        description=' Indicates if bus is balanced, i.e. if the sum of inflows equals to the sum of outflows for each timestep; defaults to True'\n    )\n\n    def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.Bus:\n        \"\"\"\n        Converts the current instance into an oemof.solph.Bus object using the\n        provided energy system. This method prepares necessary keyword arguments\n        from the energy system to initialize and return a solph.Bus instance.\n\n        :param energysystem: An instance of solph.EnergySystem used to build\n            keyword arguments for the solph.Bus.\n        :type energysystem: solph.EnergySystem\n        :return: A solph.Bus object initialized with the built keyword arguments.\n        :rtype: solph.Bus\n        \"\"\"\n        kwargs = self.build_kwargs(energysystem)\n\n        return solph.Bus(**kwargs)\n</code></pre>"},{"location":"ensys/components/bus/#components.bus.EnBus.to_oemof","title":"<code>to_oemof(energysystem)</code>","text":"<p>Converts the current instance into an oemof.solph.Bus object using the provided energy system. This method prepares necessary keyword arguments from the energy system to initialize and return a solph.Bus instance.</p> <p>Parameters:</p> Name Type Description Default <code>energysystem</code> <code>EnergySystem</code> <p>An instance of solph.EnergySystem used to build keyword arguments for the solph.Bus.</p> required <p>Returns:</p> Type Description <code>solph.Bus</code> <p>A solph.Bus object initialized with the built keyword arguments.</p> Source code in <code>ensys/components/bus.py</code> <pre><code>def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.Bus:\n    \"\"\"\n    Converts the current instance into an oemof.solph.Bus object using the\n    provided energy system. This method prepares necessary keyword arguments\n    from the energy system to initialize and return a solph.Bus instance.\n\n    :param energysystem: An instance of solph.EnergySystem used to build\n        keyword arguments for the solph.Bus.\n    :type energysystem: solph.EnergySystem\n    :return: A solph.Bus object initialized with the built keyword arguments.\n    :rtype: solph.Bus\n    \"\"\"\n    kwargs = self.build_kwargs(energysystem)\n\n    return solph.Bus(**kwargs)\n</code></pre>"},{"location":"ensys/components/constraints/","title":"Constraints","text":""},{"location":"ensys/components/constraints/#components.constraints.EnConstraints","title":"<code>EnConstraints</code>","text":"<p>               Bases: <code>EnBaseModel</code></p> <p>Represents constraint definitions used for various optimization models.</p> <p>The <code>EnConstraints</code> class is used for defining constraints within an optimization framework. It allows the user to configure various parameters of the constraint, such as the variables involved, proportional factors, limits, and weights. Additionally, the class provides functionality to parse its data into a format suited for downstream usage.</p> <p>Attributes:</p> Name Type Description <code>typ</code> <code>Constraints | None</code> <p>Type of the Constraints, all possible types are given in the Enum types.Constraints</p> <code>var1</code> <code>object | None</code> <p>First variable, to be set to equal with Var2 and multiplied with factor1.</p> <code>var2</code> <code>object | None</code> <p>Second variable, to be set equal to (Var1 * factor1).</p> <code>factor1</code> <code>float | None</code> <p>Factor to define the proportion between the variables.</p> <code>name</code> <code>str | None</code> <p>Optional name for the equation e.g. in the LP file. By default the name is: equate + string representation of var1 and var2.</p> <code>keyword</code> <code>str | None</code> <p>Keyword to consider (searches all NonConvexFlows).</p> <code>quantity</code> <code>object | None</code> <p>Shared Pyomo variable for all components of a type.</p> <code>limit_name</code> <code>str | None</code> <p>Name of the constraint to create.</p> <code>components</code> <code>list | None</code> <p>List of components from the same type.</p> <code>weights</code> <code>list[float] | None</code> <p>It has to have the same length as the list of components</p> <code>limit</code> <code>float | None</code> <p>Absolute limit of keyword attribute for the energy system.</p> <code>flows</code> <code>list | dict | None</code> <p>List or dictionary that describes flows relevant to the constraint.</p> <code>constraint_name</code> <code>str | None</code> <p>Name assigned to the constraint.</p> <code>upper_limit</code> <code>int | None</code> <p>Maximum number of active flows in the list</p> <code>lower_limit</code> <code>int | None</code> <p>Minimum number of active flows in the list</p> Source code in <code>ensys/components/constraints.py</code> <pre><code>class EnConstraints(EnBaseModel):\n    \"\"\"\n    Represents constraint definitions used for various optimization models.\n\n    The `EnConstraints` class is used for defining constraints within an optimization\n    framework. It allows the user to configure various parameters of the constraint, such as\n    the variables involved, proportional factors, limits, and weights. Additionally, the\n    class provides functionality to parse its data into a format suited for downstream\n    usage.\n\n    :ivar typ: Type of the Constraints, all possible types are given in the Enum types.Constraints\n    :ivar var1: First variable, to be set to equal with Var2 and multiplied with factor1.\n    :ivar var2: Second variable, to be set equal to (Var1 * factor1).\n    :ivar factor1: Factor to define the proportion between the variables.\n    :ivar name: Optional name for the equation e.g. in the LP file. By default the name is: equate + string representation of var1 and var2.\n    :ivar keyword: Keyword to consider (searches all NonConvexFlows).\n    :ivar quantity: Shared Pyomo variable for all components of a type.\n    :ivar limit_name: Name of the constraint to create.\n    :ivar components: List of components from the same type.\n    :ivar weights: It has to have the same length as the list of components\n    :ivar limit: Absolute limit of keyword attribute for the energy system.\n    :ivar flows: List or dictionary that describes flows relevant to the constraint.\n    :ivar constraint_name: Name assigned to the constraint.\n    :ivar upper_limit: Maximum number of active flows in the list\n    :ivar lower_limit: Minimum number of active flows in the list\n    \"\"\"\n    typ: Constraints | None = Field(\n        None,\n        title='Typ',\n        description='Type of the constraint.'\n    )\n\n    var1: object | None = Field(\n        None,\n        title='var1',\n        description='First variable, to be set to equal with Var2 and multiplied with factor1.'\n    )\n\n    var2: object | None = Field(\n        None,\n        title='var2',\n        description='Second variable, to be set equal to (Var1 * factor1).'\n    )\n\n    factor1: float | None = Field(\n        None,\n        title='factor1',\n        description='Factor to define the proportion between the variables.',\n    )\n\n    name: str | None = Field(\n        None,\n        title='Name',\n        description='Optional name'\n    )\n\n    keyword: str | None = Field(\n        None,\n        title='Keyword',\n        description='Keyword to consider (searches all NonConvexFlows)'\n    )\n\n    quantity: object | None = Field(\n        None,\n        title='Quantity',\n        description=''\n    )\n\n    limit_name: str | None = Field(\n        None,\n        title='Limit Name',\n        description=''\n    )\n\n    components: list | None = Field(\n        None,\n        title='Components',\n        description=''\n    )\n\n    weights: list[float] | None = Field(\n        None,\n        title='Weights',\n        description=''\n    )\n\n    limit: float | None = Field(\n        None,\n        title='Limit',\n        description=''\n    )\n\n    flows: list | dict | None = Field(\n        None,\n        title='Flows',\n        description=''\n    )\n\n    constraint_name: str | None = Field(\n        None,\n        title='constraint name',\n        description=''\n    )\n\n    upper_limit: int | None = Field(\n        None,\n        title='Upper Limit',\n        description=''\n    )\n\n    lower_limit: int | None = Field(\n        None,\n        title='Lower Limit',\n        description=''\n    )\n\n    def to_oemof(self) -&gt; dict[str, dict]:\n        \"\"\"\n        Converts the attributes of the current instance into a dictionary format.\n\n        This method iterates through all the attributes of the instance, excluding the\n        attribute named \"typ\". If an attribute is not `None`, it is added to the resulting\n        dictionary. The resulting dictionary represents the instance in a format compatible\n        for further usage or processing.\n\n        :return: A dictionary representation of the instance where keys are attribute names\n                 and values are their corresponding data, excluding attributes that are `None`\n                 or named \"typ\".\n        :rtype: dict[str, dict]\n        \"\"\"\n        args = {}\n        for var in vars(self):\n            if var != \"typ\":\n                if vars(self)[var] is not None:\n                    args[var] = vars(self)[var]\n\n        return args\n</code></pre>"},{"location":"ensys/components/constraints/#components.constraints.EnConstraints.to_oemof","title":"<code>to_oemof()</code>","text":"<p>Converts the attributes of the current instance into a dictionary format.</p> <p>This method iterates through all the attributes of the instance, excluding the attribute named \"typ\". If an attribute is not <code>None</code>, it is added to the resulting dictionary. The resulting dictionary represents the instance in a format compatible for further usage or processing.</p> <p>Returns:</p> Type Description <code>dict[str, dict]</code> <p>A dictionary representation of the instance where keys are attribute names and values are their corresponding data, excluding attributes that are <code>None</code> or named \"typ\".</p> Source code in <code>ensys/components/constraints.py</code> <pre><code>def to_oemof(self) -&gt; dict[str, dict]:\n    \"\"\"\n    Converts the attributes of the current instance into a dictionary format.\n\n    This method iterates through all the attributes of the instance, excluding the\n    attribute named \"typ\". If an attribute is not `None`, it is added to the resulting\n    dictionary. The resulting dictionary represents the instance in a format compatible\n    for further usage or processing.\n\n    :return: A dictionary representation of the instance where keys are attribute names\n             and values are their corresponding data, excluding attributes that are `None`\n             or named \"typ\".\n    :rtype: dict[str, dict]\n    \"\"\"\n    args = {}\n    for var in vars(self):\n        if var != \"typ\":\n            if vars(self)[var] is not None:\n                args[var] = vars(self)[var]\n\n    return args\n</code></pre>"},{"location":"ensys/components/converter/","title":"Converter","text":""},{"location":"ensys/components/converter/#components.converter.EnConverter","title":"<code>EnConverter</code>","text":"<p>               Bases: <code>EnBaseModel</code></p> <p>Represents a converter class for modeling energy systems.</p> <p>This class is designed to manage conversion processes between inputs and outputs in an energy system model. It allows defining inflows and outflows with specific conversion factors and integrates with <code>oemof</code> to build compatible energy system components. The <code>label</code> attribute ensures that each converter has a unique, identifiable name in the system.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>A unique label identifying the converter.</p> <code>inputs</code> <code>dict[str, EnFlow]</code> <p>Dictionary of inflows with their starting nodes.</p> <code>outputs</code> <code>dict[str, EnFlow]</code> <p>Dictionary of outflows with their ending nodes.</p> <code>conversion_factors</code> <code>dict[str, float | list[float]]</code> <p>Dictionary of conversion factors, where each key corresponds to connected nodes and values can be a scalar or a list of conversion factors for time-dependent variations. If unspecified, defaults to 1 for all flows.</p> Source code in <code>ensys/components/converter.py</code> <pre><code>class EnConverter(EnBaseModel):\n    \"\"\"\n    Represents a converter class for modeling energy systems.\n\n    This class is designed to manage conversion processes between inputs and\n    outputs in an energy system model. It allows defining inflows and outflows\n    with specific conversion factors and integrates with `oemof` to build\n    compatible energy system components. The `label` attribute ensures that each\n    converter has a unique, identifiable name in the system.\n\n    :ivar label: A unique label identifying the converter.\n    :type label: str\n    :ivar inputs: Dictionary of inflows with their starting nodes.\n    :type inputs: dict[str, EnFlow]\n    :ivar outputs: Dictionary of outflows with their ending nodes.\n    :type outputs: dict[str, EnFlow]\n    :ivar conversion_factors: Dictionary of conversion factors, where each key\n        corresponds to connected nodes and values can be a scalar or a list of\n        conversion factors for time-dependent variations. If unspecified, defaults\n        to 1 for all flows.\n    :type conversion_factors: dict[str, float | list[float]]\n    \"\"\"\n    label: str = Field(\n        \"Default Converter\",\n        title='Label',\n        description='String holding the label of the Converter object. The label of each object must be unique.'\n    )\n\n    inputs: dict[str, EnFlow] = Field(\n        ...,\n        title='Inputs',\n        description='Dictionary with inflows. Keys must be the starting node(s) of the inflow(s)'\n    )\n\n    outputs: dict[str, EnFlow] = Field(\n        ...,\n        title='Outputs',\n        description='Dictionary with outflows. Keys must be the ending node(s) of the outflow(s)'\n    )\n\n    conversion_factors: dict[str, float | list[float]] = Field(\n        ...,\n        title='Conversion Factors',\n        description='Dictionary containing conversion factors for conversion of each flow. Keys must be the connected nodes (typically Buses). The dictionary values can either be a scalar or an iterable with individual conversion factors for each time step. Default: 1. If no conversion_factor is given for an in- or outflow, the conversion_factor is set to 1'\n    )\n\n    def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.components.Converter:\n        \"\"\"\n        Converts the current instance into an oemof.solph Converter object and integrates\n        it into the provided oemof EnergySystem. This method prepares and builds the\n        necessary keyword arguments from the instance's state and passes them into\n        the Converter component.\n\n        :param energysystem: An oemof.solph EnergySystem instance that serves as a\n            container storing energy models, components, and their relations.\n        :type energysystem: solph.EnergySystem\n        :return: An oemof.solph.Converter instance initialized and built using the\n            processed arguments from this instance's data.\n        :rtype: solph.components.Converter\n        \"\"\"\n        kwargs = self.build_kwargs(energysystem)\n\n        return solph.components.Converter(**kwargs)\n</code></pre>"},{"location":"ensys/components/converter/#components.converter.EnConverter.to_oemof","title":"<code>to_oemof(energysystem)</code>","text":"<p>Converts the current instance into an oemof.solph Converter object and integrates it into the provided oemof EnergySystem. This method prepares and builds the necessary keyword arguments from the instance's state and passes them into the Converter component.</p> <p>Parameters:</p> Name Type Description Default <code>energysystem</code> <code>EnergySystem</code> <p>An oemof.solph EnergySystem instance that serves as a container storing energy models, components, and their relations.</p> required <p>Returns:</p> Type Description <code>solph.components.Converter</code> <p>An oemof.solph.Converter instance initialized and built using the processed arguments from this instance's data.</p> Source code in <code>ensys/components/converter.py</code> <pre><code>def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.components.Converter:\n    \"\"\"\n    Converts the current instance into an oemof.solph Converter object and integrates\n    it into the provided oemof EnergySystem. This method prepares and builds the\n    necessary keyword arguments from the instance's state and passes them into\n    the Converter component.\n\n    :param energysystem: An oemof.solph EnergySystem instance that serves as a\n        container storing energy models, components, and their relations.\n    :type energysystem: solph.EnergySystem\n    :return: An oemof.solph.Converter instance initialized and built using the\n        processed arguments from this instance's data.\n    :rtype: solph.components.Converter\n    \"\"\"\n    kwargs = self.build_kwargs(energysystem)\n\n    return solph.components.Converter(**kwargs)\n</code></pre>"},{"location":"ensys/components/energysystem/","title":"Energysystem","text":""},{"location":"ensys/components/energysystem/#components.energysystem.EnEnergysystem","title":"<code>EnEnergysystem</code>","text":"<p>               Bases: <code>EnBaseModel</code></p> <p>Represents an energy system consisting of various components including busses, sinks, sources, converters, generic storages, and constraints.</p> <p>This class serves as a model for energy systems where components can be added and managed. It provides methods to organize these components and convert them into a format suitable for oemof energy systems, enabling seamless integration with oemof's modeling and analysis tools.</p> <p>Attributes:</p> Name Type Description <code>busses</code> <code>list[EnBus]</code> <p>List of all busses in the energy system.</p> <code>sinks</code> <code>list[EnSink]</code> <p>List of all sinks in the energy system.</p> <code>sources</code> <code>list[EnSource]</code> <p>List of all sources in the energy system.</p> <code>converters</code> <code>list[EnConverter]</code> <p>List of all converters in the energy system.</p> <code>generic_storages</code> <code>list[EnGenericStorage]</code> <p>List of all generic storages in the energy system.</p> <code>constraints</code> <code>list[EnConstraints]</code> <p>List of all constraints associated with the energy system.</p> Source code in <code>ensys/components/energysystem.py</code> <pre><code>class EnEnergysystem(EnBaseModel):\n    \"\"\"\n    Represents an energy system consisting of various components including busses,\n    sinks, sources, converters, generic storages, and constraints.\n\n    This class serves as a model for energy systems where components can be added\n    and managed. It provides methods to organize these components and convert them\n    into a format suitable for oemof energy systems, enabling seamless integration\n    with oemof's modeling and analysis tools.\n\n    :ivar busses: List of all busses in the energy system.\n    :type busses: list[EnBus]\n    :ivar sinks: List of all sinks in the energy system.\n    :type sinks: list[EnSink]\n    :ivar sources: List of all sources in the energy system.\n    :type sources: list[EnSource]\n    :ivar converters: List of all converters in the energy system.\n    :type converters: list[EnConverter]\n    :ivar generic_storages: List of all generic storages in the energy system.\n    :type generic_storages: list[EnGenericStorage]\n    :ivar constraints: List of all constraints associated with the energy system.\n    :type constraints: list[EnConstraints]\n    \"\"\"\n    busses: list[EnBus] = Field(\n        default=[],\n        title='Busses',\n        description='List of all busses.'\n    )\n\n    sinks: list[EnSink] = Field(\n        default=[],\n        title='Sinks',\n        description='List of all sinks.'\n    )\n\n    sources: list[EnSource] = Field(\n        default=[],\n        title='Sources',\n        description='List of all sources.'\n    )\n\n    converters: list[EnConverter] = Field(\n        default=[],\n        title='Converters',\n        description='List of all converters.'\n    )\n\n    generic_storages: list[EnGenericStorage] = Field(\n        default=[],\n        title='Generic Storages',\n        description='List of all generic storages.'\n    )\n\n    constraints: list[EnConstraints] = Field(\n        default=[],\n        title='Constraints',\n        description='List of all constraints.'\n    )\n\n    def add(self, elem: EnSink | EnSource | EnBus | EnGenericStorage | EnConverter | EnConstraints):\n        \"\"\"\n        Adds an element to the corresponding list based on its type. Determines\n        the type of the given element and appends it to its respective\n        container (e.g., sinks, sources, busses, etc.). Raises an exception\n        if the type of the element is not recognized.\n\n        :param elem: The element to be added. It should be one of the following\n                     types: EnSink, EnSource, EnBus, EnGenericStorage,\n                     EnConverter, or EnConstraints.\n        :type elem: EnSink | EnSource | EnBus | EnGenericStorage | EnConverter | EnConstraints\n        :return: None\n        \"\"\"\n        if type(elem) is EnSink:\n            self.sinks.append(elem)\n        elif type(elem) is EnSource:\n            self.sources.append(elem)\n        elif type(elem) is EnBus:\n            self.busses.append(elem)\n        elif type(elem) in [EnGenericStorage]:\n            self.generic_storages.append(elem)\n        elif type(elem) is EnConverter:\n            self.converters.append(elem)\n        elif type(elem) is EnConstraints:\n            self.constraints.append(elem)\n        else:\n            raise Exception(\"Unknown Type given!\")\n\n    def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.EnergySystem:\n        \"\"\"\n        Converts the internal energy system components to an oemof energy system and adds\n        them to the provided oemof energy system instance. Each component in the internal\n        energy system is iterated through, converted to its corresponding oemof object,\n        and subsequently added to the provided energy system. This includes busses, sinks,\n        sources, converters, and generic storages.\n\n        :param energysystem: The oemof energy system instance to which the converted components\n            of the internal energy system are added.\n        :return: An updated oemof energy system instance containing all converted components.\n        :rtype: solph.EnergySystem\n        \"\"\"\n        for bus in self.busses:\n            energysystem.add(bus.to_oemof(energysystem))\n\n        for sink in self.sinks:\n            energysystem.add(sink.to_oemof(energysystem))\n\n        for source in self.sources:\n            energysystem.add(source.to_oemof(energysystem))\n\n        for converter in self.converters:\n            energysystem.add(converter.to_oemof(energysystem))\n\n        for generic_storage in self.generic_storages:\n            energysystem.add(generic_storage.to_oemof(energysystem))\n\n        # TODO: Adding Constraints\n\n        return energysystem\n</code></pre>"},{"location":"ensys/components/energysystem/#components.energysystem.EnEnergysystem.add","title":"<code>add(elem)</code>","text":"<p>Adds an element to the corresponding list based on its type. Determines the type of the given element and appends it to its respective container (e.g., sinks, sources, busses, etc.). Raises an exception if the type of the element is not recognized.</p> <p>Parameters:</p> Name Type Description Default <code>elem</code> <code>EnSink | EnSource | EnBus | EnGenericStorage | EnConverter | EnConstraints</code> <p>The element to be added. It should be one of the following types: EnSink, EnSource, EnBus, EnGenericStorage, EnConverter, or EnConstraints.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>ensys/components/energysystem.py</code> <pre><code>def add(self, elem: EnSink | EnSource | EnBus | EnGenericStorage | EnConverter | EnConstraints):\n    \"\"\"\n    Adds an element to the corresponding list based on its type. Determines\n    the type of the given element and appends it to its respective\n    container (e.g., sinks, sources, busses, etc.). Raises an exception\n    if the type of the element is not recognized.\n\n    :param elem: The element to be added. It should be one of the following\n                 types: EnSink, EnSource, EnBus, EnGenericStorage,\n                 EnConverter, or EnConstraints.\n    :type elem: EnSink | EnSource | EnBus | EnGenericStorage | EnConverter | EnConstraints\n    :return: None\n    \"\"\"\n    if type(elem) is EnSink:\n        self.sinks.append(elem)\n    elif type(elem) is EnSource:\n        self.sources.append(elem)\n    elif type(elem) is EnBus:\n        self.busses.append(elem)\n    elif type(elem) in [EnGenericStorage]:\n        self.generic_storages.append(elem)\n    elif type(elem) is EnConverter:\n        self.converters.append(elem)\n    elif type(elem) is EnConstraints:\n        self.constraints.append(elem)\n    else:\n        raise Exception(\"Unknown Type given!\")\n</code></pre>"},{"location":"ensys/components/energysystem/#components.energysystem.EnEnergysystem.to_oemof","title":"<code>to_oemof(energysystem)</code>","text":"<p>Converts the internal energy system components to an oemof energy system and adds them to the provided oemof energy system instance. Each component in the internal energy system is iterated through, converted to its corresponding oemof object, and subsequently added to the provided energy system. This includes busses, sinks, sources, converters, and generic storages.</p> <p>Parameters:</p> Name Type Description Default <code>energysystem</code> <code>EnergySystem</code> <p>The oemof energy system instance to which the converted components of the internal energy system are added.</p> required <p>Returns:</p> Type Description <code>solph.EnergySystem</code> <p>An updated oemof energy system instance containing all converted components.</p> Source code in <code>ensys/components/energysystem.py</code> <pre><code>def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.EnergySystem:\n    \"\"\"\n    Converts the internal energy system components to an oemof energy system and adds\n    them to the provided oemof energy system instance. Each component in the internal\n    energy system is iterated through, converted to its corresponding oemof object,\n    and subsequently added to the provided energy system. This includes busses, sinks,\n    sources, converters, and generic storages.\n\n    :param energysystem: The oemof energy system instance to which the converted components\n        of the internal energy system are added.\n    :return: An updated oemof energy system instance containing all converted components.\n    :rtype: solph.EnergySystem\n    \"\"\"\n    for bus in self.busses:\n        energysystem.add(bus.to_oemof(energysystem))\n\n    for sink in self.sinks:\n        energysystem.add(sink.to_oemof(energysystem))\n\n    for source in self.sources:\n        energysystem.add(source.to_oemof(energysystem))\n\n    for converter in self.converters:\n        energysystem.add(converter.to_oemof(energysystem))\n\n    for generic_storage in self.generic_storages:\n        energysystem.add(generic_storage.to_oemof(energysystem))\n\n    # TODO: Adding Constraints\n\n    return energysystem\n</code></pre>"},{"location":"ensys/components/flow/","title":"Flow","text":""},{"location":"ensys/components/flow/#components.flow.EnFlow","title":"<code>EnFlow</code>","text":"<p>               Bases: <code>EnBaseModel</code></p> <p>Represents an energy flow model designed to manage and optimize energy-related variables and constraints in an energy system. It includes parameters such as nominal values, variable costs, bounds, gradients, and additional constraints like nonconvex flows, lifetime, or custom attributes.</p> <p>This class is typically employed in optimization scenarios where energy flows between nodes in a system are analyzed and adjusted based on various input parameters to minimize costs or adhere to specific constraints.</p> <p>Attributes:</p> Name Type Description <code>nominal_value</code> <code>float | EnInvestment</code> <p>The nominal value of the flow. If set, the corresponding optimization variable of the flow object will be bounded by this value multiplied with min(lower bound)/max(upper bound).</p> <code>variable_costs</code> <code>float | list[float] | None</code> <p>The costs associated with one unit of the flow per hour. These costs for each timestep will be added to the objective expression of the optimization problem.</p> <code>min</code> <code>float | list[float] | None</code> <p>Normed minimum value of the flow.</p> <code>max</code> <code>float | list[float] | None</code> <p>Normed maximum value of the flow. The absolute maximum flow will be calculated by multiplying nominal_value with max.</p> <code>fix</code> <code>float | list[float] | None</code> <p>Normed fixed value for the flow variable. It will be multiplied with nominal_value to get the absolute value.</p> <code>positive_gradient_limit</code> <code>dict | None</code> <p>Normed upper bound on the positive difference (flow[t-1] &lt; flow[t]) of two consecutive flow values.</p> <code>negative_gradient_limit</code> <code>dict | None</code> <p>Normed upper bound on the negative difference (flow[t-1] &gt; flow[t]) of two consecutive flow values.</p> <code>full_load_time_max</code> <code>int | None</code> <p>Maximum energy transported by the flow, expressed as the time (in hours) the flow would have to run at nominal capacity (nominal_value).</p> <code>full_load_time_min</code> <code>int | None</code> <p>Minimum energy transported by the flow, expressed as the time (in hours) the flow would have to run at nominal capacity (nominal_value).</p> <code>integer</code> <code>bool | None</code> <p>If True, the flow values will be bounded to integers.</p> <code>nonconvex</code> <code>EnNonConvex | None</code> <p>If a nonconvex flow object is specified, the flow's constraints will be significantly altered based on the NonConvexFlow model.</p> <code>fixed_costs</code> <code>float | list[float] | None</code> <p>Fixed costs associated with a flow, provided on a yearly basis. Applicable only for a multi-period model.</p> <code>lifetime</code> <code>int | None</code> <p>Lifetime of a flow (in years). When reached (considering the initial age), the flow is forced to 0. Applicable only for a multi-period model.</p> <code>age</code> <code>int | None</code> <p>Age of a flow (in years). When reached (considering the initial age), the flow is forced to 0. Applicable only for a multi-period model.</p> <code>custom_attributes</code> <code>dict | None</code> <p>Custom attributes provided as a dictionary for customized investment limits or additional properties.</p> Source code in <code>ensys/components/flow.py</code> <pre><code>class EnFlow(EnBaseModel):\n    \"\"\"\n    Represents an energy flow model designed to manage and optimize energy-related variables\n    and constraints in an energy system. It includes parameters such as nominal values,\n    variable costs, bounds, gradients, and additional constraints like nonconvex flows,\n    lifetime, or custom attributes.\n\n    This class is typically employed in optimization scenarios where energy flows\n    between nodes in a system are analyzed and adjusted based on various input parameters\n    to minimize costs or adhere to specific constraints.\n\n    :ivar nominal_value: The nominal value of the flow. If set, the corresponding optimization\n        variable of the flow object will be bounded by this value multiplied with\n        min(lower bound)/max(upper bound).\n    :type nominal_value: float | EnInvestment\n    :ivar variable_costs: The costs associated with one unit of the flow per hour. These costs\n        for each timestep will be added to the objective expression of the optimization problem.\n    :type variable_costs: float | list[float] | None\n    :ivar min: Normed minimum value of the flow.\n    :type min: float | list[float] | None\n    :ivar max: Normed maximum value of the flow. The absolute maximum flow will be calculated\n        by multiplying nominal_value with max.\n    :type max: float | list[float] | None\n    :ivar fix: Normed fixed value for the flow variable. It will be multiplied with\n        nominal_value to get the absolute value.\n    :type fix: float | list[float] | None\n    :ivar positive_gradient_limit: Normed upper bound on the positive difference\n        (flow[t-1] &lt; flow[t]) of two consecutive flow values.\n    :type positive_gradient_limit: dict | None\n    :ivar negative_gradient_limit: Normed upper bound on the negative difference\n        (flow[t-1] &gt; flow[t]) of two consecutive flow values.\n    :type negative_gradient_limit: dict | None\n    :ivar full_load_time_max: Maximum energy transported by the flow, expressed as the\n        time (in hours) the flow would have to run at nominal capacity (nominal_value).\n    :type full_load_time_max: int | None\n    :ivar full_load_time_min: Minimum energy transported by the flow, expressed as the\n        time (in hours) the flow would have to run at nominal capacity (nominal_value).\n    :type full_load_time_min: int | None\n    :ivar integer: If True, the flow values will be bounded to integers.\n    :type integer: bool | None\n    :ivar nonconvex: If a nonconvex flow object is specified, the flow's constraints\n        will be significantly altered based on the NonConvexFlow model.\n    :type nonconvex: EnNonConvex | None\n    :ivar fixed_costs: Fixed costs associated with a flow, provided on a yearly basis.\n        Applicable only for a multi-period model.\n    :type fixed_costs: float | list[float] | None\n    :ivar lifetime: Lifetime of a flow (in years). When reached (considering the initial age),\n        the flow is forced to 0. Applicable only for a multi-period model.\n    :type lifetime: int | None\n    :ivar age: Age of a flow (in years). When reached (considering the initial age),\n        the flow is forced to 0. Applicable only for a multi-period model.\n    :type age: int | None\n    :ivar custom_attributes: Custom attributes provided as a dictionary for customized\n        investment limits or additional properties.\n    :type custom_attributes: dict | None\n    \"\"\"\n    nominal_value: float | EnInvestment = Field(\n        default=None,\n        title='Nominal Value',\n        description='The nominal value of the flow. If this value is set the corresponding optimization variable of '\n                    'the flow object will be bounded by this value multiplied with min(lower bound)/max(upper bound).'\n    )\n\n    variable_costs: float | list[float] | None = Field(\n        default=None,\n        title='Variable Costs',\n        description='The costs associated with one unit of the flow per hour. The costs for each timestep will be added to the objective expression of the optimization problem.'\n    )\n\n    # numeric or sequence\n    min: float | list[float] | None = Field(\n        default=None,\n        title='Minimum',\n        description='Normed minimum value of the flow (see max).'\n    )\n\n    # numeric or sequence\n    max: float | list[float] | None = Field(\n        default=None,\n        title='Maximum',\n        description='Normed maximum value of the flow. The flow absolute maximum will be calculated by multiplying nominal_value with max'\n    )\n\n    # numeric or sequence or None\n    fix: float | list[float] | None = Field(\n        default=None,\n        title='Fix',\n        description='Normed fixed value for the flow variable. '\n                    'Will be multiplied with the nominal_value to get the absolute value'\n    )\n\n    positive_gradient_limit: dict | None = Field(\n        default=None,\n        title='Positive Gradient Limit',\n        description='the normed upper bound on the positive difference (flow[t-1] &lt; flow[t]) of two consecutive flow values.'\n    )\n    negative_gradient_limit: dict | None = Field(\n        default=None,\n        title='Negative Gradient Limit',\n        description='the normed upper bound on the negative difference (flow[t-1] &gt; flow[t]) of two consecutive flow values.'\n    )\n\n    full_load_time_max: int | None = Field(\n        default=None,\n        title='Full Load Time Maximum',\n        description='Maximum energy transported by the flow expressed as the time (in hours) that the flow would have to run at nominal capacity (nominal_value).'\n    )\n\n    full_load_time_min: int | None = Field(\n        default=None,\n        title='Full Load Time Minimum',\n        description='Minimum energy transported by the flow expressed as the time (in hours) that the flow would have to run at nominal capacity (nominal_value).'\n    )\n\n    integer: bool | None = Field(\n        default=None,\n        title='Integer',\n        description='Set True to bound the flow values to integers.'\n    )\n\n    nonconvex: EnNonConvex | None = Field(\n        default=None,\n        title='Nonconvex',\n        description='If a nonconvex flow object is added here, the flow constraints will be altered significantly as '\n                    'the mathematical model for the flow will be different, i.e. constraint etc. from NonConvexFlow '\n                    'will be used instead of Flow. '\n    )\n\n    fixed_costs: float | list[float] | None = Field(\n        default=None,\n        title='Fixed Costs',\n        description='The fixed costs associated with a flow. Note: These are only applicable for a multi-period model and given on a yearly basis.'\n    )\n\n    lifetime: int | None = Field(\n        default=None,\n        title='Lifetime',\n        description='The lifetime of a flow (usually given in years); once it reaches its lifetime (considering also an initial age), the flow is forced to 0. Note: Only applicable for a multi-period model.'\n    )\n\n    age: int | None = Field(\n        default=None,\n        title='Age',\n        description='The age of a flow (usually given in years); once it reaches its age (considering also an initial age), the flow is forced to 0. Note: Only applicable for a multi-period model.'\n    )\n\n    custom_attributes: dict | None = Field(\n        default=None,\n        title=\"Custom Attributes\",\n        description=\"Custom Attributes as dictionary for custom investment limits.\"\n    )\n\n    def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.Flow:\n        \"\"\"\n        Converts the current instance into an oemof.solph.Flow object using the provided\n        energy system and internal parameters. The method prepares the necessary\n        arguments from the instance and inputs, constructs the Flow object, and\n        returns it.\n\n        :param energysystem: The energy system object used to derive specific\n            characteristics for the flow conversion (oemof.solph.EnergySystem).\n        :return: A corresponding oemof.solph.Flow object built using the instance\n            parameters and the energy system context (oemof.solph.Flow).\n        \"\"\"\n        kwargs = self.build_kwargs(energysystem)\n\n        return solph.Flow(**kwargs)\n</code></pre>"},{"location":"ensys/components/flow/#components.flow.EnFlow.to_oemof","title":"<code>to_oemof(energysystem)</code>","text":"<p>Converts the current instance into an oemof.solph.Flow object using the provided energy system and internal parameters. The method prepares the necessary arguments from the instance and inputs, constructs the Flow object, and returns it.</p> <p>Parameters:</p> Name Type Description Default <code>energysystem</code> <code>EnergySystem</code> <p>The energy system object used to derive specific characteristics for the flow conversion (oemof.solph.EnergySystem).</p> required <p>Returns:</p> Type Description <code>Flow</code> <p>A corresponding oemof.solph.Flow object built using the instance parameters and the energy system context (oemof.solph.Flow).</p> Source code in <code>ensys/components/flow.py</code> <pre><code>def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.Flow:\n    \"\"\"\n    Converts the current instance into an oemof.solph.Flow object using the provided\n    energy system and internal parameters. The method prepares the necessary\n    arguments from the instance and inputs, constructs the Flow object, and\n    returns it.\n\n    :param energysystem: The energy system object used to derive specific\n        characteristics for the flow conversion (oemof.solph.EnergySystem).\n    :return: A corresponding oemof.solph.Flow object built using the instance\n        parameters and the energy system context (oemof.solph.Flow).\n    \"\"\"\n    kwargs = self.build_kwargs(energysystem)\n\n    return solph.Flow(**kwargs)\n</code></pre>"},{"location":"ensys/components/genericstorage/","title":"Storage","text":""},{"location":"ensys/components/genericstorage/#components.genericstorage.EnGenericStorage","title":"<code>EnGenericStorage</code>","text":"<p>               Bases: <code>EnBaseModel</code></p> <p>Represents a generic energy storage model with various attributes related to inputs, outputs, capacities, efficiencies, and losses.</p> <p>This class models an energy storage system with different properties such as storage capacity, inflow and outflow conversions, losses, and investment options. The class is designed to handle energy optimization tasks and can be translated into an oemof (Open Energy Modelling Framework)-compatible GenericStorage object.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>Default label for the energy storage instance.</p> <code>inputs</code> <code>dict[str, EnFlow]</code> <p>Dictionary representing inflows to the storage. Keys are the ending nodes of the inflows.</p> <code>outputs</code> <code>dict[str, EnFlow]</code> <p>Dictionary representing outflows from the storage. Keys are the ending nodes of the outflows.</p> <code>nominal_storage_capacity</code> <code>float | EnInvestment</code> <p>Absolute nominal storage capacity. This can be a fixed value or an EnInvestment object for investment optimization.</p> <code>invest_relation_input_capacity</code> <code>float | None</code> <p>Ratio between the investment variable of the input flow and the investment variable of the storage.</p> <code>invest_relation_output_capacity</code> <code>float | None</code> <p>Ratio between the investment variable of the output flow and the investment variable of the storage.</p> <code>invest_relation_input_output</code> <code>float | None</code> <p>Ratio between the investment variable of the output flow and the investment variable of the input flow. Used to fix relationships between flow investments.</p> <code>initial_storage_level</code> <code>float | None</code> <p>Relative storage content before the first timestep of optimization (value between 0 and 1). Cannot be used with investment mode in multi-period models.</p> <code>balanced</code> <code>bool</code> <p>Indicates whether the total inflow and outflow are balanced (coupling the storage level of the first and last time step).</p> <code>loss_rate</code> <code>float | list[float]</code> <p>Relative loss of storage content per hour.</p> <code>fixed_losses_relative</code> <code>float | list[float] | None</code> <p>Losses proportional to the nominal storage capacity but independent of storage content. Not supported in investment mode.</p> <code>fixed_losses_absolute</code> <code>float | list[float] | None</code> <p>Losses independent of both storage content and nominal storage capacity. Not supported in investment mode.</p> <code>inflow_conversion_factor</code> <code>float | list[float]</code> <p>Efficiency associated with inflow to the storage.</p> <code>outflow_conversion_factor</code> <code>float | list[float]</code> <p>Efficiency associated with outflow from the storage.</p> <code>min_storage_level</code> <code>float | list[float]</code> <p>Minimum storage level as a fraction of nominal storage capacity or invested capacity. Value between 0 and 1. Can be set for each timestep using a sequence.</p> <code>max_storage_level</code> <code>float | list[float]</code> <p>Maximum storage level as a fraction of nominal storage capacity or invested capacity. Value between 0 and 1. Can be set for each timestep using a sequence.</p> <code>investment</code> <code>EnInvestment | None</code> <p>Object determining whether nominal storage capacity is optimized. If used, nominal_storage_capacity should not be set.</p> <code>storage_costs</code> <code>float | list[float] | None</code> <p>Cost (per energy unit) for maintaining energy in the storage.</p> <code>lifetime_inflow</code> <code>int | None</code> <p>Lifetime of inflow, applicable for multi-period models with investment in storage capacity and defined invest_relation_input_capacity.</p> <code>lifetime_outflow</code> <code>int | None</code> <p>Lifetime of outflow, applicable for multi-period models with investment in storage capacity and defined invest_relation_output_capacity.</p> Source code in <code>ensys/components/genericstorage.py</code> <pre><code>class EnGenericStorage(EnBaseModel):\n    \"\"\"\n    Represents a generic energy storage model with various attributes related to\n    inputs, outputs, capacities, efficiencies, and losses.\n\n    This class models an energy storage system with different properties such as\n    storage capacity, inflow and outflow conversions, losses, and investment\n    options. The class is designed to handle energy optimization tasks and can\n    be translated into an oemof (Open Energy Modelling Framework)-compatible\n    GenericStorage object.\n\n    :ivar label: Default label for the energy storage instance.\n    :ivar inputs: Dictionary representing inflows to the storage. Keys are the\n        ending nodes of the inflows.\n    :ivar outputs: Dictionary representing outflows from the storage. Keys are\n        the ending nodes of the outflows.\n    :ivar nominal_storage_capacity: Absolute nominal storage capacity. This can\n        be a fixed value or an EnInvestment object for investment optimization.\n    :ivar invest_relation_input_capacity: Ratio between the investment variable\n        of the input flow and the investment variable of the storage.\n    :ivar invest_relation_output_capacity: Ratio between the investment variable\n        of the output flow and the investment variable of the storage.\n    :ivar invest_relation_input_output: Ratio between the investment variable of\n        the output flow and the investment variable of the input flow. Used to\n        fix relationships between flow investments.\n    :ivar initial_storage_level: Relative storage content before the first\n        timestep of optimization (value between 0 and 1). Cannot be used with\n        investment mode in multi-period models.\n    :ivar balanced: Indicates whether the total inflow and outflow are balanced\n        (coupling the storage level of the first and last time step).\n    :ivar loss_rate: Relative loss of storage content per hour.\n    :ivar fixed_losses_relative: Losses proportional to the nominal storage\n        capacity but independent of storage content. Not supported in\n        investment mode.\n    :ivar fixed_losses_absolute: Losses independent of both storage content and\n        nominal storage capacity. Not supported in investment mode.\n    :ivar inflow_conversion_factor: Efficiency associated with inflow to the\n        storage.\n    :ivar outflow_conversion_factor: Efficiency associated with outflow from\n        the storage.\n    :ivar min_storage_level: Minimum storage level as a fraction of nominal\n        storage capacity or invested capacity. Value between 0 and 1. Can be\n        set for each timestep using a sequence.\n    :ivar max_storage_level: Maximum storage level as a fraction of nominal\n        storage capacity or invested capacity. Value between 0 and 1. Can be\n        set for each timestep using a sequence.\n    :ivar investment: Object determining whether nominal storage capacity is\n        optimized. If used, nominal_storage_capacity should not be set.\n    :ivar storage_costs: Cost (per energy unit) for maintaining energy in the\n        storage.\n    :ivar lifetime_inflow: Lifetime of inflow, applicable for multi-period\n        models with investment in storage capacity and defined\n        invest_relation_input_capacity.\n    :ivar lifetime_outflow: Lifetime of outflow, applicable for multi-period\n        models with investment in storage capacity and defined\n        invest_relation_output_capacity.\n    \"\"\"\n    label: str = Field(\n        default=\"Default GenericStorage\",\n        title='Label',\n        description=''\n    )\n\n    inputs: dict[str, EnFlow] = Field(\n        ...,\n        title='Inputs',\n        description='Dictionary with inflows. Keys must be the ending node(s) of the inflows(s)'\n    )\n\n    outputs: dict[str, EnFlow] = Field(\n        ...,\n        title='Outputs',\n        description='Dictionary with outflows. Keys must be the ending node(s) of the outflow(s)'\n    )\n    nominal_storage_capacity: float | EnInvestment = Field(\n        ...,\n        title='nominal storage capacity',\n        description='object Absolute nominal capacity of the storage, fixed value or object describing parameter of investment optimisations.'\n    )\n\n    invest_relation_input_capacity: float | None = Field(\n        default=None,\n        title='invest relation input capacity',\n        description='Ratio between the investment variable of the input Flow and the investment variable of the storage'\n    )\n\n    invest_relation_output_capacity: float | None = Field(\n        default=None,\n        title='invest relation output capacity',\n        description='Ratio between the investment variable of the output Flow and the investment variable of the storage.'\n    )\n\n    invest_relation_input_output: float | None = Field(\n        default=None,\n        title='invest relation input output',\n        description='Ratio between the investment variable of the output Flow and the investment variable of the input flow. This ratio used to fix the flow investments to each other. Values &lt; 1 set the input flow lower than the output and &gt; 1 will set the input flow higher than the output flow.'\n    )\n\n    initial_storage_level: float | None = Field(\n        default=None,\n        title='initial storage level',\n        description='The relative storage content in the timestep before the first time step of optimization (between 0 and 1). Note: When investment mode is used in a multi-period model, initial_storage_level is not supported. Storage output is forced to zero until the storage unit is invested in.'\n    )\n\n    balanced: bool = Field(\n        default=True,\n        title='balanced',\n        description=' Couple storage level of first and last time step. (Total inflow and total outflow are balanced.)'\n    )\n\n    loss_rate: float | list[float] = Field(\n        ...,\n        title='loss rate',\n        description='The relative loss of the storage content per hour.'\n    )\n\n    fixed_losses_relative: float | list[float] | None = Field(\n        default=None,\n        title='fixed losses relative',\n        description='Losses per hour that are independent of the storage content but proportional to nominal storage capacity. Note: Fixed losses are not supported in investment mode.'\n    )\n\n    fixed_losses_absolute: float | list[float] | None = Field(\n        default=None,\n        title='Fixed losses absolute',\n        description='Losses per hour that are independent of storage content and independent of nominal storage capacity. Note: Fixed losses are not supported in investment mode.'\n    )\n\n    inflow_conversion_factor: float | list[float] = Field(\n        ...,\n        title='Conversion factor: Inflow',\n        description='The relative conversion factor, i.e. efficiency associated with the inflow of the storage.'\n    )\n\n    outflow_conversion_factor: float | list[float] = Field(\n        ...,\n        title='Conversion factor: Outflow',\n        description='The relative conversion factor, i.e. efficiency associated with the outflow of the storage.'\n    )\n\n    min_storage_level: float | list[float] = Field(\n        ...,\n        title='Minimum storage level',\n        description='The normed minimum storage content as fraction of the nominal storage capacity or the capacity that has been invested into (between 0 and 1). To set different values in every time step use a sequence.'\n    )\n\n    max_storage_level: float | list[float] = Field(\n        ...,\n        title='Maximum storage level',\n        description='The normed maximum storage content as fraction of the nominal storage capacity or the capacity that has been invested into (between 0 and 1). To set different values in every time step use a sequence.'\n    )\n\n    investment: EnInvestment | None = Field(\n        default=None,\n        title='Investment',\n        description='Object indicating if a nominal_value of the flow is determined by the optimization problem. Note: This will refer all attributes to an investment variable instead of to the nominal_storage_capacity. The nominal_storage_capacity should not be set (or set to None) if an investment object is used.'\n    )\n\n    storage_costs: float | list[float] | None = Field(\n        default=None,\n        title='storage costs',\n        description='Cost (per energy) for having energy in the storage.'\n    )\n\n    lifetime_inflow: int | None = Field(\n        default=None,\n        title='lifetime inflow',\n        description='Determine the lifetime of an inflow; only applicable for multi-period models which can invest in storage capacity and have an invest_relation_input_capacity defined.'\n    )\n\n    lifetime_outflow: int | None = Field(\n        default=None,\n        title='lifetime outflow',\n        description='Determine the lifetime of an outflow; only applicable for multi-period models which can invest in storage capacity and have an invest_relation_output_capacity defined.'\n    )\n\n    def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.components.GenericStorage:\n        \"\"\"\n        Converts the current storage object to an oemof-compatible\n        GenericStorage component.\n\n        This method takes an oemof EnergySystem object as input,\n        builds the appropriate arguments for an oemof GenericStorage,\n        and then returns the created GenericStorage component.\n\n        :param energysystem: The specified oemof EnergySystem object required for\n            creating the GenericStorage component.\n        :type energysystem: solph.EnergySystem\n        :return: A GenericStorage component created and populated\n            using the provided EnergySystem and associated parameters.\n        :rtype: solph.components.GenericStorage\n        \"\"\"\n        kwargs = self.build_kwargs(energysystem)\n\n        return solph.components.GenericStorage(**kwargs)\n</code></pre>"},{"location":"ensys/components/genericstorage/#components.genericstorage.EnGenericStorage.to_oemof","title":"<code>to_oemof(energysystem)</code>","text":"<p>Converts the current storage object to an oemof-compatible GenericStorage component.</p> <p>This method takes an oemof EnergySystem object as input, builds the appropriate arguments for an oemof GenericStorage, and then returns the created GenericStorage component.</p> <p>Parameters:</p> Name Type Description Default <code>energysystem</code> <code>EnergySystem</code> <p>The specified oemof EnergySystem object required for creating the GenericStorage component.</p> required <p>Returns:</p> Type Description <code>solph.components.GenericStorage</code> <p>A GenericStorage component created and populated using the provided EnergySystem and associated parameters.</p> Source code in <code>ensys/components/genericstorage.py</code> <pre><code>def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.components.GenericStorage:\n    \"\"\"\n    Converts the current storage object to an oemof-compatible\n    GenericStorage component.\n\n    This method takes an oemof EnergySystem object as input,\n    builds the appropriate arguments for an oemof GenericStorage,\n    and then returns the created GenericStorage component.\n\n    :param energysystem: The specified oemof EnergySystem object required for\n        creating the GenericStorage component.\n    :type energysystem: solph.EnergySystem\n    :return: A GenericStorage component created and populated\n        using the provided EnergySystem and associated parameters.\n    :rtype: solph.components.GenericStorage\n    \"\"\"\n    kwargs = self.build_kwargs(energysystem)\n\n    return solph.components.GenericStorage(**kwargs)\n</code></pre>"},{"location":"ensys/components/investment/","title":"Investment","text":""},{"location":"ensys/components/investment/#components.investment.EnInvestment","title":"<code>EnInvestment</code>","text":"<p>               Bases: <code>EnBaseModel</code></p> <p>Represents an investment model for energy system components.</p> <p>This class defines the properties and configurations for managing investments in energy system components. The attributes include limits on capacity investment, cost-related parameters, and constraints for both standard and multi-period models. It supports nonconvex investments and custom limits through additional configurations.</p> <p>Attributes:</p> Name Type Description <code>maximum</code> <code>float | None</code> <p>Maximum additional invested capacity; defined per period in a multi-period model.</p> <code>minimum</code> <code>float</code> <p>Minimum additional invested capacity. Defines the threshold when nonconvex is True; defined per period in a multi-period model.</p> <code>ep_costs</code> <code>float</code> <p>Equivalent periodical costs or investment expenses per flow capacity in both standard and multi-period models.</p> <code>existing</code> <code>float</code> <p>Installed capacity without additional investment costs; not applicable if nonconvex is True.</p> <code>nonconvex</code> <code>bool</code> <p>Flag to enable binary variables for investment status, allowing offset costs independent of invested flow capacity.</p> <code>offset</code> <code>float</code> <p>Fixed costs for nonconvex investments.</p> <code>overall_maximum</code> <code>float | None</code> <p>Overall maximum capacity investment, applicable to multi-period models.</p> <code>overalL_minimum</code> <code>float | None</code> <p>Overall minimum capacity investment, applicable to multi-period models.</p> <code>lifetime</code> <code>int | None</code> <p>Lifetime of the unit in years, applicable to multi-period models.</p> <code>age</code> <code>int | None</code> <p>Start age of the unit in years at the beginning of optimization, applicable to multi-period models.</p> <code>interest_rate</code> <code>float | None</code> <p>Interest rate for annuities calculation in a multi-period model; defaults to the model's discount rate if unspecified.</p> <code>fixed_costs</code> <code>float | None</code> <p>Fixed costs per period in nominal terms, applicable to multi-period models.</p> <code>custom_attributes</code> <code>dict | None</code> <p>Dictionary of custom constraints or attributes for investment.</p> Source code in <code>ensys/components/investment.py</code> <pre><code>class EnInvestment(EnBaseModel):\n    \"\"\"\n    Represents an investment model for energy system components.\n\n    This class defines the properties and configurations for managing investments in energy\n    system components. The attributes include limits on capacity investment, cost-related\n    parameters, and constraints for both standard and multi-period models. It supports\n    nonconvex investments and custom limits through additional configurations.\n\n    :ivar maximum: Maximum additional invested capacity; defined per period in a\n        multi-period model.\n    :ivar minimum: Minimum additional invested capacity. Defines the threshold when\n        nonconvex is True; defined per period in a multi-period model.\n    :ivar ep_costs: Equivalent periodical costs or investment expenses per flow capacity\n        in both standard and multi-period models.\n    :ivar existing: Installed capacity without additional investment costs; not applicable\n        if nonconvex is True.\n    :ivar nonconvex: Flag to enable binary variables for investment status, allowing offset\n        costs independent of invested flow capacity.\n    :ivar offset: Fixed costs for nonconvex investments.\n    :ivar overall_maximum: Overall maximum capacity investment, applicable to\n        multi-period models.\n    :ivar overalL_minimum: Overall minimum capacity investment, applicable to\n        multi-period models.\n    :ivar lifetime: Lifetime of the unit in years, applicable to multi-period models.\n    :ivar age: Start age of the unit in years at the beginning of optimization,\n        applicable to multi-period models.\n    :ivar interest_rate: Interest rate for annuities calculation in a multi-period\n        model; defaults to the model's discount rate if unspecified.\n    :ivar fixed_costs: Fixed costs per period in nominal terms, applicable to\n        multi-period models.\n    :ivar custom_attributes: Dictionary of custom constraints or attributes for\n        investment.\n    :type maximum: float | None\n    :type minimum: float\n    :type ep_costs: float\n    :type existing: float\n    :type nonconvex: bool\n    :type offset: float\n    :type overall_maximum: float | None\n    :type overalL_minimum: float | None\n    :type lifetime: int | None\n    :type age: int | None\n    :type interest_rate: float | None\n    :type fixed_costs: float | None\n    :type custom_attributes: dict | None\n    \"\"\"\n    maximum: float | None = Field(\n        default=None,  # eigtl. float(\"+inf\"),\n        title='Maximum',\n        description='Maximum of the additional invested capacity; defined per period p for a multi-period model.'\n    )\n\n    minimum: float = Field(\n        default=0.0,\n        title='Minimum',\n        description='Minimum of the additional invested capacity. If nonconvex is True, minimum defines the threshold for the invested capacity; defined per period p for a multi-period model.'\n    )\n\n    ep_costs: float = Field(\n        default=0.0,\n        title='EP Costs',\n        description='Equivalent periodical costs or investment expenses for the investment'\n                    'For a standard model: equivalent periodical costs for the investment per flow capacity, i.e. annuities for investments already calculated.'\n                    'For a multi-period model: Investment expenses for the respective period (in nominal terms). Annuities are calculated within the objective term, also considering age and lifetime.'\n    )\n\n    existing: float = Field(\n        default=0.0,\n        title='Existing',\n        description='Existing / installed capacity. The invested capacity is added on top of this value. Hence, existing capacities come at no additional costs. Not applicable if nonconvex is set to True.'\n    )\n\n    nonconvex: bool = Field(\n        default=False,\n        title='Nonconvex',\n        description='If True, a binary variable for the status of the investment is created. This enables additional fix investment costs (offset) independent of the invested flow capacity. Therefore, use the offset parameter.'\n    )\n\n    offset: float = Field(\n        default=0.0,\n        title='Offset',\n        description='Additional fixed investment costs. Only applicable if nonconvex is set to True.'\n    )\n\n    overall_maximum: float | None = Field(\n        default=None,\n        title='Overall Maximum',\n        description='Overall maximum capacity investment, i.e. the amount of capacity that can be totally installed at maximum in any period (taking into account decommissionings); only applicable for multi-period models'\n    )\n\n    overalL_minimum: float | None = Field(\n        default=None,\n        title='Overall Minimum',\n        description='Overall minimum capacity investment, i.e. the amount of capacity that can be totally installed at minimum in any period (taking into account decommissionings); only applicable for multi-period models'\n    )\n\n    lifetime: int | None = Field(\n        default=None,\n        title='Lifetime',\n        description='Units lifetime, given in years; only applicable for multi-period models'\n    )\n\n    age: int | None = Field(\n        default=None,\n        title='Age',\n        description='Units start age, given in years at the beginning of the optimization; only applicable for multi-period models'\n    )\n\n    interest_rate: float | None = Field(\n        default=None,\n        title='Interest Rate',\n        description='Interest rate for calculating annuities when investing in a particular unit; only applicable for multi-period models. If nothing else is specified, the interest rate is the same as the model discount rate of the multi-period model.'\n    )\n\n    fixed_costs: float | None = Field(\n        default=None,\n        title='Fixed Costs',\n        description='Fixed costs in each period (given in nominal terms); only applicable for multi-period models'\n    )\n\n    custom_attributes: dict | None = Field(\n        default=None,\n        title=\"Custom Attributes\",\n        description=\"Custom Attributes as dictionary for custom investment limits.\"\n    )\n\n    # kwargs: Dict = Field(\n    #    None,\n    #    title='kwargs',\n    #    description='Extra arguments for the object'\n    # )\n\n    def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.Investment:\n        \"\"\"\n        Converts the object's internal configuration to an oemof.solph Investment object.\n\n        This method takes an oemof EnergySystem object and uses the provided system\n        configuration to construct and return an oemof.solph Investment object. The\n        generated Investment object encapsulates investment-related parameters for\n        use in energy system modeling, particularly for optimization.\n\n        :param energysystem: The oemof.solph EnergySystem object containing the\n            necessary system configuration and parameters.\n        :type energysystem: solph.EnergySystem\n        :return: An oemof.solph Investment object constructed based on the internal\n            configuration and the provided EnergySystem object.\n        :rtype: solph.Investment\n        \"\"\"\n        kwargs = self.build_kwargs(energysystem)\n\n        return solph.Investment(**kwargs)\n</code></pre>"},{"location":"ensys/components/investment/#components.investment.EnInvestment.to_oemof","title":"<code>to_oemof(energysystem)</code>","text":"<p>Converts the object's internal configuration to an oemof.solph Investment object.</p> <p>This method takes an oemof EnergySystem object and uses the provided system configuration to construct and return an oemof.solph Investment object. The generated Investment object encapsulates investment-related parameters for use in energy system modeling, particularly for optimization.</p> <p>Parameters:</p> Name Type Description Default <code>energysystem</code> <code>EnergySystem</code> <p>The oemof.solph EnergySystem object containing the necessary system configuration and parameters.</p> required <p>Returns:</p> Type Description <code>solph.Investment</code> <p>An oemof.solph Investment object constructed based on the internal configuration and the provided EnergySystem object.</p> Source code in <code>ensys/components/investment.py</code> <pre><code>def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.Investment:\n    \"\"\"\n    Converts the object's internal configuration to an oemof.solph Investment object.\n\n    This method takes an oemof EnergySystem object and uses the provided system\n    configuration to construct and return an oemof.solph Investment object. The\n    generated Investment object encapsulates investment-related parameters for\n    use in energy system modeling, particularly for optimization.\n\n    :param energysystem: The oemof.solph EnergySystem object containing the\n        necessary system configuration and parameters.\n    :type energysystem: solph.EnergySystem\n    :return: An oemof.solph Investment object constructed based on the internal\n        configuration and the provided EnergySystem object.\n    :rtype: solph.Investment\n    \"\"\"\n    kwargs = self.build_kwargs(energysystem)\n\n    return solph.Investment(**kwargs)\n</code></pre>"},{"location":"ensys/components/model/","title":"Simulationmodel","text":""},{"location":"ensys/components/model/#components.model.EnModel","title":"<code>EnModel</code>","text":"<p>               Bases: <code>EnBaseModel</code></p> <p>Represents an energy model that solves optimization problems for a given energy system using a specified solver.</p> <p>This class is designed to manage and execute energy model optimization tasks. It provides configuration options for the underlying solver, including the ability to enable verbose output and specify additional solver arguments. The focus is on integrating with a defined energy system and ensuring that the energy system provided is not empty or undefined.</p> <p>Attributes:</p> Name Type Description <code>energysystem</code> <code>EnEnergysystem</code> <p>The energy system that the model operates upon. This is a required parameter.</p> <code>solver</code> <code>Solver</code> <p>The solver to use for optimization tasks. Defaults to the Gurobi solver.</p> <code>solver_verbose</code> <code>bool</code> <p>Specifies whether to enable verbose output from the solver during runtime. Defaults to True.</p> <code>solver_kwargs</code> <code>dict[str, bool | str | int | float] | None</code> <p>Extra configuration arguments for the solver, such as gap limits or other solver-specific parameters. Defaults to None.</p> Source code in <code>ensys/components/model.py</code> <pre><code>class EnModel(EnBaseModel):\n    \"\"\"\n    Represents an energy model that solves optimization problems for a given\n    energy system using a specified solver.\n\n    This class is designed to manage and execute energy model optimization tasks.\n    It provides configuration options for the underlying solver, including the\n    ability to enable verbose output and specify additional solver arguments.\n    The focus is on integrating with a defined energy system and ensuring that\n    the energy system provided is not empty or undefined.\n\n    :ivar energysystem: The energy system that the model operates upon. This is\n        a required parameter.\n    :type energysystem: EnEnergysystem\n    :ivar solver: The solver to use for optimization tasks. Defaults to the\n        Gurobi solver.\n    :type solver: Solver\n    :ivar solver_verbose: Specifies whether to enable verbose output from the\n        solver during runtime. Defaults to True.\n    :type solver_verbose: bool\n    :ivar solver_kwargs: Extra configuration arguments for the solver, such as\n        gap limits or other solver-specific parameters. Defaults to None.\n    :type solver_kwargs: dict[str, bool | str | int | float] | None\n    \"\"\"\n    energysystem: EnEnergysystem = Field(\n        ...,\n        title='Energysystem',\n        description='Energysystem to solve'\n    )\n\n    solver: Solver = Field(\n        default=Solver.gurobi,\n        title='Solver',\n        description='Solver'\n    )\n\n    solver_verbose: bool = Field(\n        default=True,\n        title='Solver verbose',\n        description='Print output from the Solver'\n    )\n\n    solver_kwargs: dict[str, bool | str | int | float] | None = Field(\n        default=None,\n        title='Solver Extra Arguments',\n        description='Extra arguments for the Solver (MIP_GAP etc.)'\n    )\n\n    @classmethod\n    @field_validator('energysystem')\n    def es_is_not_none(cls, v):\n        \"\"\"\n        Validates the 'energysystem' field during class instantiation to ensure it is not set to None.\n        This method is called automatically by the Pydantic validator mechanism.\n\n        :param v: The value provided for the 'energysystem' field.\n        :type v: Any\n        :return: The validated 'energysystem' value if it is not None.\n        :rtype: Any\n        :raises ValueError: If the 'energysystem' value is None.\n        \"\"\"\n        if v is None:  # pragma: no cover\n            raise ValueError(\"Energysystem can not be 'None'.\")\n\n        return v  # pragma: no cover\n</code></pre>"},{"location":"ensys/components/model/#components.model.EnModel.es_is_not_none","title":"<code>es_is_not_none(v)</code>  <code>classmethod</code>","text":"<p>Validates the 'energysystem' field during class instantiation to ensure it is not set to None. This method is called automatically by the Pydantic validator mechanism.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>Any</code> <p>The value provided for the 'energysystem' field.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>The validated 'energysystem' value if it is not None.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the 'energysystem' value is None.</p> Source code in <code>ensys/components/model.py</code> <pre><code>@classmethod\n@field_validator('energysystem')\ndef es_is_not_none(cls, v):\n    \"\"\"\n    Validates the 'energysystem' field during class instantiation to ensure it is not set to None.\n    This method is called automatically by the Pydantic validator mechanism.\n\n    :param v: The value provided for the 'energysystem' field.\n    :type v: Any\n    :return: The validated 'energysystem' value if it is not None.\n    :rtype: Any\n    :raises ValueError: If the 'energysystem' value is None.\n    \"\"\"\n    if v is None:  # pragma: no cover\n        raise ValueError(\"Energysystem can not be 'None'.\")\n\n    return v  # pragma: no cover\n</code></pre>"},{"location":"ensys/components/nonconvex/","title":"NonConvex","text":""},{"location":"ensys/components/nonconvex/#components.nonconvex.EnNonConvex","title":"<code>EnNonConvex</code>","text":"<p>               Bases: <code>EnBaseModel</code></p> <p>Represents a non-convex energy model with constraints and cost attributes.</p> <p>Defines attributes and limitations associated with non-convex behavior, including cost structures, operational constraints, and gradient limits, for modeling purposes in an energy system optimization context.</p> <p>Attributes:</p> Name Type Description <code>startup_costs</code> <code>float | list[float] | None</code> <p>Costs associated with a start of the flow (representing a unit).</p> <code>shutdown_costs</code> <code>float | list[float] | None</code> <p>Costs associated with the shutdown of the flow (representing a unit).</p> <code>activity_costs</code> <code>float | list[float] | None</code> <p>Costs associated with the active operation of the flow, independently from the actual output.</p> <code>inactivity_costs</code> <code>float | list[float] | None</code> <p>Costs associated with not operating the flow.</p> <code>minimum_uptime</code> <code>int | list[int] | None</code> <p>Minimum number of time steps that a flow must be greater than its minimum flow after startup. Be aware that minimum up and downtimes can contradict each other and may lead to infeasible problems.</p> <code>minimum_downtime</code> <code>int | list[int] | None</code> <p>Minimum number of time steps a flow is forced to zero after shutting down. Be aware that minimum up and downtimes can contradict each other and may lead to infeasible problems.</p> <code>maximum_startups</code> <code>int | None</code> <p>Maximum number of start-ups in the optimization timeframe.</p> <code>maximum_shutdowns</code> <code>int | None</code> <p>Maximum number of shutdowns in the optimization timeframe.</p> <code>initial_status</code> <code>int</code> <p>Integer value indicating the status of the flow in the first time step (0 = off, 1 = on). For minimum up and downtimes, the initial status is set for the respective values in the beginning, e.g., if a minimum uptime of four timesteps is defined and the initial status is set to one, the initial status is fixed for the four first timesteps of the optimization period. Otherwise, if the initial status is set to zero, the first timesteps are fixed for the number of minimum downtime steps.</p> <code>positive_gradient_limit</code> <code>dict | None</code> <p>The normed upper bound on the positive difference (flow[t-1] &lt; flow[t]) of two consecutive flow values.</p> <code>negative_gradient_limit</code> <code>dict | None</code> <p>The normed upper bound on the negative difference (flow[t-1] &gt; flow[t]) of two consecutive flow values.</p> Source code in <code>ensys/components/nonconvex.py</code> <pre><code>class EnNonConvex(EnBaseModel):\n    \"\"\"\n    Represents a non-convex energy model with constraints and cost attributes.\n\n    Defines attributes and limitations associated with non-convex behavior, including\n    cost structures, operational constraints, and gradient limits, for modeling\n    purposes in an energy system optimization context.\n\n    :ivar startup_costs: Costs associated with a start of the flow (representing a unit).\n    :type startup_costs: float | list[float] | None\n    :ivar shutdown_costs: Costs associated with the shutdown of the flow (representing a unit).\n    :type shutdown_costs: float | list[float] | None\n    :ivar activity_costs: Costs associated with the active operation of the flow, independently from the actual output.\n    :type activity_costs: float | list[float] | None\n    :ivar inactivity_costs: Costs associated with not operating the flow.\n    :type inactivity_costs: float | list[float] | None\n    :ivar minimum_uptime: Minimum number of time steps that a flow must be greater than its minimum flow after startup. Be aware that minimum up and downtimes can contradict each other and may lead to infeasible problems.\n    :type minimum_uptime: int | list[int] | None\n    :ivar minimum_downtime: Minimum number of time steps a flow is forced to zero after shutting down. Be aware that minimum up and downtimes can contradict each other and may lead to infeasible problems.\n    :type minimum_downtime: int | list[int] | None\n    :ivar maximum_startups: Maximum number of start-ups in the optimization timeframe.\n    :type maximum_startups: int | None\n    :ivar maximum_shutdowns: Maximum number of shutdowns in the optimization timeframe.\n    :type maximum_shutdowns: int | None\n    :ivar initial_status: Integer value indicating the status of the flow in the first time step (0 = off, 1 = on). For minimum up and downtimes, the initial status is set for the respective values in the beginning, e.g., if a minimum uptime of four timesteps is defined and the initial status is set to one, the initial status is fixed for the four first timesteps of the optimization period. Otherwise, if the initial status is set to zero, the first timesteps are fixed for the number of minimum downtime steps.\n    :type initial_status: int\n    :ivar positive_gradient_limit: The normed upper bound on the positive difference (flow[t-1] &lt; flow[t]) of two consecutive flow values.\n    :type positive_gradient_limit: dict | None\n    :ivar negative_gradient_limit: The normed upper bound on the negative difference (flow[t-1] &gt; flow[t]) of two consecutive flow values.\n    :type negative_gradient_limit: dict | None\n    \"\"\"\n    startup_costs: float | list[float] | None = Field(\n        default=None,\n        title='Startups Costs',\n        description='Costs associated with a start of the flow (representing a unit).'\n    )\n\n    shutdown_costs: float | list[float] | None = Field(\n        default=None,\n        title='Shutdown Costs',\n        description='Costs associated with the shutdown of the flow (representing a unit).'\n    )\n\n    activity_costs: float | list[float] | None = Field(\n        default=None,\n        title='Activity Costs',\n        description='Costs associated with the active operation of the flow, independently from the actual output.'\n    )\n\n    inactivity_costs: float | list[float] | None = Field(\n        default=None,\n        title='Inactivity Costs',\n        description='Costs associated with not operating the flow.'\n    )\n\n    minimum_uptime: int | list[int] | None = Field(\n        default=None,\n        title='Minimum Uptime',\n        description='Minimum number of time steps that a flow must be greater then its minimum flow after startup. Be aware that minimum up and downtimes can contradict each other and may lead to infeasible problems.',\n        ge=0\n    )\n    minimum_downtime: int | list[int] | None = Field(\n        default=None,\n        title='Minimum Downtime',\n        description='Minimum number of time steps a flow is forced to zero after shutting down. Be aware that minimum up and downtimes can contradict each other and may to infeasible problems.',\n        ge=0\n    )\n\n    maximum_startups: int | None = Field(\n        default=None,\n        title='Maximum Startups',\n        description='Maximum number of start-ups in the optimization timeframe.',\n        ge=0\n    )\n\n    maximum_shutdowns: int | None = Field(\n        default=None,\n        title='Maximum Shutdowns',\n        description='Maximum number of shutdowns in the optimization timeframe.',\n        ge=0\n    )\n\n    # 0/False = off, 1/True = on\n    initial_status: int = Field(\n        default=0,\n        title='initial Status',\n        description='Integer value indicating the status of the flow in the first time step (0 = off, 1 = on). For minimum up and downtimes, the initial status is set for the respective values in the beginning e.g. if a minimum uptime of four timesteps is defined and the initial status is set to one, the initial status is fixed for the four first timesteps of the optimization period. Otherwise if the initial status is set to zero and the first timesteps are fixed for the number of minimum downtime steps.',\n        ge=0,\n        le=1\n    )\n\n    positive_gradient_limit: dict | None = Field(\n        default=None,\n        title='positive Gradient Limit',\n        description='the normed upper bound on the positive difference (flow[t-1] &lt; flow[t]) of two consecutive flow values.'\n    )\n\n    negative_gradient_limit: dict | None = Field(\n        default=None,\n        title='negative Gradient limit',\n        description='the normed upper bound on the negative difference (flow[t-1] &gt; flow[t]) of two consecutive flow values.'\n    )\n\n    def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.NonConvex:\n        \"\"\"\n        Converts the given energy system into an oemof.solph.NonConvex object using\n        parameters built by the `build_kwargs` method. This function prepares the\n        necessary parameters by interacting with the provided energy system and\n        constructs the required non-convex properties for the output.\n\n        :param energysystem: The energy system instance that holds the data and\n            configuration required to create an `oemof.solph.NonConvex` object.\n        :return: An instance of `solph.NonConvex` configured with the parameters\n            derived from the input energy system.\n        :rtype: solph.NonConvex\n        \"\"\"\n        kwargs = self.build_kwargs(energysystem)\n\n        return solph.NonConvex(**kwargs)\n</code></pre>"},{"location":"ensys/components/nonconvex/#components.nonconvex.EnNonConvex.to_oemof","title":"<code>to_oemof(energysystem)</code>","text":"<p>Converts the given energy system into an oemof.solph.NonConvex object using parameters built by the <code>build_kwargs</code> method. This function prepares the necessary parameters by interacting with the provided energy system and constructs the required non-convex properties for the output.</p> <p>Parameters:</p> Name Type Description Default <code>energysystem</code> <code>EnergySystem</code> <p>The energy system instance that holds the data and configuration required to create an <code>oemof.solph.NonConvex</code> object.</p> required <p>Returns:</p> Type Description <code>solph.NonConvex</code> <p>An instance of <code>solph.NonConvex</code> configured with the parameters derived from the input energy system.</p> Source code in <code>ensys/components/nonconvex.py</code> <pre><code>def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.NonConvex:\n    \"\"\"\n    Converts the given energy system into an oemof.solph.NonConvex object using\n    parameters built by the `build_kwargs` method. This function prepares the\n    necessary parameters by interacting with the provided energy system and\n    constructs the required non-convex properties for the output.\n\n    :param energysystem: The energy system instance that holds the data and\n        configuration required to create an `oemof.solph.NonConvex` object.\n    :return: An instance of `solph.NonConvex` configured with the parameters\n        derived from the input energy system.\n    :rtype: solph.NonConvex\n    \"\"\"\n    kwargs = self.build_kwargs(energysystem)\n\n    return solph.NonConvex(**kwargs)\n</code></pre>"},{"location":"ensys/components/sink/","title":"Sink","text":""},{"location":"ensys/components/sink/#components.sink.EnSink","title":"<code>EnSink</code>","text":"<p>               Bases: <code>EnBaseModel</code></p> <p>Represents a sink in an energy system model.</p> <p>A sink is used to define endpoints for energy flows within the context of the oemof energy system framework. This class includes attributes for defining the sink's label and its inputs, which specify the inflow connections to the sink. Each sink object must have a unique label for identification. Inputs are represented as a dictionary of node-inflow mappings.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>A string representing the unique label of the Sink object.</p> <code>inputs</code> <code>dict[str, EnFlow]</code> <p>A dictionary mapping input nodes to their respective EnFlow objects, which define the input values.</p> Source code in <code>ensys/components/sink.py</code> <pre><code>class EnSink(EnBaseModel):\n    \"\"\"\n    Represents a sink in an energy system model.\n\n    A sink is used to define endpoints for energy flows within the\n    context of the oemof energy system framework. This class includes\n    attributes for defining the sink's label and its inputs, which\n    specify the inflow connections to the sink. Each sink object must\n    have a unique label for identification. Inputs are represented\n    as a dictionary of node-inflow mappings.\n\n    :ivar label: A string representing the unique label of the Sink\n                 object.\n    :type label: str\n    :ivar inputs: A dictionary mapping input nodes to their respective\n                  EnFlow objects, which define the input values.\n    :type inputs: dict[str, EnFlow]\n    \"\"\"\n    label: str = Field(\n        \"Default Sink\",\n        title='Label',\n        description='String holding the label of the Sink object. The label of each object must be unique.'\n    )\n\n    inputs: dict[str, EnFlow] = Field(\n        ...,\n        title='Inputs',\n        description='A dictionary mapping input nodes to corresponding inflows (i.e. input values).'\n    )\n\n    def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.components.Sink:\n        \"\"\"\n        Converts the current energy system object to an oemof `Sink` component.\n\n        This method transforms the energy system data into a format compatible with\n        oemof.solph by constructing the necessary keyword arguments and returning an\n        instance of `solph.components.Sink`.\n\n        :param energysystem: The oemof.solph EnergySystem instance to which the data\n            will be transferred.\n        :type energysystem: solph.EnergySystem\n        :return: An oemof.solph Sink component created using the current energy system\n            parameters.\n        :rtype: solph.components.Sink\n        \"\"\"\n        kwargs = self.build_kwargs(energysystem)\n\n        return solph.components.Sink(**kwargs)\n</code></pre>"},{"location":"ensys/components/sink/#components.sink.EnSink.to_oemof","title":"<code>to_oemof(energysystem)</code>","text":"<p>Converts the current energy system object to an oemof <code>Sink</code> component.</p> <p>This method transforms the energy system data into a format compatible with oemof.solph by constructing the necessary keyword arguments and returning an instance of <code>solph.components.Sink</code>.</p> <p>Parameters:</p> Name Type Description Default <code>energysystem</code> <code>EnergySystem</code> <p>The oemof.solph EnergySystem instance to which the data will be transferred.</p> required <p>Returns:</p> Type Description <code>solph.components.Sink</code> <p>An oemof.solph Sink component created using the current energy system parameters.</p> Source code in <code>ensys/components/sink.py</code> <pre><code>def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.components.Sink:\n    \"\"\"\n    Converts the current energy system object to an oemof `Sink` component.\n\n    This method transforms the energy system data into a format compatible with\n    oemof.solph by constructing the necessary keyword arguments and returning an\n    instance of `solph.components.Sink`.\n\n    :param energysystem: The oemof.solph EnergySystem instance to which the data\n        will be transferred.\n    :type energysystem: solph.EnergySystem\n    :return: An oemof.solph Sink component created using the current energy system\n        parameters.\n    :rtype: solph.components.Sink\n    \"\"\"\n    kwargs = self.build_kwargs(energysystem)\n\n    return solph.components.Sink(**kwargs)\n</code></pre>"},{"location":"ensys/components/source/","title":"Source","text":""},{"location":"ensys/components/source/#components.source.EnSource","title":"<code>EnSource</code>","text":"<p>               Bases: <code>EnBaseModel</code></p> <p>Represents an energy source model within the system.</p> <p>This class is used to define a source object with unique attributes such as a label and outputs. It is part of a model system and can interface with external libraries to represent energy system components.</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code> <p>A string holding the label of the Source object. The label of each object must be unique to ensure proper identification.</p> <code>outputs</code> <code>dict[str, EnFlow]</code> <p>A dictionary mapping input nodes to their corresponding outflows (i.e., output values) within the system.</p> Source code in <code>ensys/components/source.py</code> <pre><code>class EnSource(EnBaseModel):\n    \"\"\"\n    Represents an energy source model within the system.\n\n    This class is used to define a source object with unique attributes such as\n    a label and outputs. It is part of a model system and can interface with\n    external libraries to represent energy system components.\n\n    :ivar label: A string holding the label of the Source object. The label of\n        each object must be unique to ensure proper identification.\n    :type label: str\n    :ivar outputs: A dictionary mapping input nodes to their corresponding outflows\n        (i.e., output values) within the system.\n    :type outputs: dict[str, EnFlow]\n    \"\"\"\n    label: str = Field(\n        \"Default Source\",\n        title='Label',\n        description='String holding the label of the Source object. The label of each object must be unique.'\n    )\n\n    outputs: dict[str, EnFlow] = Field(\n        ...,\n        title='Outputs',\n        description='A dictionary mapping input nodes to corresponding outflows (i.e. output values).'\n    )\n\n    def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.components.Source:\n        \"\"\"\n        Builds and returns an oemof.solph Source component from the specified energy system.\n\n        This method constructs necessary keyword arguments for creating an\n        oemof.solph Source component using the provided energy system. It utilizes\n        the `build_kwargs` method to generate the required arguments, and then creates\n        and returns the corresponding Source component.\n\n        :param energysystem: Energy system for which the oemof.solph Source component\n            is to be built.\n        :type energysystem: solph.EnergySystem\n        :return: An instance of solph.components.Source created based on the provided\n            energy system.\n        :rtype: solph.components.Source\n        \"\"\"\n        kwargs = self.build_kwargs(energysystem)\n\n        return solph.components.Source(**kwargs)\n</code></pre>"},{"location":"ensys/components/source/#components.source.EnSource.to_oemof","title":"<code>to_oemof(energysystem)</code>","text":"<p>Builds and returns an oemof.solph Source component from the specified energy system.</p> <p>This method constructs necessary keyword arguments for creating an oemof.solph Source component using the provided energy system. It utilizes the <code>build_kwargs</code> method to generate the required arguments, and then creates and returns the corresponding Source component.</p> <p>Parameters:</p> Name Type Description Default <code>energysystem</code> <code>EnergySystem</code> <p>Energy system for which the oemof.solph Source component is to be built.</p> required <p>Returns:</p> Type Description <code>solph.components.Source</code> <p>An instance of solph.components.Source created based on the provided energy system.</p> Source code in <code>ensys/components/source.py</code> <pre><code>def to_oemof(self, energysystem: solph.EnergySystem) -&gt; solph.components.Source:\n    \"\"\"\n    Builds and returns an oemof.solph Source component from the specified energy system.\n\n    This method constructs necessary keyword arguments for creating an\n    oemof.solph Source component using the provided energy system. It utilizes\n    the `build_kwargs` method to generate the required arguments, and then creates\n    and returns the corresponding Source component.\n\n    :param energysystem: Energy system for which the oemof.solph Source component\n        is to be built.\n    :type energysystem: solph.EnergySystem\n    :return: An instance of solph.components.Source created based on the provided\n        energy system.\n    :rtype: solph.components.Source\n    \"\"\"\n    kwargs = self.build_kwargs(energysystem)\n\n    return solph.components.Source(**kwargs)\n</code></pre>"},{"location":"frontend/dev/","title":"Frontend","text":"<p>Warning</p> <p>To be done.</p>"}]}